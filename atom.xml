<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>六个周</title>
  
  <subtitle>liugezhou</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liugezhou.online/"/>
  <updated>2019-12-10T07:15:46.027Z</updated>
  <id>http://liugezhou.online/</id>
  
  <author>
    <name>liugezhou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>No6.浏览器中的网络</title>
    <link href="http://liugezhou.online/2019/12/10/No6.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C/"/>
    <id>http://liugezhou.online/2019/12/10/No6.浏览器中的网络/</id>
    <published>2019-12-10T12:40:00.000Z</published>
    <updated>2019-12-10T07:15:46.027Z</updated>
    
    <content type="html"><![CDATA[<h6 id="谈及浏览器中的网络，就避不开-HTTP。我们知道-HTTP-是浏览器中最重要且使用最多的协议，是浏览器和服务器之间的通信语言，也是互联网的基石。而随着浏览器的发展，HTTP-为了能适应新的形式也在持续进化，学习-HTTP-的最佳途径就是了解其发展史，所以在接下来的三节文章中，从浏览器发展的视角来学习-HTTP-演进。这三节分别是即将完成使命的-HTTP-1、正在向我们走来的-HTTP-2，以及未来的-HTTP-3。"><a href="#谈及浏览器中的网络，就避不开-HTTP。我们知道-HTTP-是浏览器中最重要且使用最多的协议，是浏览器和服务器之间的通信语言，也是互联网的基石。而随着浏览器的发展，HTTP-为了能适应新的形式也在持续进化，学习-HTTP-的最佳途径就是了解其发展史，所以在接下来的三节文章中，从浏览器发展的视角来学习-HTTP-演进。这三节分别是即将完成使命的-HTTP-1、正在向我们走来的-HTTP-2，以及未来的-HTTP-3。" class="headerlink" title="谈及浏览器中的网络，就避不开 HTTP。我们知道 HTTP 是浏览器中最重要且使用最多的协议，是浏览器和服务器之间的通信语言，也是互联网的基石。而随着浏览器的发展，HTTP 为了能适应新的形式也在持续进化，学习 HTTP 的最佳途径就是了解其发展史，所以在接下来的三节文章中，从浏览器发展的视角来学习 HTTP 演进。这三节分别是即将完成使命的 HTTP/1、正在向我们走来的 HTTP/2，以及未来的 HTTP/3。"></a>谈及浏览器中的网络，就避不开 HTTP。我们知道 HTTP 是浏览器中最重要且使用最多的协议，是浏览器和服务器之间的通信语言，也是互联网的基石。而随着浏览器的发展，HTTP 为了能适应新的形式也在持续进化，学习 HTTP 的最佳途径就是了解其发展史，所以在接下来的三节文章中，从浏览器发展的视角来学习 HTTP 演进。这三节分别是即将完成使命的 HTTP/1、正在向我们走来的 HTTP/2，以及未来的 HTTP/3。</h6><a id="more"></a><h4 id="29-HTTP-1：HTTP性能优化"><a href="#29-HTTP-1：HTTP性能优化" class="headerlink" title="29 | HTTP/1：HTTP性能优化"></a>29 | HTTP/1：HTTP性能优化</h4><hr><blockquote><p>本文主要介绍的是 HTTP/1.1，我们先来学习下 HTTP/1.1 的进化史，然后再介绍在进化过程中所遇到的各种瓶颈，以及对应的解决方法。 </p></blockquote><h5 id="超文本传输协议HTTP-0-9"><a href="#超文本传输协议HTTP-0-9" class="headerlink" title="超文本传输协议HTTP/0.9"></a>超文本传输协议HTTP/0.9</h5><blockquote><p>HTTP/0.9 是于 1991 年提出的，主要用于学术交流，需求很简单——用来在网络之间传递<code>HTML 超文本</code>的内容，所以被称为<code>超文本传输协议</code>。<br>HTTP/0.9 的实现有以下三个特点:    </p><ul><li>第一个是只有一个请求行，并没有 HTTP 请求头和请求体，因为只需要一个请求行就可以完整表达客户端的需求了。  </li><li>第二个是服务器也没有返回头信息，这是因为服务器端并不需要告诉客户端太多信息，只需要返回数据就可以了。    </li><li>第三个是返回的文件内容是以 ASCII 字符流来传输的，因为都是 HTML 格式的文件，所以使用 ASCII 字节码来传输是最合适的。  </li></ul></blockquote><h5 id="被浏览器推动的HTTP-1-0"><a href="#被浏览器推动的HTTP-1-0" class="headerlink" title="被浏览器推动的HTTP/1.0"></a>被浏览器推动的HTTP/1.0</h5><blockquote><p>变化是这个世界永恒不变的主旋律，1994 年底出现了拨号上网服务，同年网景又推出一款浏览器，从此万维网就不局限于学术交流了，而是进入了高速的发展阶段。<br>万维网的高速发展带来了很多新的需求，而 HTTP/0.9 已经不能适用新兴网络的发展，所以这时就需要一个新的协议来支撑新兴网络，这就是 HTTP/1.0 诞生的原因。</p></blockquote><blockquote><p>新兴网络带来了新的需求：首先在浏览器中展示的不单是 HTML 文件了，还包括了 JavaScript、CSS、图片、音频、视频等不同类型的文件。因此支持多种类型的文件下载是 HTTP/1.0 的一个核心诉求，而且文件格式不仅仅局限于 ASCII 编码，还有很多其他类型编码的文件。   </p></blockquote><blockquote><p>为了让客户端和服务器能更深入地交流，HTTP/1.0 引入了<code>请求头</code>和<code>响应头</code>，它们都是以为 Key-Value 形式保存的，在 HTTP 发送请求时，会带上请求头信息，服务器返回数据时，会先返回响应头信息。<br>HTTP/1.0 的方案是通过请求头和响应头来进行协商，在发起请求时候会通过 HTTP 请求头告诉服务器它期待服务器返回什么类型的文件、采取什么形式的压缩、提供什么语言的文件以及文件的具体编码。</p></blockquote><h5 id="缝缝补补的HTTP-1-1"><a href="#缝缝补补的HTTP-1-1" class="headerlink" title="缝缝补补的HTTP/1.1"></a>缝缝补补的HTTP/1.1</h5><blockquote><p>技术继续发展、需求不断迭代更新，HTTP/1.0也不能满足需求了，HTTP/1.1又在HTTP/1.0上继续更新：</p></blockquote><h6 id="改进持久连接"><a href="#改进持久连接" class="headerlink" title="改进持久连接"></a>改进持久连接</h6><blockquote><p>HTTP/1.1 中增加了持久连接的方法，它的特点是在一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持。<br>HTTP 的持久连接可以有效减少 TCP 建立连接和断开连接的次数，这样的好处是减少了服务器额外的负担，并提升整体 HTTP 的请求时长。<br>持久连接在 HTTP/1.1 中是默认开启的，所以你不需要专门为了持久连接去 HTTP 请求头设置信息，如果你不想要采用持久连接，可以在 HTTP 请求头中加上Connection: close。目前浏览器中对于同一个域名，默认允许同时建立 6 个 TCP 持久连接.  </p></blockquote><h6 id="不成熟的HTTP管线化"><a href="#不成熟的HTTP管线化" class="headerlink" title="不成熟的HTTP管线化"></a>不成熟的HTTP管线化</h6><blockquote><p>如果 TCP 通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后面的所有请求，这就是著名的队头阻塞的问题。<br>HTTP/1.1 中试图通过管线化的技术来解决队头阻塞的问题。HTTP/1.1 中的管线化是指将多个 HTTP 请求整批提交给服务器的技术，虽然可以整批发送请求，不过服务器依然需要根据请求顺序来回复浏览器的请求。<br>FireFox、Chrome 都做过管线化的试验，但是由于各种原因，它们最终都放弃了管线化技术. </p></blockquote><h6 id="提供虚拟主机的支持"><a href="#提供虚拟主机的支持" class="headerlink" title="提供虚拟主机的支持"></a>提供虚拟主机的支持</h6><blockquote><p>在 HTTP/1.0 中，每个域名绑定了一个唯一的 IP 地址，因此一个服务器只能支持一个域名。<br>但是随着虚拟主机技术的发展，需要实现在一台物理主机上绑定多个虚拟主机，每个虚拟主机都有自己的单独的域名，这些单独的域名都公用同一个 IP 地址。<br>因此，HTTP/1.1 的请求头中增加了 Host 字段，用来表示当前的域名地址，这样服务器就可以根据不同的 Host 值做不同的处理。</p></blockquote><h6 id="对动态生成的内容提供了完美的支持"><a href="#对动态生成的内容提供了完美的支持" class="headerlink" title="对动态生成的内容提供了完美的支持"></a>对动态生成的内容提供了完美的支持</h6><blockquote><p>在设计 HTTP/1.0 时，需要在响应头中设置完整的数据大小，如Content-Length: 901，这样浏览器就可以根据设置的数据大小来接收数据。<br>不过随着服务器端的技术发展，很多页面的内容都是动态生成的，因此在传输数据之前并不知道最终的数据大小，这就导致了浏览器不知道何时会接收完所有的文件数据。<br>HTTP/1.1 通过引入 Chunk transfer 机制来解决这个问题，服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。这样就提供了对动态内容的支持。</p></blockquote><h6 id="客户端Cookie、安全机制"><a href="#客户端Cookie、安全机制" class="headerlink" title="客户端Cookie、安全机制"></a>客户端Cookie、安全机制</h6><blockquote><p>除此之外，HTTP/1.1 还引入了客户端 Cookie 机制和安全机制。</p></blockquote><h4 id="30-｜-HTTP-2：如何提升网络速度？"><a href="#30-｜-HTTP-2：如何提升网络速度？" class="headerlink" title="30 ｜ HTTP/2：如何提升网络速度？"></a>30 ｜ HTTP/2：如何提升网络速度？</h4><hr><blockquote><p>HTTP/1.1为网络效率做了大量的优化，最核心的三种方式为：    </p><ul><li>增加了持久连接。    </li><li>浏览器为每个域名最多同时支持6个TCP持久连接。    </li><li>使用CDN的实现域名分片机制。 </li></ul></blockquote><h5 id="HTTP-1-1的主要问题"><a href="#HTTP-1-1的主要问题" class="headerlink" title="HTTP/1.1的主要问题"></a>HTTP/1.1的主要问题</h5><blockquote><p>HTTP/1.1对带宽的利用率却并不理想，这也是 HTTP/1.1 的一个核心问题.<br>带宽是指每秒最大能发送或者接收的字节数。我们把每秒能发送的最大字节数称为上行带宽，每秒能够接收的最大字节数称为下行带宽。  </p></blockquote><blockquote><p>出现宽带利用率不理想的原因，主要为：  </p><ul><li>第一个原因，TCP的慢启动。   </li><li>第二个原因，同时开启了多条TCP连接，那么这些连接会竞争固定的宽带。   </li><li>第三个原因，HTTP/1.1队头阻塞的问题。</li></ul></blockquote><h5 id="HTTP-2的多路复用"><a href="#HTTP-2的多路复用" class="headerlink" title="HTTP/2的多路复用"></a>HTTP/2的多路复用</h5><blockquote><p>HTTP/2 的解决方案可以总结为：一个域名只使用一个 TCP 长连接和消除队头阻塞问题.<br>具体实现就是：通过引入二进制分帧层，实现 HTTP 的多路复用技术。</p></blockquote><h5 id="HTTP-2其他特性"><a href="#HTTP-2其他特性" class="headerlink" title="HTTP/2其他特性"></a>HTTP/2其他特性</h5><blockquote><ul><li>可以设置请求的优先级。  </li><li>服务器推送。    </li><li>头部压缩。  </li></ul></blockquote><blockquote><p>HTTP/2 协议规范于 2015 年 5 月正式发布，在那之后，该协议已在互联网和万维网上得到了广泛的实现和部署。从目前的情况来看，国内外一些排名靠前的站点基本都实现了 HTTP/2 的部署。使用 HTTP/2 能带来 20%～60% 的效率提升，至于 20% 还是 60% 要看优化的程度。总之，我们也应该与时俱进，放弃 HTTP/1.1 和其性能优化方法，去“拥抱”HTTP/2</p></blockquote><h4 id="31-HTTP-3-0-甩掉TCP、TLS的包袱，构建高效网络"><a href="#31-HTTP-3-0-甩掉TCP、TLS的包袱，构建高效网络" class="headerlink" title="31 | HTTP/3.0:甩掉TCP、TLS的包袱，构建高效网络"></a>31 | HTTP/3.0:甩掉TCP、TLS的包袱，构建高效网络</h4><blockquote><p>和通常一样，介绍 HTTP/3 之前，我们先来看看 HTTP/2 到底有什么缺陷。    </p></blockquote><h5 id="1-TCP的队头阻塞"><a href="#1-TCP的队头阻塞" class="headerlink" title="1.TCP的队头阻塞"></a>1.TCP的队头阻塞</h5><blockquote><p>在 TCP 传输过程中，由于单个数据包的丢失而造成的阻塞称为 TCP 上的队头阻塞。<br>有测试数据表明，当系统达到了 2% 的丢包率时，HTTP/1.1 的传输效率反而比 HTTP/2 表现得更好。 </p></blockquote><h5 id="2-TCP建立连接的延时"><a href="#2-TCP建立连接的延时" class="headerlink" title="2.TCP建立连接的延时"></a>2.TCP建立连接的延时</h5><blockquote><p>网络延迟又称为 RTT（Round Trip Time）。我们把从浏览器发送一个数据包到服务器，再从服务器返回数据包到浏览器的整个往返时间称为 RTT。RTT 是反映网络性能的一个重要指标。 </p></blockquote><h5 id="3-TCP协议僵化"><a href="#3-TCP协议僵化" class="headerlink" title="3.TCP协议僵化"></a>3.TCP协议僵化</h5><blockquote><p>虽然我们知道了TCP的队头阻塞和建立连接延时等缺点，但是通过改进TCP协议来解决这些问题非常困难，这里说的非常困难就是指TCP协议僵化。<br>TCP协议僵化体现在两个方面：第一个是中间设备的僵化；除中间设备的僵化外，操作系统也是导致TCP协议僵化的另外一个原因。    </p></blockquote><h5 id="QUIC协议"><a href="#QUIC协议" class="headerlink" title="QUIC协议"></a>QUIC协议</h5><blockquote><p>HTTP/3 选择了一个折衷的方法——UDP 协议，基于 UDP 实现了类似于 TCP 的多路数据流、传输可靠性等功能，我们把这套功能称为 QUIC 协议。<br>HTTP/3 中的 QUIC 协议集合了以下几点功能:</p></blockquote><blockquote><ul><li>实现了类似 TCP 的流量控制、传输可靠性的功能。虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。  </li><li>集成了 TLS 加密功能。   </li><li>实现了 HTTP/2 中的多路复用功能。  </li><li>实现了快速握手功能。    </li></ul></blockquote><h5 id="HTTP-3的挑战"><a href="#HTTP-3的挑战" class="headerlink" title="HTTP/3的挑战"></a>HTTP/3的挑战</h5><blockquote><p>通过上面的分析，我们相信在技术层面，HTTP/3 是个完美的协议。不过要将 HTTP/3 应用到实际环境中依然面临着诸多严峻的挑战，这些挑战主要来自于以下三个方面:  </p><ul><li>第一，从目前的情况来看，服务器和浏览器端都没有对 HTTP/3 提供比较完整的支持。Chrome 虽然在数年前就开始支持 Google 版本的 QUIC，但是这个版本的 QUIC 和官方的 QUIC 存在着非常大的差异。    </li><li>第二，部署 HTTP/3 也存在着非常大的问题。因为系统内核对 UDP 的优化远远没有达到 TCP 的优化程度，这也是阻碍 QUIC 的一个重要原因。  </li><li>第三，中间设备僵化的问题。这些设备对 UDP 的优化程度远远低于 TCP，据统计使用 QUIC 协议时，大约有 3%～7% 的丢包率。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;谈及浏览器中的网络，就避不开-HTTP。我们知道-HTTP-是浏览器中最重要且使用最多的协议，是浏览器和服务器之间的通信语言，也是互联网的基石。而随着浏览器的发展，HTTP-为了能适应新的形式也在持续进化，学习-HTTP-的最佳途径就是了解其发展史，所以在接下来的三节文章中，从浏览器发展的视角来学习-HTTP-演进。这三节分别是即将完成使命的-HTTP-1、正在向我们走来的-HTTP-2，以及未来的-HTTP-3。&quot;&gt;&lt;a href=&quot;#谈及浏览器中的网络，就避不开-HTTP。我们知道-HTTP-是浏览器中最重要且使用最多的协议，是浏览器和服务器之间的通信语言，也是互联网的基石。而随着浏览器的发展，HTTP-为了能适应新的形式也在持续进化，学习-HTTP-的最佳途径就是了解其发展史，所以在接下来的三节文章中，从浏览器发展的视角来学习-HTTP-演进。这三节分别是即将完成使命的-HTTP-1、正在向我们走来的-HTTP-2，以及未来的-HTTP-3。&quot; class=&quot;headerlink&quot; title=&quot;谈及浏览器中的网络，就避不开 HTTP。我们知道 HTTP 是浏览器中最重要且使用最多的协议，是浏览器和服务器之间的通信语言，也是互联网的基石。而随着浏览器的发展，HTTP 为了能适应新的形式也在持续进化，学习 HTTP 的最佳途径就是了解其发展史，所以在接下来的三节文章中，从浏览器发展的视角来学习 HTTP 演进。这三节分别是即将完成使命的 HTTP/1、正在向我们走来的 HTTP/2，以及未来的 HTTP/3。&quot;&gt;&lt;/a&gt;谈及浏览器中的网络，就避不开 HTTP。我们知道 HTTP 是浏览器中最重要且使用最多的协议，是浏览器和服务器之间的通信语言，也是互联网的基石。而随着浏览器的发展，HTTP 为了能适应新的形式也在持续进化，学习 HTTP 的最佳途径就是了解其发展史，所以在接下来的三节文章中，从浏览器发展的视角来学习 HTTP 演进。这三节分别是即将完成使命的 HTTP/1、正在向我们走来的 HTTP/2，以及未来的 HTTP/3。&lt;/h6&gt;
    
    </summary>
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>每周总结第二十二期</title>
    <link href="http://liugezhou.online/2019/12/07/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E6%9C%9F/"/>
    <id>http://liugezhou.online/2019/12/07/每周总结第二十二期/</id>
    <published>2019-12-07T14:08:00.000Z</published>
    <updated>2019-12-08T14:09:36.568Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这里记录过去一周，我的一些小总结。<br><img src="http://img.liugezhou.online/20191206weekly.jpeg" alt="weekly-22"></p></blockquote><a id="more"></a><h4 id="Feeling"><a href="#Feeling" class="headerlink" title="Feeling"></a>Feeling</h4><blockquote><p>推出一个新产品很难，组建一个能够持续推出新产品的团队更难。<br>我最引以为傲的产品，就是苹果公司和我在苹果公司建立的团队。<br><cite>史蒂夫·乔布斯</cite></p></blockquote><h4 id="消费者办手机号全面开启人脸比对"><a href="#消费者办手机号全面开启人脸比对" class="headerlink" title="消费者办手机号全面开启人脸比对"></a>消费者办手机号全面开启人脸比对</h4><blockquote><p>据工信部的相关规定，自12月1日起，电信企业需在实体渠道全面实施人像比对技术措施，人像比对一致方可办理入网手续。<br>这意味着，今后，中国所有注册新SIM卡的手机用户都必须接受面部识别扫描。同时，规定要求电信企业部署“人工智能和其他技术方法”以检查注册SIM卡的人员的身份。<br>今年以来，人脸识别技术在国内出现了一系列的负面新闻，比如曾红极一时的换脸软件——ZAO，还有一位大学教授起诉动物园违规采集面部信息的“中国人脸识别第一案”。这些事件背后，说明中国人脸识别行业缺乏统一标准，管理仍然比较混乱，对用户的隐私保护做得不到位。就像“办手机卡”这件事，已经有一些声音开始担心：电信运营商真的能保证我们的人脸数据不外泄吗,不会用于其他的某方面用途吗？</p></blockquote><h4 id="华为作过的恶"><a href="#华为作过的恶" class="headerlink" title="华为作过的恶"></a><a href="https://github.com/evil-huawei/evil-huawei" target="_blank" rel="noopener">华为作过的恶</a></h4><blockquote><p>Gitub上，本周star数凑凑上涨的一个项目：<br>项目介绍：「由于部分内容被控评和删帖，已经无法在中文互联网搜索到，所以本项目将收集华为作过的恶，记录这些不应该被遗忘的历史。」</p></blockquote><h4 id="一键抠图神器"><a href="#一键抠图神器" class="headerlink" title="一键抠图神器"></a><a href="http://www.picup.ai/#/" target="_blank" rel="noopener">一键抠图神器</a></h4><blockquote><p>识别图像中的人体轮廓，与背景进行分离.有人体抠图和物体抠图。   </p></blockquote><h4 id="沙拉查词"><a href="#沙拉查词" class="headerlink" title="沙拉查词"></a>沙拉查词</h4><blockquote><p>一款浏览器插件，推荐。<br><img src="https://user-gold-cdn.xitu.io/2019/10/21/16dec06bb7790bd3?imageView2/2/w/800/q/85" alt="查词"></p></blockquote><h4 id="Grid-代码生成器"><a href="#Grid-代码生成器" class="headerlink" title="Grid 代码生成器"></a><a href="https://cssgrid-generator.netlify.com/" target="_blank" rel="noopener">Grid 代码生成器</a></h4><blockquote><p>可视化地配置 Grid，你可以设置行与列的个数、指定每个格子的类、长宽占比、行间距与列间距大小等，再一键生成 Grid 的 CSS 代码.<br><img src="https://user-gold-cdn.xitu.io/2019/12/6/16eda0f218272486?imageView2/2/w/800/q/85" alt="演示"></p></blockquote><h4 id="GitHub中文排行榜"><a href="#GitHub中文排行榜" class="headerlink" title="GitHub中文排行榜"></a><a href="https://github.com/kon9chunkit/GitHub-Chinese-Top-Charts" target="_blank" rel="noopener">GitHub中文排行榜</a></h4><blockquote><p>GitHub中文排行榜，帮助你发现高分优秀中文项目、更高效地吸收国人的优秀经验成果；榜单每周更新一次.   </p></blockquote><h4 id="浏览器中的页面"><a href="#浏览器中的页面" class="headerlink" title="浏览器中的页面"></a><a href="https://www.liugezhou.online/2019/12/03/No5.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E9%A1%B5%E9%9D%A2/" target="_blank" rel="noopener">浏览器中的页面</a></h4><blockquote><p>前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。<br>本篇是这个专栏的第四章：<a href="https://www.liugezhou.online/2019/12/03/No5.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E9%A1%B5%E9%9D%A2/" target="_blank" rel="noopener">浏览器中的页面</a>。本章分为八讲。</p></blockquote><h4 id="HTTP请求中的Form-Data和Request-Payload的区别"><a href="#HTTP请求中的Form-Data和Request-Payload的区别" class="headerlink" title="HTTP请求中的Form Data和Request Payload的区别"></a>HTTP请求中的Form Data和Request Payload的区别</h4><blockquote><p>前端开发中经常会用到AJAX发送异步请求，对于POST类型的请求会附带请求数据。而常用的两种传参方式为：Form Data 和 Request Payload。    </p></blockquote><blockquote><p>方式一： Form Data形式<br>当POST请求的请求头里设置Content-Type: application/x-www-form-urlencoded(默认), 参数在请求体以标准的Form Data的形式提交，以&amp;符号拼接，参数格式为key=value&amp;key=value&amp;key=value…<br>方式二：Request Payload形式<br>如果使用AJAX原生POST请求,请求头里设置Content-Type:application/json，请求的参数会显示在Request Payload中，参数格式为JSON格式：{“key”:”value”,”key”:”value”…}，这种方式可读性会更好. 后端可以使用getRequestPayload方法来获取.<br><code>Form Data 和 Request Payload 区别</code><br>如果请求头里设置Content-Type: application/x-www-form-urlencoded，那么这个请求被认为是表单请求，参数出现在Form Data里，格式为key=value&amp;key=value&amp;key=value…<br>原生的AJAX请求头里设置Content-Type:application/json，或者使用默认的请求头Content-Type:text/plain;参数会显示在Request payload块里提交。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这里记录过去一周，我的一些小总结。&lt;br&gt;&lt;img src=&quot;http://img.liugezhou.online/20191206weekly.jpeg&quot; alt=&quot;weekly-22&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="每周分享" scheme="http://liugezhou.online/categories/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="每周分享" scheme="http://liugezhou.online/tags/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>No5.浏览器中的页面</title>
    <link href="http://liugezhou.online/2019/12/03/No5.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E9%A1%B5%E9%9D%A2/"/>
    <id>http://liugezhou.online/2019/12/03/No5.浏览器中的页面/</id>
    <published>2019-12-03T12:40:00.000Z</published>
    <updated>2019-12-06T02:49:13.345Z</updated>
    
    <content type="html"><![CDATA[<h6 id="前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。"><a href="#前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。" class="headerlink" title="前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。"></a>前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。</h6><h6 id="本篇是这个专栏的第五章：《No5-浏览器中的页面》。本章分为八节。"><a href="#本篇是这个专栏的第五章：《No5-浏览器中的页面》。本章分为八节。" class="headerlink" title="本篇是这个专栏的第五章：《No5.浏览器中的页面》。本章分为八节。"></a>本篇是这个专栏的第五章：《No5.浏览器中的页面》。本章分为八节。</h6><a id="more"></a><h4 id="21-｜-Chrome开发者工具：利用网络面板做性能分析"><a href="#21-｜-Chrome开发者工具：利用网络面板做性能分析" class="headerlink" title="21 ｜ Chrome开发者工具：利用网络面板做性能分析"></a>21 ｜ Chrome开发者工具：利用网络面板做性能分析</h4><hr><blockquote><p>本节首先对开发者工具的各个模块进行了一个简单介绍，然后重点讲解的是NetWork面板。<br>网络面板包括：控制器、过滤器、抓图信息、时间线、详细列表和下载信息概要六个区域构成。    </p></blockquote><h5 id="1-控制器"><a href="#1-控制器" class="headerlink" title="1.控制器"></a>1.控制器</h5><blockquote><ul><li>“开始/暂停”抓包。   </li><li>全局搜索。    </li><li>Disable cache:禁止从Cache中加载资源。</li><li>Online按钮：模拟2G/3G 网络，模拟弱网环境。  </li></ul></blockquote><h5 id="2-过滤器"><a href="#2-过滤器" class="headerlink" title="2.过滤器"></a>2.过滤器</h5><blockquote><p>过滤功能。 </p></blockquote><h5 id="3-抓图信息"><a href="#3-抓图信息" class="headerlink" title="3.抓图信息"></a>3.抓图信息</h5><blockquote><p>抓图信息区域，可以用来分析用户等待页面加载时间内所看到的内容，分析用户实际的体验情况。  </p></blockquote><h5 id="4-时间线"><a href="#4-时间线" class="headerlink" title="4.时间线"></a>4.时间线</h5><blockquote><p>时间线，主要用来展示 HTTP、HTTPS、WebSocket 加载的状态和时间的一个关系，用于直观感受页面的加载过程。</p></blockquote><h5 id="5-详细列表"><a href="#5-详细列表" class="headerlink" title="5.详细列表"></a>5.详细列表</h5><blockquote><p>详细记录了每个资源从发起请求到完成请求这中间所有过程的状态，以及最终请求完成的数据信息.<br>Queuing：当浏览器发起一个请求的时候，会有很多原因导致该请求不能被立即执行，而是需要排队等待。<br>Stalled： 在发起连接之前，还有一些原因可能导致连接过程被推迟，这个推迟就表现在面板中的 Stalled 上。<br>Proxy Negotiation:若使用代理服务器，会增加一个此阶段。<br>Waiting (TTFB):通常也称为“第一字节时间”。 TTFB 是反映服务端响应速度的重要指标，对服务器来说，TTFB 时间越短，就说明服务器响应越快。<br>Content Download :这意味着从第一字节时间到接收到全部响应数据所用的时间。  </p></blockquote><h5 id="6-下载信息概要"><a href="#6-下载信息概要" class="headerlink" title="6.下载信息概要"></a>6.下载信息概要</h5><blockquote><p>重点关注 DOMContentLoaded和Load两个事件。 </p><ul><li>DOMContentLoaded:这个事件发生后，说明页面已经构建好DOM了，即DOM需要的HTML、JavaScript、CSS等文件已下载完成了。  </li><li>Load：说明浏览器已经加载了所有的资源(图像、样式等)。    </li></ul></blockquote><h4 id="22-DOM树：JavaScript是如何影响DOM树构建的？"><a href="#22-DOM树：JavaScript是如何影响DOM树构建的？" class="headerlink" title="22 | DOM树：JavaScript是如何影响DOM树构建的？"></a>22 | DOM树：JavaScript是如何影响DOM树构建的？</h4><hr><h5 id="什么是DOM"><a href="#什么是DOM" class="headerlink" title="什么是DOM"></a>什么是DOM</h5><blockquote><p>DOM 是表述 HTML 的内部数据结构，它会将 Web 页面和 JavaScript 脚本连接起来，并过滤一些不安全的内容。   </p></blockquote><h5 id="DOM树如何生成"><a href="#DOM树如何生成" class="headerlink" title="DOM树如何生成"></a>DOM树如何生成</h5><blockquote><p>在渲染引擎内部，有一个叫 HTML 解析器（HTMLParser）的模块，它的职责就是负责将 HTML 字节流转换为 DOM 结构。<br>HTML解析器过程是：网络进程加载了多少数据，HTML解析器便解析多少数据。  </p></blockquote><h5 id="JavaScript是如何影响DOM生成的"><a href="#JavaScript是如何影响DOM生成的" class="headerlink" title="JavaScript是如何影响DOM生成的"></a>JavaScript是如何影响DOM生成的</h5><blockquote><ul><li>在两段 div 中间插入了一段 JavaScript 脚本：当HTML解析器解析到script标签的时候会暂停DOM解析，去执行这段JS脚本。 </li><li>在页面中引入 JavaScript文件：整个执行流程还是一样的，执行到 JavaScript 标签时，暂停整个 DOM 的解析，执行 JavaScript 代码，不过这里执行 JavaScript 时，需要先<code>下载这段 JavaScript 代码</code>。这里需要重点关注<code>下载环境</code>，因为 JavaScript 文件的下载过程会阻塞 DOM 解析(Chrome浏览器做的一个主要优化是预解析操作)。<br>另外也有一些相关的策略：比如使用 CDN 来加速 JavaScript 文件的加载，压缩 JavaScript 文件的体积。如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为<code>异步加载</code>，通过 <code>async</code>或<code>defer</code> 来标记代码.  </li></ul><ol><li>async:使用 async 标志的脚本文件一旦加载完成，会立即执行.    </li><li>defer:使用了 defer 标记的脚本文件，需要在 DOMContentLoaded 事件之前执行.</li></ol></blockquote><blockquote><p>通过上面的分析，我们知道了 JavaScript 会阻塞 DOM 生成，而样式文件又会阻塞 JavaScript 的执行，所以在实际的工程中需要重点关注 JavaScript 文件和样式表文件，使用不当会影响到页面性能的。</p></blockquote><h4 id="23-｜-渲染流水线：CSS如何影响首次加载时的白屏问题"><a href="#23-｜-渲染流水线：CSS如何影响首次加载时的白屏问题" class="headerlink" title="23 ｜ 渲染流水线：CSS如何影响首次加载时的白屏问题"></a>23 ｜ 渲染流水线：CSS如何影响首次加载时的白屏问题</h4><hr><blockquote><p>CSS资源是页面中非常重要的一环，本节首先站在渲染流水线的视角来介绍CSS是如何工作的、然后通过CSS工作流程来分分析性能瓶颈、最后讨论如何减少首次加载时的白屏问题。 </p></blockquote><h5 id="渲染流水线视角下的CSS"><a href="#渲染流水线视角下的CSS" class="headerlink" title="渲染流水线视角下的CSS"></a>渲染流水线视角下的CSS</h5><blockquote><p>首先是发起页面请求，网络进程接收到返回的HTML数据，将其发送给渲染进程，渲染进程解析HTML数据并构建DOM。<br>需要特别注意下，请求 HTML 数据和构建 DOM 中间有一段空闲时间，这个空闲时间有可能成为页面渲染的瓶颈。   </p></blockquote><blockquote><p>前面提到一嘴：Chrome浏览器做的一个主要优化是预解析操作。<br>因此，Chrome开启这个预解析进程后，在遇到JavaScript或CSS文件后，会提前下载这些文件。<br>这里也有一个空闲时间需要注意一下，就是在 DOM 构建结束之后、css 文件还未下载完成的这段时间内，渲染流水线无事可做，因为下一步是合成布局树，而合成布局树需要 CSSOM 和 DOM，所以这里需要等待 CSS 加载结束并解析成 CSSOM。 </p></blockquote><blockquote><p>CSSOM的两个作用： </p><ul><li>提供给 JavaScript 操作样式表的能力. </li><li>为布局树的合成提供基础的样式信息。</li></ul></blockquote><h5 id="影响页面展示的因素以及优化策略"><a href="#影响页面展示的因素以及优化策略" class="headerlink" title="影响页面展示的因素以及优化策略"></a>影响页面展示的因素以及优化策略</h5><blockquote><p>从发起 URL 请求开始，到首次显示页面的内容，在视觉上经历的三个阶段:    </p><ol><li>等请求发出去之后，到提交数据阶段，这时页面展示出来的还是之前页面的内容。   </li><li>提交数据之后渲染进程会创建一个空白页面，我们通常把这段时间称为解析白屏，并等待 CSS 文件和 JavaScript 文件的加载完成，生成 CSSOM 和 DOM，然后合成布局树，最后还要经过一系列的步骤准备首次渲染.  </li><li>等首次渲染完成之后，就开始进入完整页面的生成阶段了，然后页面会一点点被绘制出来。   </li></ol></blockquote><blockquote><p>这里重点关注第二个阶段：<br>该阶段的主要任务包括了：解析 HTML、下载 CSS、下载 JavaScript、生成 CSSOM、执行 JavaScript、生成布局树、绘制页面一系列操作。<br>对应策略：</p><ul><li>通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。    </li><li>但并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。 </li><li>还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 sync 或者 defer。    </li><li>对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。 </li></ul></blockquote><h4 id="24-分层和合成机制：为什么CSS动画比JavaScript高效"><a href="#24-分层和合成机制：为什么CSS动画比JavaScript高效" class="headerlink" title="24 | 分层和合成机制：为什么CSS动画比JavaScript高效"></a>24 | 分层和合成机制：为什么CSS动画比JavaScript高效</h4><hr><blockquote><p>在第五节的时候，我们知道DOM构建成功后还要经历布局、分层、绘制、合成、显示等阶段后才能显示出漂亮的页面。<br>这一节主要讲解的是渲染引擎的分层和合成机制，作者说分层和合成机制代表了浏览器最为先进的合成技术，请注意是<code>最为先进的</code>. </p></blockquote><h5 id="显示器是怎么显示图像的"><a href="#显示器是怎么显示图像的" class="headerlink" title="显示器是怎么显示图像的"></a>显示器是怎么显示图像的</h5><blockquote><p>每个显示器的固定刷新频率通常是60HZ，即每秒更新60张图片，更新的图片都来自显卡中一个叫前缓冲区的地方，，显示器所做的任务很简单，就是每秒固定读取 60 次前缓冲区中的图像，并将读取的图像显示到显示器上。<br>显卡的作用：显卡的职责就是合成新的图像，并将图像保存到后缓冲区中，一旦显卡把合成的图像写到后缓冲区，系统就会让后缓冲区和前缓冲区互换，这样就能保证显示器能读取到最新显卡合成的图像。  </p></blockquote><h5 id="帧-VS-帧率"><a href="#帧-VS-帧率" class="headerlink" title="帧 VS 帧率"></a>帧 VS 帧率</h5><blockquote><p>渲染流水线生成的每一张图片称为一帧，渲染流水线每秒更新了多少帧称为帧率。  </p></blockquote><h5 id="如何生成一帧图像"><a href="#如何生成一帧图像" class="headerlink" title="如何生成一帧图像"></a>如何生成一帧图像</h5><blockquote><p>生成一帧图像有三种方式：重排、重绘、合成。 这三种方式的渲染路径不同，通常渲染路径越长，生成图像花费的时间越久。<br>这里聚焦点在合成上 ，为了提升每帧的渲染效率，Chrome 引入了分层和合成的机制，Chrome的合成技术用三个词来概括：分层、分块、合成。</p></blockquote><h5 id="分层和合成"><a href="#分层和合成" class="headerlink" title="分层和合成"></a>分层和合成</h5><blockquote><p>你可以把一张网页想象成是由很多个图片叠加在一起的，每个图片就对应一个图层，将素材分解为多个图层的操作就称为分层。最后将这些图层合并到一起的操作就称为合成。<br>在Chrome渲染流水线中，分层体现在生成布局树之后，渲染引擎根据布局树的特点将其转化为层树，层树是渲染流水线后续流程的基础结构。<br>需要重点关注的是，合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的。这就是为什么经常主线程卡住了，但是 CSS 动画依然能执行的原因。</p></blockquote><h5 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h5><blockquote><p>如果说分层是从宏观上提升了渲染效率，那么分块则是从微观层面提升了渲染效率。<br>在首次合成图块的时候使用一个低分辨率的图片。</p></blockquote><h5 id="如何利用分层技术优化代码"><a href="#如何利用分层技术优化代码" class="headerlink" title="如何利用分层技术优化代码"></a>如何利用分层技术优化代码</h5><blockquote><p>在写 Web 应用的时候，你可能经常需要对某个元素做几何形状变换、透明度变换或者一些缩放操作，如果使用 JavaScript 来写这些效果，会牵涉到整个渲染流水线，所以 JavaScript 的绘制效率会非常低下.<br>这时你可以使用 will-change 来告诉渲染引擎你会对该元素做一些特效变换，CSS 代码如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    will-change: transform, opacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这段代码就是提前告诉渲染引擎 box 元素将要做几何变换和透明度变换操作，这时候渲染引擎会将该元素单独实现一帧，等这些变换发生时，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就大大提升了渲染的效率。这也是 CSS 动画比 JavaScript 动画高效的原因.   </p></blockquote><h4 id="25-｜-页面性能：如何系统地优化页面？"><a href="#25-｜-页面性能：如何系统地优化页面？" class="headerlink" title="25 ｜ 页面性能：如何系统地优化页面？"></a>25 ｜ 页面性能：如何系统地优化页面？</h4><hr><blockquote><p>本节所谈论的页面优化，其实就是让页面更快的显示和响应。<br>通常一个页面有三个阶段：加载阶段、交互阶段和关闭阶段。    </p><ul><li>加载阶段，是指从发出请求到渲染出完整页面的过程，影响到这个阶段的主要因素有网络和 JavaScript 脚本。  </li><li>交互阶段，主要是从页面加载完成到用户交互的整合过程，影响到这个阶段的主要因素是 JavaScript 脚本。    </li><li>关闭阶段，主要是用户发出关闭指令后页面所做的一些清理操作。<br>这里我们需要重点关注加载阶段和交互阶段，因为影响到我们体验的因素主要都在这两个阶段.</li></ul></blockquote><h5 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h5><blockquote><p>并非所有的资源都会阻塞页面的首次绘制，比如图片、音频、视频等文件就不会阻塞页面的首次渲染。而JavaScript、首次请求的HTML资源文件、CSS文件是会阻塞首次渲染的。把这些能阻塞页面渲染的称为关键资源。基于关键资源，细化出三个影响页面首次渲染的核心因素：   </p><ul><li>第一个是关键资源个数。  </li><li>第二个是关键资源大小。  </li><li>第三个是请求关键资源需要多少个RTT(Round Trip Time).[通常1个HTTP的数据包在14KB左右，所以0.1M的页面需要拆分成8个包来传输，也就是说需要8个RTT]。   </li></ul></blockquote><blockquote><p>然后针对核心因素，考虑优化方案：总的优化原则就是减少关键资源个数、降低关键资源大小、降低关键资源的RTT次数。</p></blockquote><h5 id="交互阶段"><a href="#交互阶段" class="headerlink" title="交互阶段"></a>交互阶段</h5><blockquote><p>交互阶段的优化，一个大的原则就是让单个帧的生成速度变快。  </p><ol><li>减少JavaScript脚本执行时间。</li><li>避免强制同步布局。【所谓强制同步布局，是指JavaScript强制将计算样式和布局操作提前到当前的任务中。】 </li><li>避免布局抖动。 </li><li>合理利用CSS合成动画。  </li><li>避免频繁的垃圾回收。   </li></ol></blockquote><h4 id="26-｜-虚拟DOM：虚拟DOM和实际的DOM有何不同？"><a href="#26-｜-虚拟DOM：虚拟DOM和实际的DOM有何不同？" class="headerlink" title="26 ｜ 虚拟DOM：虚拟DOM和实际的DOM有何不同？"></a>26 ｜ 虚拟DOM：虚拟DOM和实际的DOM有何不同？</h4><hr><blockquote><p>本节先聊一些DOM的缺陷，然后在此基础上介绍虚拟DOM如何解决这些缺陷，最后站在双缓存和MVC的视角来聊聊虚拟DOM。</p></blockquote><h5 id="DOM的缺陷"><a href="#DOM的缺陷" class="headerlink" title="DOM的缺陷"></a>DOM的缺陷</h5><blockquote><p>通过前面对DOM的学习，我们知道对于一些复杂的页面或者目前使用非常多的单页面应用来说，其DOM结构复杂，每次操作需要去不断修改DOM树，每次操作渲染引擎都需要进行重绘、重排或者合成操作，执行一次重排或者重绘操作是非常耗时的，这样就带来了性能问题。<br>所以就需要一直方式来减少JavaScript对DOM的操作，这时候虚拟DOM就上场了。    </p></blockquote><h5 id="什么是虚拟DOM"><a href="#什么是虚拟DOM" class="headerlink" title="什么是虚拟DOM"></a>什么是虚拟DOM</h5><blockquote><p>虚拟DOM要解决的事情：  </p><ul><li>将页面改变的内容应用到虚拟DOM上，而不是直接应用在DOM上。  </li><li>变化被应用到虚拟DOM上时，虚拟DOM并不急着去渲染页面，而仅仅是调整虚拟DOM的内部状态，这样操作虚拟DOM的代价就变得非常轻了。    </li><li>在虚拟DOM收集到足够的改变时，再把这些变化一次性应用到真实的DOM上。  </li></ul></blockquote><blockquote><p>接下来从双缓存和MVC模型这两个视角来聊聊虚拟DOM：  </p><ul><li><ol><li>双缓存<br>双换粗是一种经典的思路，应用哎很多场合，能解决页面无效刷新和闪屏的问题，虚拟DOM就是双缓存思想的一种实现。<br>使用双缓存，可以先将计算的中间结果存放到另一个缓冲区中，等全部的计算结束，该缓冲区已经存储了完整的图形，这样使得整个图像的输出非常稳定。  </li></ol></li></ul><ol start="2"><li>MVC模式<br>基于MVC的设计思想广泛地渗透到各种场合，且基于MVC又衍生出了很多其他模式(如MVP、MVVM)，不过万变不离其宗，它们的基础框架都是基于MVC而来。站在MVC视角来理解虚拟DOM能让你看到更为“广阔的世界”. </li></ol></blockquote><h4 id="27-渐进式网页应用-PWA-它究竟解决了Web应用的哪些问题？"><a href="#27-渐进式网页应用-PWA-它究竟解决了Web应用的哪些问题？" class="headerlink" title="27 | 渐进式网页应用(PWA):它究竟解决了Web应用的哪些问题？"></a>27 | 渐进式网页应用(PWA):它究竟解决了Web应用的哪些问题？</h4><hr><blockquote><p>PWA,全称是Progressive Web App，渐进式网页应用。   </p></blockquote><blockquote><p>渐进式：</p><ul><li>站在Web应用开发者来说，PWA提供了一个渐进式的过度方案，让普通站点逐步过度到Web应用。采取渐进式可以降低站点改造的代价，使得站点逐步支持各项新技术，而不是一步到位。   </li><li>站在技术角度来说，PWA技术也是一个渐进式的演化过程，在技术层面会一点点演进，比如逐渐提供更好的设备特性支持，不断优化更加流畅的动画效果，不断让页面的加载速度变得更快，不断实现本地应用的特性。<br>可以这么理解：PWA是一套理念，渐进式增强Web的优势，并通过技术手段渐进式缩短和本地应用或者小程序的距离。</li></ul></blockquote><h5 id="Web应用-VS-本地应用"><a href="#Web应用-VS-本地应用" class="headerlink" title="Web应用 VS 本地应用"></a>Web应用 VS 本地应用</h5><blockquote><p>相较于本地应用，Web应用缺陷：   </p><ul><li>首先，Web应用缺少离线使用能力，在离线或者弱网环境下基本上是无法使用的。 </li><li>其次，Web应用还缺少了消息推送的能力。   </li><li>最后，Web缺少一级入口。</li></ul></blockquote><blockquote><p>针对以上缺陷，PWA提出了两种解决方案：通过引入Service Worker来试着解决离线存储和消息推送的问题，通过引入manifest.json来解决一级入口的问题。</p></blockquote><h5 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h5><blockquote><p>在2014年的时候，标准委员会就提出来Service Worker的概念，主要思想是在页面和网络之间增加一个拦截器，主要功能就是用来缓存资源和拦截请求。</p></blockquote><blockquote><p>设计思路：<br>为避免JavaScript过多占用页面主线程时长的情况，浏览器实现了Web Worker的功能。Web Worker的目的是让JavaScript能够运行在页面主线程之外，且只能执行一些与DOM无关的JS脚本。在Chrome中，Web Worker其实就是在渲染进程中开启一个新线程，它的生命周期和页面关联。<br>“让其运行在主线程之外”就是Service Worker来自Web Worker的一个核心思想。但需要在Web Worker的基础上加上储存功能。且Service Worker还需要会为多个页面提供服务，所以还不能把Service Worker和单个页面绑定起来。<br>消息推送也是基于Service Worker来实现的。<br>最后，若要使站点支持Service Worker，首先必要的一步就是要将站点升级到HTTPS。</p></blockquote><h4 id="28-｜-WebComponent：像搭积木一样构建Web应用"><a href="#28-｜-WebComponent：像搭积木一样构建Web应用" class="headerlink" title="28 ｜ WebComponent：像搭积木一样构建Web应用"></a>28 ｜ WebComponent：像搭积木一样构建Web应用</h4><hr><blockquote><p>首先，本节介绍了组件化开发是程序员的刚需，所谓组件化就是功能模块要实现高内聚、低耦合的特性。<br>不过由于 DOM 和 CSSOM 都是全局的，所以它们是影响了前端组件化的主要元素。<br>基于这个原因，就出现 WebComponent，它包含自定义元素、影子 DOM 和 HTML 模板三种技术，使得开发者可以隔离 CSS 和 DOM。<br>在此基础上，还重点介绍了影子 DOM 到底是怎么实现的。<br>关于 WebComponent 的未来如何，这里我们不好预测和评判，但是有一点可以肯定，WebComponent 也会采用渐进式迭代的方式向前推进，未来依然有很多坑需要去填。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot;&gt;&lt;a href=&quot;#前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot; class=&quot;headerlink&quot; title=&quot;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot;&gt;&lt;/a&gt;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&lt;/h6&gt;&lt;h6 id=&quot;本篇是这个专栏的第五章：《No5-浏览器中的页面》。本章分为八节。&quot;&gt;&lt;a href=&quot;#本篇是这个专栏的第五章：《No5-浏览器中的页面》。本章分为八节。&quot; class=&quot;headerlink&quot; title=&quot;本篇是这个专栏的第五章：《No5.浏览器中的页面》。本章分为八节。&quot;&gt;&lt;/a&gt;本篇是这个专栏的第五章：《No5.浏览器中的页面》。本章分为八节。&lt;/h6&gt;
    
    </summary>
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>每周总结第二十一期</title>
    <link href="http://liugezhou.online/2019/11/30/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E6%9C%9F/"/>
    <id>http://liugezhou.online/2019/11/30/每周总结第二十一期/</id>
    <published>2019-11-30T14:08:00.000Z</published>
    <updated>2019-11-30T14:24:35.796Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这里记录过去一周，我的一些小总结。<br> <img src="http://img.liugezhou.online/20191130No21week.jpeg" alt="weekly-21"></p></blockquote><a id="more"></a><h4 id="Feeling"><a href="#Feeling" class="headerlink" title="Feeling"></a>Feeling</h4><blockquote><p>No Feeling。</p></blockquote><h4 id="携号转网"><a href="#携号转网" class="headerlink" title="携号转网"></a>携号转网</h4><blockquote><p>工信部11月27日(周三)召开携号转网启动仪式，27日起，携号转网正式在全国提供服务。用户号码保持不变，符合条件可自由选择移动、联通、电信等运营商。电信业务经营者不得干涉用户自主选择。</p><p>网上数据：<br>“携号转网”服务正式在全国范围内拓展。此前，天津、海南等五个前期试验省(市)已于9月19日正式提供服务。据工信部数据，截至11月26日，上述五个试验省份完成携号转网用户316万，从前期数据来看，携号转网的人员不到整体的2%。中国电信、中国移动、中国联通转出的用户数占全部转出用户的比例分别是16.3%、57.6%和26.1%，转入的占比是49.3%、28.1%和22.6%。（21世纪经济报道）    </p><p>这次携号转网终于可以让移动这种巨无霸企业有些许收敛。终于让一直存在的最低消费、营业点办理、流量瞎收费等等问题有了一些的缓和。<br>多年来我一直有个心愿，就是将我这半死不活还在用的移动号能有一个最低消费，多次客服无果。在这次浩浩荡荡的携号转网行动中，一个人工电话完成了我的心愿，甚感欣慰。</p></blockquote><h4 id="网易裁员的5点思考"><a href="#网易裁员的5点思考" class="headerlink" title="网易裁员的5点思考"></a><a href="https://mp.weixin.qq.com/s/_qFUhwAZwxJaiPD-EBtDVw" target="_blank" rel="noopener">网易裁员的5点思考</a></h4><blockquote><p>网易裁员、华为前员工被公司起诉敲诈(知乎已删除此相关话题回答)等事件让企业与员工关系推到了一个热度，其实大家心知肚明，这些事情在短期内虽然得到关注，但是这样的事件长期依然不会停止。<br>不管如何，对于职场人来说要做的、可控的首先是关注且做好自己的本职工作，其次当然要了解一些相关法律知识以保障自己权益。这篇文章作者针对此次事件总结了一些《劳动合同法》的基本知识。<br><a href="https://mp.weixin.qq.com/s/_qFUhwAZwxJaiPD-EBtDVw" target="_blank" rel="noopener">网易裁员事件引发的 5 点重要思考</a></p></blockquote><h4 id="欧洲IPv4地址用光"><a href="#欧洲IPv4地址用光" class="headerlink" title="欧洲IPv4地址用光"></a>欧洲IPv4地址用光</h4><blockquote><p>2019年11月25日(周一），欧洲 IP 地址注册机构 RIPE 宣布，欧洲的 IPv4 地址全部分配光了，一个也没剩下，从此没有新的 IP 地址可以分配。</p></blockquote><blockquote><ul><li>IP地址是分配给每个联网设备的一系列号码，每个IP地址都是独一无二的。IPv4地址用光大体意味着2^32-1个联网设备地址分配完了。  </li><li>当全球IPv4地址耗尽的这一刻，IPv6早就已经进入了我们的生活,在很多APP开屏的界面，会标注已经支持IPv6技术。  </li><li>IPv4地址长度是32，支持的物理地址是2^32-1个地址；IPv6地址的长度是128，支持的物理地址是2^128-1个地址。能够对地球上每平方米提供6×1023个网络地址，在可预见的将来是不会耗尽的。 </li><li>IPv4的回路地址为: 127.0.0.1，IPv6的回路地址为 : 000:0000:0000:0000:0000:0000:0000:0001 可以简写为 ::1。 </li><li>全球IPv4地址耗尽对普通用户影响不大，更多是网络技术、运营商，以及互联网应用开发者的事情.     </li></ul></blockquote><h4 id="OffScreen"><a href="#OffScreen" class="headerlink" title="OffScreen"></a>OffScreen</h4><blockquote><p>App store上的一款时间管理软件，它是系统“屏幕使用时间”的最佳伴侣，可以记录更多的信息，还可以提醒你，比如，OffScreen 会在你每次点亮屏幕的时候，用通知提醒，这是今天第几次拿起手机，以及平均查看时长，熬夜提醒，边走边看提醒，等等，帮助你戒除一些错误的生活习惯，如果你觉得有必要管理你的手机使用时长，这款软件可以很轻松的帮助你。</p></blockquote><h4 id="免费版权图片一键搜索"><a href="#免费版权图片一键搜索" class="headerlink" title="免费版权图片一键搜索!"></a><a href="https://www.logosc.cn/so/" target="_blank" rel="noopener">免费版权图片一键搜索!</a></h4><blockquote><p>一键搜索多家免版权图库，可以使用现有模板或者上传模板素材设计图片。    </p></blockquote><h4 id="再次安利vconsole"><a href="#再次安利vconsole" class="headerlink" title="再次安利vconsole"></a>再次安利vconsole</h4><blockquote><p>在开发手机网页应用，在手机真机调试过程中，如果想有类似小程序自带的调试工具，那么可以在你的网页中使用次插件：vconsole。<br>Github仓库搜索：vonsole，对照引入即可快速简单部署。</p></blockquote><h4 id="VSCode插件–import"><a href="#VSCode插件–import" class="headerlink" title="VSCode插件–import"></a>VSCode插件–import</h4><blockquote><p>作用：当你写了一个导入语句时，它会提醒你这个包的大小，如果你发现某个包太大时，就需要考虑一下你是否真的需要引入整个包。效果实例：<br><img src="http://img.liugezhou.online/20191130importcost.png" alt="import"></p></blockquote><h4 id="CSS-Grid网格布局教程"><a href="#CSS-Grid网格布局教程" class="headerlink" title="CSS Grid网格布局教程"></a><a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html" target="_blank" rel="noopener">CSS Grid网格布局教程</a></h4><blockquote><p>前端非常重要的两大布局分别是：Flex弹性布局和Grid网格布局。<br>Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是一维布局。<br>Grid 布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可以看作是二维布局。<br>Grid 布局远比 Flex 布局强大。<br><img src="https://www.wangbase.com/blogimg/asset/201903/1_bg2019032501.png" alt="Grid"></p></blockquote><h4 id="前端模块化"><a href="#前端模块化" class="headerlink" title="前端模块化"></a><a href="https://www.liugezhou.online/2019/11/27/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/" target="_blank" rel="noopener">前端模块化</a></h4><blockquote><p>最近项目在调试微信支付的前端SDK引入的时候，官网文档有一句：“JSSDk的引入，支持使用 AMD/CMD 标准模块加载方法加载”。<br>对CommonJS、AMD、CMD、ES6Module等概念与代码实例的理解甚是混淆，于是查阅资料、总结<a href="https://www.liugezhou.online/2019/11/27/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/" target="_blank" rel="noopener">此文</a>。</p></blockquote><h4 id="nginx简单的几个命令"><a href="#nginx简单的几个命令" class="headerlink" title="nginx简单的几个命令"></a>nginx简单的几个命令</h4><blockquote><ul><li>服务端安装nginx：<code>yum install nginx</code>，通过yum安装的程序默认在etc目录下。  </li><li>查看nginx安装路径：<code>which nginx</code>或者<code>whereis nginx</code>.    </li><li>nginx启动：<code>service start nginx</code>,nginx停止：<code>service stop nginx</code>.   </li><li>查看nginx的运行状况：<code>ps -ef | grep nginx</code>. </li><li>nginx的配置主要查看<code>conf</code>文件，包括一些包含配置、域名解析、文件路径、监听端口、转发端口等。    </li></ul></blockquote><h4 id="浏览器中的页面循环系统"><a href="#浏览器中的页面循环系统" class="headerlink" title="浏览器中的页面循环系统"></a><a href="https://www.liugezhou.online/2019/11/25/No4.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E9%A1%B5%E9%9D%A2%E5%BE%AA%E7%8E%AF%E7%B3%BB%E7%BB%9F/" target="_blank" rel="noopener">浏览器中的页面循环系统</a></h4><blockquote><p>前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。<br>本篇是这个专栏的第四章：<a href="https://www.liugezhou.online/2019/11/25/No4.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E9%A1%B5%E9%9D%A2%E5%BE%AA%E7%8E%AF%E7%B3%BB%E7%BB%9F/" target="_blank" rel="noopener">浏览器中的页面循环系统</a>。本章分为六讲。   </p></blockquote><blockquote><p><a href="https://liugezhou.gitbook.io/liugezhou/hong-guan-shi-jiao-xia-de-liu-lan-qi/no4.-liu-lan-qi-zhong-de-ye-mian-xun-huan-xi-tong" target="_blank" rel="noopener">Gitbook在线阅读</a></p></blockquote><blockquote><ul><li>本章通过分析线程处理任务的不同方式介绍了事件循环系统、消息队列以及IPC等知识引出微任务的作用。</li><li>介绍了setTimeout和XMLHttpRequest两个WebAPI的实现方式. </li><li>由浅入深讲解微任务：包括微任务的实现原理以及微任务的应用：Promise。   </li><li>最后讲解了比Promise更容易阅读的async/await的原理及用法。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这里记录过去一周，我的一些小总结。&lt;br&gt; &lt;img src=&quot;http://img.liugezhou.online/20191130No21week.jpeg&quot; alt=&quot;weekly-21&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="每周分享" scheme="http://liugezhou.online/categories/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="每周分享" scheme="http://liugezhou.online/tags/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>前端模块化</title>
    <link href="http://liugezhou.online/2019/11/27/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>http://liugezhou.online/2019/11/27/前端模块化/</id>
    <published>2019-11-27T12:00:00.000Z</published>
    <updated>2019-11-29T03:11:13.682Z</updated>
    
    <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><blockquote><p>最近在梳理前端的公众号支付流程，从前端流程微信JSSDK的引入开始查阅文档。<br>在引入JS文件一小段中，文档中备注：“支持使用 AMD/CMD 标准模块加载方法加载”。<br>于是，想到对CommonJS、AMD、CMD、ES6Module等概念与代码实例的理解甚是混淆，于是学习、总结此文。  </p></blockquote><a id="more"></a><h4 id="前端模块化"><a href="#前端模块化" class="headerlink" title="前端模块化"></a>前端模块化</h4><hr><blockquote><p>2009年，美国程序员Ryan Dahl创造了node.js项目，将javascript语言用于服务器端编程。这标志”Javascript模块化编程”正式诞生。<br>因为老实说，在浏览器环境下，没有模块也不是特别大的问题，毕竟网页程序的复杂性有限；但是在服务器端，一定要有模块，与操作系统和其他应用程序互动，否则根本没法编程。NodeJS是CommonJS规范的实现，webpack 也是以CommonJS的形式来书写。</p></blockquote><blockquote><p>为了提高代码的复用率，方便代码进行管理，我也不知先后(应该CommonJS最早吧)的出现了一系列的模块化的规范：CommonJS、AMD、CMD以及（ES6Module）。</p></blockquote><blockquote><p>通常来讲：一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。</p></blockquote><blockquote><p>这三个规范都是为javascript模块化加载而生的，都是在用到或者预计要用到某些模块时候加载该模块，使得大量的系统巨大的庞杂的代码得以很好的组织和管理。模块化使得我们在使用和管理代码的时候不那么混乱，而且也方便了多人的合作。</p></blockquote><h4 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h4><hr><blockquote><ul><li>CommonJS是一个更偏向于服务端的规范。Node.js就是CommonJS规范的主要实践者。 </li><li>CommonJS不适用浏览器是因为：此规范是同步加载模块，对于服务器端来说，所有的模块都是在本地磁盘，等待模块时间就是硬盘读取文件时间，很小，但对浏览器而言，设计到网速、代理更原因，同步加载会造成阻塞，浏览器处于“假死”状态，所以浏览器端出现了AMD规范。</li></ul></blockquote><blockquote><p>代码实现拓展：<a href="http://javascript.ruanyifeng.com/nodejs/module.html" target="_blank" rel="noopener">CommonJS规范</a></p></blockquote><h4 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h4><blockquote><ul><li>AMD是<code>Asynchronous Module Definition</code>的缩写，即“异步模块定义”，它采用异步方式加载模块(模块的加载不影响它后面语句的运行),且会提前加载。</li><li>AMD同CommonJS一样也是使用require加载模块，但不同的是，AMD要求两个参数：require([module],callback).  </li></ul></blockquote><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> // 定义一个模块--math.js</span><br><span class="line">    define(function() &#123;</span><br><span class="line">    var add = function(x, y) &#123;</span><br><span class="line">        return x + y;</span><br><span class="line">    &#125;</span><br><span class="line">    return  &#123;</span><br><span class="line">        add: add</span><br><span class="line">    &#125;</span><br><span class="line">//加载方法如下</span><br><span class="line">require([&apos;math&apos;], function(math) &#123;</span><br><span class="line">  alert(math.add(1, 1));</span><br><span class="line">&#125;)</span><br><span class="line">//如果math模块还依赖其他模块，写法如下：</span><br><span class="line">define([&apos;dependenceModule&apos;], function(dependenceModule) &#123;</span><br><span class="line">    // todo</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><ul><li>当require()函数加载math模块的时候，就会先加载dependenceModule模块。当有多个依赖时，就将所有的依赖都写在define()函数第一个参数数组中，所以说AMD是依赖前置的。这不同于CMD规范，它是依赖就近的。</li></ul></blockquote><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><hr><blockquote><p>CMD与AMD最大的不同就是：CMD推崇依赖就近，延迟执行。可以在代码的任意一行写入依赖：<br><code>define(factory)</code><br>当factory为函数时，表示是模块的构造方法。<br>执行该构造方法，可以得到模块向外提供的接口。<br>factory 方法在执行时，默认会传入三个参数：require、exports 和 module.</p></blockquote><blockquote><p>AMD与CMD代码对比：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// CMD</span><br><span class="line">   define(function(require, exports, module) &#123;</span><br><span class="line">   var a = require(&apos;./a&apos;);</span><br><span class="line">   a.doSomething();</span><br><span class="line">   var b = require(&apos;./b&apos;);</span><br><span class="line">   b.doSomething();</span><br><span class="line">   &#125;)</span><br><span class="line">   // AMDdefine([&apos;a&apos;, &apos;b&apos;], function(a, b) &#123;</span><br><span class="line">   a.doSomething();</span><br><span class="line">   b.doSomething();</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure><h4 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h4><hr><blockquote><p>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：export和import.<br>export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。<br>ES6还提供了export default命令，为模块指定默认输出，对应的import语句不需要使用大括号.</p></blockquote><h4 id="ES6模块与CommonJS模块差异"><a href="#ES6模块与CommonJS模块差异" class="headerlink" title="ES6模块与CommonJS模块差异"></a>ES6模块与CommonJS模块差异</h4><hr><blockquote><ul><li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。  </li><li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;最近在梳理前端的公众号支付流程，从前端流程微信JSSDK的引入开始查阅文档。&lt;br&gt;在引入JS文件一小段中，文档中备注：“支持使用 AMD/CMD 标准模块加载方法加载”。&lt;br&gt;于是，想到对CommonJS、AMD、CMD、ES6Module等概念与代码实例的理解甚是混淆，于是学习、总结此文。  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="web前端" scheme="http://liugezhou.online/categories/web%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="http://liugezhou.online/categories/web%E5%89%8D%E7%AB%AF/js/"/>
    
    
      <category term="jsonp" scheme="http://liugezhou.online/tags/jsonp/"/>
    
      <category term="js" scheme="http://liugezhou.online/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>No4.浏览器中的页面循环系统</title>
    <link href="http://liugezhou.online/2019/11/25/No4.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E9%A1%B5%E9%9D%A2%E5%BE%AA%E7%8E%AF%E7%B3%BB%E7%BB%9F/"/>
    <id>http://liugezhou.online/2019/11/25/No4.浏览器中的页面循环系统/</id>
    <published>2019-11-25T12:40:00.000Z</published>
    <updated>2019-11-30T03:11:31.014Z</updated>
    
    <content type="html"><![CDATA[<h6 id="前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。"><a href="#前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。" class="headerlink" title="前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。"></a>前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。</h6><h6 id="本篇是这个专栏的第四章：《浏览器中的页面循环系统》。本章分为六节。"><a href="#本篇是这个专栏的第四章：《浏览器中的页面循环系统》。本章分为六节。" class="headerlink" title="本篇是这个专栏的第四章：《浏览器中的页面循环系统》。本章分为六节。"></a>本篇是这个专栏的第四章：《浏览器中的页面循环系统》。本章分为六节。</h6><a id="more"></a><h4 id="15｜消息队列和事件循环：页面是怎么“活”起来的？"><a href="#15｜消息队列和事件循环：页面是怎么“活”起来的？" class="headerlink" title="15｜消息队列和事件循环：页面是怎么“活”起来的？"></a>15｜消息队列和事件循环：页面是怎么“活”起来的？</h4><hr><blockquote><p>本节主要专门介绍页面的事件循环系统，希望通过几段总结能对页面的事件循环系统有一个整体上的理解。    </p></blockquote><h5 id="使用单线程处理安排好的任务"><a href="#使用单线程处理安排好的任务" class="headerlink" title="使用单线程处理安排好的任务"></a>使用单线程处理安排好的任务</h5><blockquote><p>单线程处理的流程就是把所有任务代码按照顺序写进主线程里，等线程运行时，这些任务按照顺序在线程中执行，等所有任务执行完成，线程自动退出。        </p></blockquote><h5 id="在线程运行过程中处理任务"><a href="#在线程运行过程中处理任务" class="headerlink" title="在线程运行过程中处理任务"></a>在线程运行过程中处理任务</h5><blockquote><p>当然并非所有任务都可以使用单线程处理，有时我们需要在线程运行的过程中处理任务。<br>那么要想在线程运行过程中，能接受并执行新的任务，就需要采用事件循环机制。<br>相较与单线程处理任务，此线程做了两点改进：  </p><ul><li>引入了循环机制。(比如一个实现方式是添加for循环。线程一直循环执行)。 </li><li>引入了事件。</li></ul></blockquote><h5 id="处理其他线程发送过来的任务"><a href="#处理其他线程发送过来的任务" class="headerlink" title="处理其他线程发送过来的任务"></a>处理其他线程发送过来的任务</h5><blockquote><p>如何设计好一个线程模型，能让其能够接受其他线程发送的消息呢？<br>一个通用的模式是消息队列：「消息队列是一种数据结构、可以存放要执行的任务。它符合队列“先进先出”的特点。」<br>有了队列之后继续改进步骤如下：    </p><ul><li>添加一个消息队列。  </li><li>IO线程中产生的新任务添加进消息队列尾部。    </li><li>渲染主进程会循环地从消息队列头部中读取任务，执行任务。  </li></ul></blockquote><h5 id="处理其他进程发送过来的任务"><a href="#处理其他进程发送过来的任务" class="headerlink" title="处理其他进程发送过来的任务"></a>处理其他进程发送过来的任务</h5><blockquote><p>渲染进程专门有一个 IO 线程用来接收其他进程传进来的消息，接收到消息之后，会将这些消息组装成任务发送给渲染主线程，后续的步骤就和前面的“处理其他线程发送的任务”一样。    </p></blockquote><h5 id="消息队列中的任务类型"><a href="#消息队列中的任务类型" class="headerlink" title="消息队列中的任务类型"></a>消息队列中的任务类型</h5><blockquote><p>消息队列中的任务都有哪些呢？<br>输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器等等。除此之外，消息队列中还包含了很多与页面相关的事件，如 JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画等。    </p></blockquote><h5 id="页面使用单线程的缺点"><a href="#页面使用单线程的缺点" class="headerlink" title="页面使用单线程的缺点"></a>页面使用单线程的缺点</h5><blockquote><ul><li>第一个问题是如何处理高优先级的任务。<br>由于优先级的问题使得微任务应用而生，微任务是如何权衡效率和实时性的呢?<br>通常我们把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题.等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为 DOM 变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题   </li><li>第二个是如何解决单个任务执行时长过久的问题.<br>针对这种情况，JavaScript 可以通过回调功能来规避这种问题，也就是让要执行的 JavaScript 任务滞后执行。  </li></ul></blockquote><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><blockquote><p>如果有一些确定好的任务，可以使用一个单线程来按照顺序处理这些任务，这是第一版线程模型。<br>要在线程执行过程中接收并处理新的任务，就需要引入循环语句和事件系统，这是第二版线程模型。<br>如果要接收其他线程发送过来的任务，就需要引入消息队列，这是第三版线程模型。<br>如果其他进程想要发送任务给页面主线程，那么先通过 IPC 把任务发送给渲染进程的 IO 线程，IO 线程再把任务发送给页面主线程。<br>消息队列机制并不是太灵活，为了适应效率和实时性，引入了微任务。</p></blockquote><h4 id="16-｜-WebAPI-setTimeout是如何实现的"><a href="#16-｜-WebAPI-setTimeout是如何实现的" class="headerlink" title="16 ｜ WebAPI : setTimeout是如何实现的"></a>16 ｜ WebAPI : setTimeout是如何实现的</h4><hr><h5 id="浏览器怎么实现setTimeout"><a href="#浏览器怎么实现setTimeout" class="headerlink" title="浏览器怎么实现setTimeout"></a>浏览器怎么实现setTimeout</h5><blockquote><p>通过上一小节的学习，我们知道：对于一些事件执行的过程是：这些事件先被添加到消息队列，然后事件循环系统就会按照消息队列中的顺序来执行事件。也就是说，执行一段异步任务，需要先将任务添加到消息队列中。<br>不过通过定时器设置回调函数有点特别，它们需要在指定的时间间隔内被调用，但消息队列中的任务是按照顺序执行的，所以为了保证回调函数能在指定时间内执行，你不能将定时器的回调函数直接添加到消息队列中。<br>从Chromium队列的部分源码中我们知道，在Chrome中除了正常使用的消息队列外，还有另外一个消息队列，这个队列中维护了<code>需要延迟执行的任务列表</code>，包括了定时器和Chromium内部一些需要延迟执行的任务。<br>由于消息队列排队和一些系统级别的限制，通过setTimeout设置的回调任务并非总是可以实时的执行，这样就不能满足一些实时性要求较高的需求。    </p></blockquote><h5 id="使用setTimeout的一些注意事项"><a href="#使用setTimeout的一些注意事项" class="headerlink" title="使用setTimeout的一些注意事项"></a>使用setTimeout的一些注意事项</h5><blockquote><ul><li>如果当前任务执行时间过久，会影响延迟到期定时器任务的执行。  </li><li>如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒。 </li><li>未激活的页面，setTimeout 执行最小间隔是 1000 毫秒.  </li><li>延时执行时间有最大值:大约 24.8 天   </li><li>使用 setTimeout 设置的回调函数中的 this 不符合直觉. </li></ul></blockquote><h4 id="17-WebAPI：XMLHttpRequest是怎么实现的"><a href="#17-WebAPI：XMLHttpRequest是怎么实现的" class="headerlink" title="17 | WebAPI：XMLHttpRequest是怎么实现的?"></a>17 | WebAPI：XMLHttpRequest是怎么实现的?</h4><hr><blockquote><p>在深入讲解 XMLHttpRequest 之前，我们得先介绍下<code>同步回调</code>和<code>异步回调</code>这两个概念.   </p></blockquote><h5 id="回调函数-VS-系统调用栈"><a href="#回调函数-VS-系统调用栈" class="headerlink" title="回调函数 VS 系统调用栈"></a>回调函数 VS 系统调用栈</h5><blockquote><p><code>回调函数</code>：将一个函数作为参数传递给另外一个函数，那作为参数的这个函数就是回调函数。</p></blockquote><blockquote><p>同步回调函数代码：  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let callback = function()&#123;</span><br><span class="line">    console.log(&apos;i am do homework&apos;)</span><br><span class="line">&#125;</span><br><span class="line">function doWork(cb) &#123;</span><br><span class="line">    console.log(&apos;start do work&apos;)</span><br><span class="line">    cb()</span><br><span class="line">    console.log(&apos;end do work&apos;)</span><br><span class="line">&#125;</span><br><span class="line">doWork(callback)</span><br><span class="line">//start do work</span><br><span class="line">//i am do homework</span><br><span class="line">//end do work</span><br></pre></td></tr></table></figure><blockquote><p>异步回调函数代码：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let callback = function()&#123;</span><br><span class="line">    console.log(&apos;i am do homework&apos;)</span><br><span class="line">&#125;</span><br><span class="line">function doWork(cb) &#123;</span><br><span class="line">    console.log(&apos;start do work&apos;)</span><br><span class="line">    setTimeout(cb,1000)   </span><br><span class="line">    console.log(&apos;end do work&apos;)</span><br><span class="line">&#125;</span><br><span class="line">doWork(callback)</span><br></pre></td></tr></table></figure><h5 id="XMLHttpRequest运作机制"><a href="#XMLHttpRequest运作机制" class="headerlink" title="XMLHttpRequest运作机制"></a>XMLHttpRequest运作机制</h5><blockquote><p>对回调函数有了一个认知后，那么接着我们来分析下从发起请求到接收数据的完整流程：    </p></blockquote><blockquote><p>首先从XMLHttpRequest的用法开始：</p><ul><li>第一步：创建XMLHttpRequest对象。  </li><li>第二步：为xhr对象注册回调函数。</li><li>第三步：配置基础的请求信息。    </li><li>第四步：发起请求。  </li></ul></blockquote><h5 id="XMLRequest使用过程中的“坑”"><a href="#XMLRequest使用过程中的“坑”" class="headerlink" title="XMLRequest使用过程中的“坑”"></a>XMLRequest使用过程中的“坑”</h5><blockquote><ul><li>跨域问题    </li><li>HTTPS混合内容的问题：这是指HTTPS页面中包含了不符合HTTPS安全要求的内容，比如包含了HTTP资源。</li></ul></blockquote><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><blockquote><p>setTimeout 是直接将延迟任务添加到延迟队列中，而 XMLHttpRequest 发起请求，是由浏览器的其他进程或者线程去执行，然后再将执行结果利用 IPC 的方式通知渲染进程，之后渲染进程再将对应的消息添加到消息队列中。    </p></blockquote><h4 id="18-宏任务和微任务：不是所有的任务都是一个待遇"><a href="#18-宏任务和微任务：不是所有的任务都是一个待遇" class="headerlink" title="18 | 宏任务和微任务：不是所有的任务都是一个待遇"></a>18 | 宏任务和微任务：不是所有的任务都是一个待遇</h4><hr><blockquote><p>前面我们已经知道微任务可以在实时性和效率之间做一个有效的权衡。微任务已被广泛应用，比如Promise以及以Promise为基础开发出来的很多其他的技术。<br>宏任务与微任务的区别：    </p></blockquote><h5 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h5><blockquote><p>页面中的大部分任务都是在主线程上执行的。如渲染事件、用户交互事件、JavaScript脚本执行事件、网络请求等等。这些在消息队列中的任务称为宏任务。<br>虽然宏任务可以满足我们大部门的日常需求，但是有时对时间精度要求较高的需求，宏任务就难以胜任了。</p></blockquote><h5 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h5><blockquote><p>微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。<br>产生微任务的两种方式：    </p><ul><li>第一种方式是使用 MutationObserver 监控某个 DOM 节点，然后再通过 JavaScript 来修改这个节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。   </li><li>第二种方式是使用 Promise，当调用 Promise.resolve() 或者 Promise.reject() 的时候，也会产生微任务。<br>通过微任务的工作流程，我们可以得出如下结论：  </li><li>微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。    </li><li>微任务的执行时长会影响到当然宏任务的执行时长，因此写代码的时候一定要注意微任务的执行时长。  </li><li>在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务早于宏任务执行。</li></ul></blockquote><h5 id="监听DOM变化演变"><a href="#监听DOM变化演变" class="headerlink" title="监听DOM变化演变"></a>监听DOM变化演变</h5><blockquote><p>微任务应用在了<code>MutationObserver</code>中，<code>MutationObserver</code>是用来监听DOM变化的一套方法。 监听DOM变化一直是前端工程师一项非常核心的需求。<br>下面是监听DOM变化演变的简单总结:  </p><ul><li>早起观测DOM变化就是轮询检测。比如使用 setTimeout 或者 setInterval 来定时检测 DOM 是否有改变。无疑这种方式实时性不好，效率还低效。   </li><li>2000年的时候引入了Mutation Event，Mutation Event采用了观察者的设计模式，当DOM有变动时立即出发相应的事件。此方式属于同步回调。虽然这种方式解决了实时性问题，但是因为会产生较大性能开销、导致页面性能出现问题，被反对使用并逐步从web标准事件中删除。  </li><li>MutationObserver替代MutationEvent，相较于Event方式，Observer采用了一次触发异步回调。且采用微任务的处理，使得实时性与性能功能都得到有效提高。</li></ul></blockquote><h4 id="19-｜-Promise：使用Promise，告别回调函数"><a href="#19-｜-Promise：使用Promise，告别回调函数" class="headerlink" title="19 ｜ Promise：使用Promise，告别回调函数"></a>19 ｜ Promise：使用Promise，告别回调函数</h4><blockquote><p>微任务的另一个应用：Promise。<br>本节简单介绍JavaScript引入Promise的动机，以及解决问题的几个核心关键点。<br>讲到动机，也就是说Promise解决了什么问题。众所周知，他解决的是异步编码风格的问题。 </p></blockquote><blockquote><p>页面编程的一大特点就是：异步编程，下面分析异步编程的代码风格进化。    </p><ul><li>之前的代码编码风格，一段代码可能会出现五次回调，这种回调导致代码逻辑不连贯、不连线，不符合人的直觉。  </li><li>然后开发人员们通过封装异步代码，让处理流程变得线性，但是这种处理方式如果嵌套了太多的回调函数就容易陷入回调地狱。</li><li>陷入回调地狱的后代码看上去很乱主要是两点：嵌套调用和任务不确定性(成功或者失败)。于是Promise出现，解决了这两个问题。</li></ul></blockquote><h5 id="Promise：消灭嵌套调用和多次错误处理"><a href="#Promise：消灭嵌套调用和多次错误处理" class="headerlink" title="Promise：消灭嵌套调用和多次错误处理"></a>Promise：消灭嵌套调用和多次错误处理</h5><blockquote><p>Promise通过两步解决嵌套回调问题：</p><ul><li>首先，Promise实现了回调函数的延时绑定（.then）  </li><li>其次，将回调函数返回值穿透到最外层。</li></ul></blockquote><blockquote><p>Promise处理异常：<br>通过最后一个catch，将所有对象合并到一个函数来处理之前的所有异常。</p></blockquote><h5 id="Promise与微任务"><a href="#Promise与微任务" class="headerlink" title="Promise与微任务"></a>Promise与微任务</h5><blockquote><p> Promise 之所以要使用微任务是由 Promise 回调函数延迟绑定技术导致的。</p></blockquote><h4 id="20-｜-async-await：使用同步的方式去写异步代码"><a href="#20-｜-async-await：使用同步的方式去写异步代码" class="headerlink" title="20 ｜ async/await：使用同步的方式去写异步代码"></a>20 ｜ async/await：使用同步的方式去写异步代码</h4><blockquote><p>当Promise解决回调地狱代码风格的同时，我们发现写很多的then函数，还是有些不太容易阅读。<br>基于这个原因，ES7引入了async/await，这是JavaScript异步编程的一个重大改进，提供了在不阻塞主线程的情况下使用同步代码实现异步访问资源的能力。并且使得代码逻辑更加清晰。</p></blockquote><blockquote><p>本节首先介绍生成器(Generator)是如何工作的，接着介绍了Generator的底层实现机制–协程。<br>这是因为async/await使用了Generator和Promise两种技术。所以紧接着通过Generator和Promise来分析async/await到底是如何通过以同步方式来编写异步代码的。  </p></blockquote><h5 id="生成器-VS-协程"><a href="#生成器-VS-协程" class="headerlink" title="生成器 VS 协程"></a>生成器 VS 协程</h5><blockquote><p>生成器函数：生成器函数是一个带星号函数，而且是可以暂停执行和恢复执行的。<br>具体使用方式就是：在生成器函数内部执行一段代码，若遇到yiled关键字，那JS引擎将返回该关键字后面的内容且暂停该函数执行，外部函数通过next方法恢复函数的执行。<br>那么JavaScript引擎V8是如何实现一个函数的暂停和恢复的？    </p></blockquote><blockquote><p>搞懂它的暂停和恢复，需要首先了解协程的概念。协程是一种比线程更加轻量级的存在。可以把协程看作是跑在线程上的任务，一个线程可以存在多个协程。但在线程上同时只能执行一个协程。<br>在JS中，生成器就是协程的一种实现方式。</p></blockquote><h5 id="asnyc-await"><a href="#asnyc-await" class="headerlink" title="asnyc/await"></a>asnyc/await</h5><blockquote><p>为了更近一步改进生成器代码，ES7引入了async/awit，实现了更加直观简洁的代码。<br>async/aswit技术背后的实现就是Promise和生成器应用。往底层说就是微服务和协程应用。</p></blockquote><blockquote><p>async: 是一个通过异步执行并隐式返回Promise作为结果的函数。<br>await: 我们知道了 async 函数返回的是一个 Promise 对象，那下面我们再结合文中这段代码来看看 await 到底是什么。   </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async function foo() &#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">    let a = await 100</span><br><span class="line">    console.log(a)</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;</span><br><span class="line">console.log(0)</span><br><span class="line">foo()</span><br><span class="line">console.log(3)</span><br><span class="line">//输出结果：0 3 100 2</span><br></pre></td></tr></table></figure><blockquote><p>async/await 无疑是异步编程领域非常大的一个革新，也是未来的一个主流的编程风格。其实，除了 JavaScript，Python、Dart、C# 等语言也都引入了 async/await，使用它不仅能让代码更加整洁美观，而且还能确保该函数始终都能返回 Promise。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot;&gt;&lt;a href=&quot;#前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot; class=&quot;headerlink&quot; title=&quot;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot;&gt;&lt;/a&gt;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&lt;/h6&gt;&lt;h6 id=&quot;本篇是这个专栏的第四章：《浏览器中的页面循环系统》。本章分为六节。&quot;&gt;&lt;a href=&quot;#本篇是这个专栏的第四章：《浏览器中的页面循环系统》。本章分为六节。&quot; class=&quot;headerlink&quot; title=&quot;本篇是这个专栏的第四章：《浏览器中的页面循环系统》。本章分为六节。&quot;&gt;&lt;/a&gt;本篇是这个专栏的第四章：《浏览器中的页面循环系统》。本章分为六节。&lt;/h6&gt;
    
    </summary>
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>每周总结第二十期</title>
    <link href="http://liugezhou.online/2019/11/24/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93%E7%AC%AC%E4%BA%8C%E5%8D%81%E6%9C%9F/"/>
    <id>http://liugezhou.online/2019/11/24/每周总结第二十期/</id>
    <published>2019-11-24T08:50:00.000Z</published>
    <updated>2019-11-25T02:15:31.390Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这里记录过去一周，我的一些小总结。</p></blockquote><a id="more"></a><h4 id="Feeling"><a href="#Feeling" class="headerlink" title="Feeling"></a>Feeling</h4><blockquote><p>本周并没有总结什么。<br>只是最近几周有个感觉，更是事实，那些写技术文章的公号里充满了软文宣传、推广。<br>技术公号的文章凡是过千的便是一个有些影响力的传播媒介了。连阮一峰这种大牛级别的公众号文章的阅读量也不过万。<br>对于商业卖课者来说，公众号的每一个阅读量都代表了那些实打实的目标群体客户都接受到了广告的洗礼，<br>群体性的技术公号集体沦陷开始卖课，这应该就是那种说程序员技术变现的广泛实例。<br>我只是很好奇这种一篇推广文，会给开发者多少广告费用。 </p></blockquote><h4 id="琅琊榜图谱"><a href="#琅琊榜图谱" class="headerlink" title="琅琊榜图谱"></a>琅琊榜图谱</h4><blockquote><p>周末倍速在家刷了一遍琅琊榜，理不清谁的谁是谁的谁：</p><p>梅长苏的爸爸是林燮(xie)。<br>林燮的妹妹是宸妃.<br>宸妃的儿子是祁王–&gt; 祁王的儿子是庭生。<br>宸妃的老公是粱王。</p><p>梅长苏的妈妈是晋阳长公主。<br>晋阳长公主的哥哥是粱王。</p><p>晋阳长公主的妹妹是莅阳长公主.<br>莅阳长公主的丈夫是谢玉。</p><p>莅阳长公主的情人是南楚晟王宇文霖。<br>宇文霖的亲生儿子是萧景睿。</p><p>粱王还有个老婆是静妃，静妃的儿子是靖王。<br>粱王还有个老婆是越贵妃，越贵妃的儿子是太子。<br>粱王还有个老婆是言皇后，言皇后的养子是誉王。 </p><p>梅长苏赤焰军旧部里面有个叫聂峰。<br>聂峰的老婆是夏冬。<br>夏冬的师哥是夏秋。<br>夏冬的师傅是夏江。</p><p>……</p></blockquote><h4 id="网传网易让保安将绝症员工赶出公司"><a href="#网传网易让保安将绝症员工赶出公司" class="headerlink" title="网传网易让保安将绝症员工赶出公司"></a>网传网易让保安将绝症员工赶出公司</h4><blockquote><p>我们大家都知道不应该因为一个员工事件来骂网易云音乐或者任何的网易应用。<br>只是大家需要一个有个官方账号的回应。<br>大家维护的不仅仅是这一起人血馒头事件。<br>更加维护的是自己的生存社会环境。<br>【每个人对于他所处的社会都负有责任，这个社会的弊病需要每一个人去维护】。</p></blockquote><h4 id="曾文正公全集"><a href="#曾文正公全集" class="headerlink" title="曾文正公全集"></a>曾文正公全集</h4><blockquote><p>盖士人读书，第一要有志，第二要有识，第三要有恒。有志则不甘为下流；有识则知学问无尽，不敢以一得自足，如河伯之观海，如井蛙之窥天，皆无识者也；有恒则断无不成之事。此三者缺一不可。诸弟此时惟有识不可以骤几；至于有志，有恒，则诸弟勉之而已。<br>中心思想：要学会读书。<br><cite>引自《曾文正公全集》</cite></p></blockquote><h4 id="CSS定位详解"><a href="#CSS定位详解" class="headerlink" title="CSS定位详解"></a><a href="http://www.ruanyifeng.com/blog/2019/11/css-position.html" target="_blank" rel="noopener">CSS定位详解</a></h4><blockquote><p>CSS 有两个最重要的基本属性，前端开发必须掌握：display 和 position。<br>display属性指定网页的布局。两个重要的布局，弹性布局<code>flex</code>和网格布局<code>grid</code>。<br>本文介绍非常有用的position属性。作者希望通过10分钟的阅读，帮助大家轻松掌握网页定位，说清楚浏览器如何计算网页元素的位置，尤其是新引进的<code>sticky</code>定位.   </p></blockquote><h4 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h4><blockquote><p>iOS APP FOR BETA 版本已经预约两个星期了，还是没有下文，真是让人焦灼。 </p></blockquote><h4 id="No3-V8工作原理"><a href="#No3-V8工作原理" class="headerlink" title="No3.V8工作原理"></a><a href="https://www.liugezhou.online/2019/11/21/No3.V8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">No3.V8工作原理</a></h4><blockquote><p>前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。<br>本篇是这个专栏的第三章：<a href="https://www.liugezhou.online/2019/11/21/No3.V8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">No3.V8工作原理</a>。本章分为三讲。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这里记录过去一周，我的一些小总结。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="每周分享" scheme="http://liugezhou.online/categories/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="每周分享" scheme="http://liugezhou.online/tags/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>No3.V8工作原理</title>
    <link href="http://liugezhou.online/2019/11/21/No3.V8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://liugezhou.online/2019/11/21/No3.V8工作原理/</id>
    <published>2019-11-21T13:40:00.000Z</published>
    <updated>2019-11-21T01:56:53.220Z</updated>
    
    <content type="html"><![CDATA[<h6 id="前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。"><a href="#前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。" class="headerlink" title="前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。"></a>前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。</h6><h6 id="本篇是这个专栏的第三章：《V8工作原理》。本章分为三节。"><a href="#本篇是这个专栏的第三章：《V8工作原理》。本章分为三节。" class="headerlink" title="本篇是这个专栏的第三章：《V8工作原理》。本章分为三节。"></a>本篇是这个专栏的第三章：《V8工作原理》。本章分为三节。</h6><a id="more"></a><h4 id="12｜栈空间和堆空间：数据是如何存储的？"><a href="#12｜栈空间和堆空间：数据是如何存储的？" class="headerlink" title="12｜栈空间和堆空间：数据是如何存储的？"></a>12｜栈空间和堆空间：数据是如何存储的？</h4><hr><h5 id="JavaScript是什么类型的语言"><a href="#JavaScript是什么类型的语言" class="headerlink" title="JavaScript是什么类型的语言"></a>JavaScript是什么类型的语言</h5><blockquote><p>在使用之前就需要确认其变量数据类型的语言称为<code>静态语言</code>，相反地，我们把运行过程中需要检查数据类型的语言称为<code>动态语言</code>。<br>我们把变量直接可以偷偷进行转换的操作称为隐式类型转换，支持隐式类型的语言称为<code>弱类型语言</code>，不支持隐式类型转换的语言称为<code>强类型语言</code>。      </p></blockquote><blockquote><p>显然，JavaScript是动态弱类型语言。    </p></blockquote><h5 id="JavaScript的数据类型"><a href="#JavaScript的数据类型" class="headerlink" title="JavaScript的数据类型"></a>JavaScript的数据类型</h5><blockquote><p>JavaScript的数据类型一共有八种：<br>基本数据类型：Boolean、Undefined、Null、String、Number、Bigint、Symbol<br>引用数据类型：Object  </p></blockquote><h5 id="内存空间"><a href="#内存空间" class="headerlink" title="内存空间"></a>内存空间</h5><blockquote><p>在JavaScript的执行过程中，主要有三种类型内存空间：代码空间、栈空间、堆空间。<br>原始类型的数据值都是直接保存在栈中的，引用类型的值都是保存在堆空间中的。<br>通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。堆空间很大，能存放很多大的数据。<br>原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。    </p></blockquote><h5 id="产生闭包的核心"><a href="#产生闭包的核心" class="headerlink" title="产生闭包的核心"></a>产生闭包的核心</h5><blockquote><p>第一步是需要预扫描内部函数。<br>第二步是把内部函数引用的外部变量保存到堆中。  </p></blockquote><h4 id="13-｜-垃圾回收：垃圾数据是如何自动回收的？"><a href="#13-｜-垃圾回收：垃圾数据是如何自动回收的？" class="headerlink" title="13 ｜ 垃圾回收：垃圾数据是如何自动回收的？"></a>13 ｜ 垃圾回收：垃圾数据是如何自动回收的？</h4><hr><blockquote><p>对一些不需要的数据，我们称之为垃圾数据，由于内存是有限的，为了释放内存，我们需要对这么垃圾数据进行回收。  </p></blockquote><h5 id="不同语言的垃圾回收策略"><a href="#不同语言的垃圾回收策略" class="headerlink" title="不同语言的垃圾回收策略"></a>不同语言的垃圾回收策略</h5><blockquote><p>通常情况，垃圾回收分为手动回收到自动回收两种策略。<br>如C/C++C++使用的是手动回收策略，何时分配内存、何时销毁内存都是由代码控制的。<br>如JavaScript、Java、Python等语言使用的是自动回收策略，产生的垃圾数据是由垃圾回收器来释放的。  </p></blockquote><h5 id="调用栈中的数据是如何回收的"><a href="#调用栈中的数据是如何回收的" class="headerlink" title="调用栈中的数据是如何回收的"></a>调用栈中的数据是如何回收的</h5><blockquote><p>栈中的垃圾回收相对比较简单：JavaScript引擎会通过向下移动ESP来销毁该函数保存在栈中的执行上下文。<br>ESP：记录当前执行状态的指针。</p></blockquote><h5 id="堆中的数据是如何回收的"><a href="#堆中的数据是如何回收的" class="headerlink" title="堆中的数据是如何回收的"></a>堆中的数据是如何回收的</h5><blockquote><p>要回收堆中的数据，需要用到JavaScript中的垃圾回收器。</p></blockquote><blockquote><p>在介绍V8如何实现回收之前，首先要了解下<code>代际假说</code>内容。这是垃圾回收领域一个重要的术语，代际假说有两个特点：    </p><ul><li>第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问.  </li><li>第二个是不死的对象，会活得更久.<br>这两个特点不仅仅适用于JavaScript，同样适应于大多数动态语言，如Java、Python等。    </li></ul></blockquote><blockquote><p>在V8中会把堆分为新生代(支持1-8M容量)和老生代(容量大很多)两个区域，新生代中存放的是生存时间短的对象，老生代中存放的是生存时间久的对象。  </p><ul><li>副垃圾回收器，主要负责新生代的垃圾回收。    </li><li>主垃圾回收器，主要负责老生代的垃圾回收。   </li></ul></blockquote><h5 id="垃圾回收器的工作流程"><a href="#垃圾回收器的工作流程" class="headerlink" title="垃圾回收器的工作流程"></a>垃圾回收器的工作流程</h5><blockquote><p>不论是主垃圾回收器还是副垃圾回收器，它们都有一套共同的执行流程。  </p><ul><li>第一步为标记活动对象与非活动对象。活动对象为还在使用的对象，非活动对象为要准备进行垃圾回收的对象。  </li><li>第二步是回收非活动对象所占用的内存。既在标记后统一清理被标记为可回收的对象的内存。    </li><li>第三步是内存整理。这是因为在频繁回收对象后，内存中会存在不连续空间，把这些不连续空间称为内存碎片。因此需要整理这些碎片，这是为了当那些较大连续内存出现时可以方便分配。【这步是可选的，副垃圾回收器不会产生内存碎片】。<br>然后按照上述流程来分析新生代垃圾回收器（副垃圾回收器）和老生代垃圾回收器（主垃圾回收器）是如何处理垃圾回收的。    </li></ul></blockquote><h5 id="副垃圾回收器"><a href="#副垃圾回收器" class="headerlink" title="副垃圾回收器"></a>副垃圾回收器</h5><blockquote><p>副垃圾回收器主要负责新生代区的垃圾回收，虽然老生代区域不大，但是垃圾回收比较频繁。<br>新生代中用Scavenge算法来处理。【Scavenge算法：把新生代空间对半划分为两个区域，一个是对象区域，一个是空闲区域。】<br>过程大概就是：新加入对象放入都对象区域，快写满时进行垃圾清理操作，副垃圾回收器把这些对象复制到空闲区域，复制后的空闲区域没有内存碎片。完成复制后，对象区域与空闲区域角色翻转。角色翻转的操作能让新生代中的两块区域无限重复使用下去。<br>因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。</p></blockquote><h5 id="主垃圾回收器"><a href="#主垃圾回收器" class="headerlink" title="主垃圾回收器"></a>主垃圾回收器</h5><blockquote><p>主垃圾回收器主要负责老生区中的垃圾回收.<br>老生区中对象的两个特点：一是存活时间长，二是对象占用空间大。<br>由特点我们知道采用副垃圾回收器的Scavenge算法显然不满足需求，因此，主垃圾回收器采用的是<code>标记-清除（Mark-Sweep）</code>算法进行垃圾回收。碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——<code>标记 - 整理（Mark-Compact）</code> .</p></blockquote><h4 id="14-编译器和解释器：V8是如何执行一段JavaScript代码的"><a href="#14-编译器和解释器：V8是如何执行一段JavaScript代码的" class="headerlink" title="14 | 编译器和解释器：V8是如何执行一段JavaScript代码的"></a>14 | 编译器和解释器：V8是如何执行一段JavaScript代码的</h4><hr><blockquote><p>深入了解V8的工作原理，我们需要弄清除一些概念和原理，比如本节要学习的：<code>编译器(Compiler)</code>、<code>解释器(Interpreter)</code>、<code>抽象语法树(AST)</code>、<code>字节码(Bytecode)</code>、<code>即时编译器(JIT)</code>等概念。 </p></blockquote><h5 id="编译器和解释器"><a href="#编译器和解释器" class="headerlink" title="编译器和解释器"></a>编译器和解释器</h5><blockquote><p>编译器和解释器“翻译”代码的流程大致可阐述如下：    </p><ol><li>在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功。    </li><li>在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。    </li></ol></blockquote><h5 id="V8是如何执行一段JavaScript代码的"><a href="#V8是如何执行一段JavaScript代码的" class="headerlink" title="V8是如何执行一段JavaScript代码的"></a>V8是如何执行一段JavaScript代码的</h5><blockquote><p>V8在执行过程中既有解释器，又有编译器。分解其执行流程如下：    </p></blockquote><h6 id="1-生成抽象语法树-AST-和执行上下文"><a href="#1-生成抽象语法树-AST-和执行上下文" class="headerlink" title="1.生成抽象语法树(AST)和执行上下文"></a>1.生成抽象语法树(AST)和执行上下文</h6><blockquote><p>那么这个抽象语法树AST是什么呢？<br>首先我们知道高级语言只是开发者可以理解的语言，但是让编译器或者解释器来理解就非常困难了。对于编译器或者解释器来说，他可以理解的是AST，所以无论是解释性语言还是编译型语言，在编译过程中，都会生成一个AST。<br>一段代码经过javascript-ast站点处理后，AST的结构和代码结构非常之相似，具体结构就不展示了，类似于DOM树。AST的生成需要经过两个阶段： </p><ul><li>第一阶段是<code>分词</code>，又称为<code>词法分析</code>。其作用是将一行行的源码拆解成一个个 token。所谓 token，指的是语法上不可能再分的、最小的单个字符或字符串。  </li><li>第二阶段是<code>解析</code>,又称为<code>语法分析</code>。其作用是将上一步生成的 token 数据，根据语法规则转为 AST。    </li></ul></blockquote><h6 id="2-生成字节码"><a href="#2-生成字节码" class="headerlink" title="2.生成字节码"></a>2.生成字节码</h6><blockquote><p>有了 AST 和执行上下文后，那接下来的第二步，解释器 Ignition 就登场了，它会根据 AST 生成字节码，并解释执行字节码。<br>字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行.之所以出现字节码，是Chrome团队为了解决内存占用问题而引入的。    </p></blockquote><h6 id="3-执行代码"><a href="#3-执行代码" class="headerlink" title="3.执行代码"></a>3.执行代码</h6><blockquote><p>生成字节码之后，接下来就进入了执行阶段。<br>在执行阶段，通常解释器逐条执行字节码，如果发现有热点代码(一段代码被重复执行多次)，那后台编译器会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了。这种字节码配合解释器和编译器的技术就称为<code>即时编译(JIT)</code>.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot;&gt;&lt;a href=&quot;#前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot; class=&quot;headerlink&quot; title=&quot;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot;&gt;&lt;/a&gt;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&lt;/h6&gt;&lt;h6 id=&quot;本篇是这个专栏的第三章：《V8工作原理》。本章分为三节。&quot;&gt;&lt;a href=&quot;#本篇是这个专栏的第三章：《V8工作原理》。本章分为三节。&quot; class=&quot;headerlink&quot; title=&quot;本篇是这个专栏的第三章：《V8工作原理》。本章分为三节。&quot;&gt;&lt;/a&gt;本篇是这个专栏的第三章：《V8工作原理》。本章分为三节。&lt;/h6&gt;
    
    </summary>
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>每周总结第十九期</title>
    <link href="http://liugezhou.online/2019/11/17/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93%E7%AC%AC%E5%8D%81%E4%B9%9D%E6%9C%9F/"/>
    <id>http://liugezhou.online/2019/11/17/每周总结第十九期/</id>
    <published>2019-11-17T09:45:00.000Z</published>
    <updated>2019-11-17T09:49:24.318Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这里记录过去一周，我的一些小总结。</p></blockquote><a id="more"></a>。<p><img src="http://img.liugezhou.online/weekly19" alt="weekly-19"></p><h4 id="Feeling"><a href="#Feeling" class="headerlink" title="Feeling"></a>Feeling</h4><blockquote><p>由于自己的职业关系，比较关注一些技术、软件、工具、科技等方面的讯息。<br>这些讯息的爆炸、扩散，让我一次又一次在潜意识里提醒自己：淡定下来，无论窗外之事多么热闹，都不要影响自己的心态，按着自己的节奏去学习、吸收、渗透。</p></blockquote><h4 id="Idea永久激活"><a href="#Idea永久激活" class="headerlink" title="Idea永久激活"></a><a href="https://mp.weixin.qq.com/s/1VBxhZNC4kq2KckT6Jqwfw" target="_blank" rel="noopener">Idea永久激活</a></h4><blockquote><p>Idea工具30天体验结束，找了一些网上的激活方法，大多方法都失效了，最终在这篇文章的指引下，成功激活，推荐推荐。<br>激活传送门：<a href="https://mp.weixin.qq.com/s/1VBxhZNC4kq2KckT6Jqwfw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/1VBxhZNC4kq2KckT6Jqwfw</a></p></blockquote><h4 id="GitLens"><a href="#GitLens" class="headerlink" title="GitLens"></a>GitLens</h4><blockquote><p>它是 VSCode 中非常令人推荐的一个插件，简直是Git神器，码农必备。 每一行代码旁边都有日志，代码是谁提交的一目了然。   </p></blockquote><h4 id="Gitbook"><a href="#Gitbook" class="headerlink" title="Gitbook"></a>Gitbook</h4><blockquote><p>Gitbook编写在线文档，可以非常方便快速的将自己的md、html、zip、docx等文件倒入，实现快速部署。<br>不需域名、不需其他的任何配置，即可快速实现在线浏览。<br>但是需要<code>过墙</code>。<br>我花了十分钟导入两篇文章后的效果：<a href="https://mingzhou.gitbook.io/liugezhou/" target="_blank" rel="noopener">https://mingzhou.gitbook.io/liugezhou/</a></p></blockquote><h4 id="诺基亚老照片"><a href="#诺基亚老照片" class="headerlink" title="诺基亚老照片"></a>诺基亚老照片</h4><blockquote><p>这个工具可以生成老式诺基亚手机的短信图片。<br>网页版：<a href="https://zzkia.noddl.me:8020" target="_blank" rel="noopener">https://zzkia.noddl.me:8020</a><br>微信小程序：【次元蜜蜂】。  </p></blockquote><h4 id="Github-for-mobile-iOS-beta"><a href="#Github-for-mobile-iOS-beta" class="headerlink" title="Github for mobile iOS beta"></a><a href="https://github.com/mobile" target="_blank" rel="noopener">Github for mobile iOS beta</a></h4><blockquote><p>11 月 13 日，GitHub 年度开发者大会—GitHub Universe 2019 在美国旧金山举行。<br>为改善用户体验，GitHub 在本次大会上宣布推出移动端，即 GitHub App 。<br>目前，官方已经上线 iOS 版，不过，却是 beta（公测版），因此用户暂时无法通过 App Store 下载，可以通过官方渠道下载尝鲜。<br>但是，我等</p></blockquote><h4 id="Bytespider"><a href="#Bytespider" class="headerlink" title="Bytespider"></a>Bytespider</h4><blockquote><p>[很多社区用户纷纷反馈，一种名为 Bytespider 的爬虫爬取他们的网站信息的频率太高，直接把网站搞瘫痪了。大家顺着爬虫的 IP 地址查了一下，发现 Bytespider 应该就是今日头条的搜索爬虫。]<sup><a href="https://mp.weixin.qq.com/s/KXg8xAf_TOAROMhqJVQQBQ" target="_blank" rel="noopener">来源</a></sup>  </p></blockquote><blockquote><p>robots.txt 协议:<br>也称为爬虫协议、爬虫规则、机器人协议等。robots.txt文件是存储在网站根目录下的 txt 文本文档。这是网站和蜘蛛之间的协议。该网站告诉搜索引擎哪些页面可以被抓取，哪些页面不想通过机器人协议被抓取。</p></blockquote><h4 id="浏览器中的JavaScript执行机制"><a href="#浏览器中的JavaScript执行机制" class="headerlink" title="浏览器中的JavaScript执行机制"></a><a href="https://www.liugezhou.online/2019/11/11/No2.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JavaScript%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">浏览器中的JavaScript执行机制</a></h4><blockquote><p>前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。<br>本篇是这个专栏的第二章：<a href="https://www.liugezhou.online/2019/11/11/No2.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JavaScript%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">浏览器中的JavaScript执行机制</a>。本章分为五讲。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这里记录过去一周，我的一些小总结。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="每周分享" scheme="http://liugezhou.online/categories/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="每周分享" scheme="http://liugezhou.online/tags/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>No2.浏览器中的JavaScript执行机制</title>
    <link href="http://liugezhou.online/2019/11/11/No2.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JavaScript%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <id>http://liugezhou.online/2019/11/11/No2.浏览器中的JavaScript执行机制/</id>
    <published>2019-11-11T13:40:00.000Z</published>
    <updated>2019-11-15T03:24:38.142Z</updated>
    
    <content type="html"><![CDATA[<h6 id="前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。"><a href="#前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。" class="headerlink" title="前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。"></a>前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。</h6><h6 id="本篇是这个专栏的第二章：《浏览器中的JavaScript执行机制》。本章分为五节。"><a href="#本篇是这个专栏的第二章：《浏览器中的JavaScript执行机制》。本章分为五节。" class="headerlink" title="本篇是这个专栏的第二章：《浏览器中的JavaScript执行机制》。本章分为五节。"></a>本篇是这个专栏的第二章：《浏览器中的JavaScript执行机制》。本章分为五节。</h6><a id="more"></a><h4 id="07｜变量提升：JavaScript代码是按顺序执行的吗？"><a href="#07｜变量提升：JavaScript代码是按顺序执行的吗？" class="headerlink" title="07｜变量提升：JavaScript代码是按顺序执行的吗？"></a>07｜变量提升：JavaScript代码是按顺序执行的吗？</h4><hr><blockquote><p>本节主要讲解<code>执行上下文</code>相关的内容。</p></blockquote><blockquote><p>通过一些代码的执行顺序与经验我们知道：    </p><ul><li>在执行过程中，若使用了未声明的变量，那么 JavaScript 执行会报错。    </li><li>在一个变量定义之前使用它，不会出错，但是该变量的值会为 undefined，而不是定义时的值。    </li><li>在一个函数定义之前使用它，不会出错，且函数能正确执行。</li></ul></blockquote><h5 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h5><blockquote><p>所谓的变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined.<br>之所以会发生变量提升，是因为一段JavaScript代码在执行之前，需要被JavaScript引擎编译，编译完成之后，才会进入执行阶段。也就是说在编译阶段，变量和函数的声明提升到了开头。    </p></blockquote><h4 id="08-｜调用栈：为什么JavaScript代码会出现栈溢出？"><a href="#08-｜调用栈：为什么JavaScript代码会出现栈溢出？" class="headerlink" title="08 ｜调用栈：为什么JavaScript代码会出现栈溢出？"></a>08 ｜调用栈：为什么JavaScript代码会出现栈溢出？</h4><hr><blockquote><p>一般有三种情况，当一段代码执行的时候JS引擎对其进行编译并创建执行上下文：</p><ol><li>当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份.  </li><li>当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。   </li><li>当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。</li></ol></blockquote><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><blockquote><ul><li>每调用一个函数，JavaScript 引擎会为其创建执行上下文，并把该执行上下文压入调用栈，然后 JavaScript 引擎开始执行函数代码。 </li><li>如果在一个函数 A 中调用了另外一个函数 B，那么 JavaScript 引擎会为 B 函数创建执行上下文，并将 B 函数的执行上下文压入栈顶。   </li><li>当前函数执行完毕后，JavaScript 引擎会将该函数的执行上下文弹出栈。   </li><li>当分配的调用栈空间被占满时，会引发“堆栈溢出”问题。</li></ul></blockquote><h4 id="09-块级作用域：var缺陷以及为什么要引入let和const"><a href="#09-块级作用域：var缺陷以及为什么要引入let和const" class="headerlink" title="09 | 块级作用域：var缺陷以及为什么要引入let和const"></a>09 | 块级作用域：var缺陷以及为什么要引入let和const</h4><hr><h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><blockquote><p>作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。<br>ES6出现之前，JS的作用域只有两种：<code>全局作用域</code>和<code>函数作用域</code>。 ES6出现，引入了<code>块级作用域</code>。</p></blockquote><h5 id="在同一段代码中，ES6-是如何做到既要支持变量提升的特性，又要支持块级作用域的呢？"><a href="#在同一段代码中，ES6-是如何做到既要支持变量提升的特性，又要支持块级作用域的呢？" class="headerlink" title="在同一段代码中，ES6 是如何做到既要支持变量提升的特性，又要支持块级作用域的呢？"></a>在同一段代码中，ES6 是如何做到既要支持变量提升的特性，又要支持块级作用域的呢？</h5><blockquote><p>当一段代码里面既有var声明的变量也有let声明的变量的时候：  </p><ul><li>函数内部通过var声明的变量，在编译阶段全都被存放到<code>变量环境</code>里面.  </li><li>通过let声明的变量，在编译阶段会被存放到<code>词法环境</code>中。 </li><li>在函数作用域内部，通过let声明的变量并没有被存放到词法环境中。<br>也就是说：通过理解词法环境的结构和工作机制，块级作用域是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现的，通过两者的结合，JavaScript引擎也就同时支持了变量 提升和块级作用域了。</li></ul></blockquote><h4 id="10-｜-作用域和闭包：代码中出现相同的变量，JavaScript引擎是如何选择的"><a href="#10-｜-作用域和闭包：代码中出现相同的变量，JavaScript引擎是如何选择的" class="headerlink" title="10 ｜ 作用域和闭包：代码中出现相同的变量，JavaScript引擎是如何选择的"></a>10 ｜ 作用域和闭包：代码中出现相同的变量，JavaScript引擎是如何选择的</h4><hr><h5 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h5><blockquote><p>理解作用域链是理解闭包的基础，而闭包在JavaScript中无处不在，同时作用域和作用域链还是作用语言的基础，所以我们先来学习一下<code>作用域链</code>。<br>理解了调用栈、执行上下文、词法环境、变量环境等概念，那么你理解起来作用域链也会很容易,看下面一段代码：</p><pre><code>function bar() {   console.log(myName)}function foo() {   var myName = &quot;局部变量&quot;   bar()}var myName = &quot;全局变量&quot;foo()</code></pre><p>通过上面的代码，我们知道最终打印出来的结果是：”全局变量“。<br>这是因为，当一段代码使用了一个变量后，JavaScript引擎会首先在“当前的执行上下文”中去查找该变量。若没有找到，由于每个执行上下文都包含一个外部引用指向外部执行上下文，所以bar函数中的变量会去全局上下文中区域查找。我们把这个查找的链条就称为作用域链。</p></blockquote><h5 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h5><blockquote><p>foo 函数调用的 bar 函数，那为什么 bar 函数的外部引用是全局执行上下文，而不是 foo 函数的执行上下文？了解这个问题我们继续来学习词法作用域：<br>词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。<br>然后，根据词法作用域，foo 和 bar 的上级作用域都是全局作用域，所以如果 foo 或者 bar 函数使用了一个它们没有定义的变量，那么它们会到全局作用域去查找。也就是说，词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系。</p></blockquote><h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><blockquote><p>在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。<br>在使用闭包的时候，要尽量注意一个原则：如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。</p></blockquote><h4 id="11-｜-this：从JavaScript执行上下文的视角讲清楚this"><a href="#11-｜-this：从JavaScript执行上下文的视角讲清楚this" class="headerlink" title="11 ｜ this：从JavaScript执行上下文的视角讲清楚this"></a>11 ｜ this：从JavaScript执行上下文的视角讲清楚this</h4><hr><blockquote><p>首先我们要知道，在对象内部的方法中使用对象内部的属性是一个非常普遍的需求，但是JavaScript作用域机制并不支持这一点，基于这个需求，JavaScript搞出了一套this机制。    </p></blockquote><blockquote><p>在前几节中，我们提到执行上下文中包含了：<code>变量环境</code>、<code>词法环境</code>、<code>外部环境</code>、还有一个没有提及的<code>this</code>,this是和执行上下文绑定的，每个执行上下文都有一个this。<br>在08节我们总结了执行上下文主要分三种：全局执行上下文、函数执行上下文和eval执行上下文。<br>对应的this也只有这三种：全局执行上下文中的this、函数执行上下中的this和eval中的this(不做讨论)。    </p><ul><li>全局执行上下文中的this：全局执行上下文中的this指向window对象。  </li><li>函数执行上下文中的this：<ol><li>默认情况下调用一个函数，其执行上下文中的 this 也是指向 window 对象的.  </li><li>通过函数的call方法设置其this指向其他对象（还可以使用bind和apply方法来设置函数执行上下文中的this）。   </li><li>通过对象调用方法设置。（使用对象来调用其内部的一个方法，该方法的 this 是指向对象本身的。在全局环境中调用一个函数，函数内部的this指向的是全局变量window）。   </li><li>通过构造函数中设置。   </li></ol></li></ul></blockquote><h5 id="this的设计缺陷以及应对方案"><a href="#this的设计缺陷以及应对方案" class="headerlink" title="this的设计缺陷以及应对方案"></a>this的设计缺陷以及应对方案</h5><blockquote><ol><li>嵌套函数的this不会从外层函数中继承。==&gt;  1⃣️、将this保存一个self变量，利用变量作用域机制传递给嵌套函数。2⃣️、将乔套函数改为箭头函数。   </li><li>普通函数中的this默认指向全局对象window。==&gt;可以通过设置JavaScript的“严格模式”来解决。</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot;&gt;&lt;a href=&quot;#前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot; class=&quot;headerlink&quot; title=&quot;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot;&gt;&lt;/a&gt;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&lt;/h6&gt;&lt;h6 id=&quot;本篇是这个专栏的第二章：《浏览器中的JavaScript执行机制》。本章分为五节。&quot;&gt;&lt;a href=&quot;#本篇是这个专栏的第二章：《浏览器中的JavaScript执行机制》。本章分为五节。&quot; class=&quot;headerlink&quot; title=&quot;本篇是这个专栏的第二章：《浏览器中的JavaScript执行机制》。本章分为五节。&quot;&gt;&lt;/a&gt;本篇是这个专栏的第二章：《浏览器中的JavaScript执行机制》。本章分为五节。&lt;/h6&gt;
    
    </summary>
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>每周总结第十八期</title>
    <link href="http://liugezhou.online/2019/11/10/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93%E7%AC%AC%E5%8D%81%E5%85%AB%E6%9C%9F/"/>
    <id>http://liugezhou.online/2019/11/10/每周总结第十八期/</id>
    <published>2019-11-10T09:35:00.000Z</published>
    <updated>2019-11-10T12:55:38.915Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这里记录过去一周，我的一些小总结。</p></blockquote><a id="more"></a><h4 id="Feeling"><a href="#Feeling" class="headerlink" title="Feeling"></a>Feeling</h4><blockquote><p>大部分人不表达是因为没什么可表达的，只是脑子里没货，而不是不愿意表达。<br>人们说自己无法坚持做一件事，其实既缺乏坚持的能力，也缺少做事的能力。<br>非不为也，实不能也。 –From <a href="https://twitter.com/sagacity/status/1193346629287366656" target="_blank" rel="noopener">Twitter</a></p></blockquote><h4 id="碾压苹果！全球最赚钱的公司要上市了"><a href="#碾压苹果！全球最赚钱的公司要上市了" class="headerlink" title="碾压苹果！全球最赚钱的公司要上市了"></a><a href="http://global.eastmoney.com/a/201911051281700917.html" target="_blank" rel="noopener">碾压苹果！全球最赚钱的公司要上市了</a></h4><blockquote><p>沙特的阿美石油公司（Aramco）是全球最赚钱公司，决定进行 IPO。它的石油产量占全球的10％，去年净利润为1110亿美元，比苹果+谷歌+埃克森美孚还要多。该公司的总市值可能会到2万亿美元，目前世界市值最大的公司也只有1万亿美元。 </p></blockquote><h4 id="GitLab-公开拒收中国员工，你怎么看？！"><a href="#GitLab-公开拒收中国员工，你怎么看？！" class="headerlink" title="GitLab 公开拒收中国员工，你怎么看？！"></a><a href="https://www.oschina.net/news/111073/gitlab-reject-chinese-programmers" target="_blank" rel="noopener">GitLab 公开拒收中国员工，你怎么看？！</a></h4><blockquote><p>本周争论话题。<br>在GitLab.com的官方issue里，出现这样一条：我们决定对有权访问客户数据的团队成员启用“工作国家/地区封锁（job family country block）”，而封锁名单上只有两个国家——中国和俄罗斯。<br>根据GitLab的解释，意味着：</p><ul><li>GitLab不会给中国/俄罗斯公民提供Offer；</li><li>那些有权限访问客户数据的员工，现在也不能移居到中国或俄罗斯。</li></ul></blockquote><h4 id="utools"><a href="#utools" class="headerlink" title="utools"></a><a href="https://u.tools/" target="_blank" rel="noopener">utools</a></h4><blockquote><p>「uTools是一个极简、插件化、跨平台的现代桌面软件。通过自由选配丰富的插件，打造你得心应手的工具集合。<br>当你熟悉它后，能够为你节约大量时间，让你可以更加专注地改变世界。」</p></blockquote><blockquote><ul><li>通过快捷键（默认alt+space）就可以快速呼出搜索框.搜索框相当聪明。    </li><li>优秀的插件化设计，自取所需，随用随走。</li><li>只需会JavaScript、CSS、HTML就可以从零开始创造一个utools插件。</li><li>非常推荐，初上手感觉比浏览器插件好用好多。</li></ul></blockquote><h4 id="electronjs"><a href="#electronjs" class="headerlink" title="electronjs"></a><a href="https://electronjs.org/" target="_blank" rel="noopener">electronjs</a></h4><blockquote><p>如果你可以建一个网站，你就可以建一个桌面应用程序。 Electron 是一个使用 JavaScript, HTML 和 CSS 等 Web 技术创建原生程序的框架，它负责比较难搞的部分，你只需把精力放在你的应用的核心上即可。</p><ul><li>Web 技术: Electron 基于 Chromium 和 Node.js, 让你可以使用 HTML, CSS 和 JavaScript 构建应用。 </li><li>开源: Electron 是一个由 GitHub 及众多贡献者组成的活跃社区共同维护的开源项目。    </li><li>跨平台: Electron 兼容 Mac、Windows 和 Linux，可以构建出三个平台的应用程序。 </li></ul></blockquote><blockquote><p>尝试：npm install 过程中竟然第一次遇到了墙，即使开着vpn也于是无补。查找资料：<a href="https://www.jianshu.com/p/f134878af30f" target="_blank" rel="noopener">electron快速入门笔记</a>，更换淘宝镜像，启动成功。<br><img src="http://img.liugezhou.online/electron_lgz.png" alt="效果展示"></p></blockquote><h4 id="宏观视角下的浏览器"><a href="#宏观视角下的浏览器" class="headerlink" title="宏观视角下的浏览器"></a><a href="https://www.liugezhou.online/2019/11/03/%E5%AE%8F%E8%A7%82%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8/" target="_blank" rel="noopener">宏观视角下的浏览器</a></h4><blockquote><p>前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。<br>本篇是这个专栏的第一章：<a href="https://www.liugezhou.online/2019/11/03/" target="_blank" rel="noopener">宏观视角下的浏览器</a>。本章分为六讲。</p></blockquote><h4 id="Top-languages-over-time"><a href="#Top-languages-over-time" class="headerlink" title="Top languages over time"></a><a href="https://octoverse.github.com/#top-languages-over-time" target="_blank" rel="noopener">Top languages over time</a></h4><blockquote><p>This year, C# and  shell climbed the list,And for the first time ,Python outranked Java as the second most popular language on Github by repository contributors.</p></blockquote><h4 id="如何比较-Java-的字符串？"><a href="#如何比较-Java-的字符串？" class="headerlink" title="如何比较 Java 的字符串？"></a><a href="https://mp.weixin.qq.com/s/WyrRCUlelzOxyfVBrxAGUg" target="_blank" rel="noopener">如何比较 Java 的字符串？</a></h4><blockquote><p>Stack Overflow上一个访问370万+的问题：如何比较Java的字符串。<br>也就是说<code>==</code>操作符与<code>.equals()</code>方法之间有什么区别呢？ </p></blockquote><blockquote><p><code>结论</code></p><ul><li>当比较两个字符串对象的内容是否相等时，请使用 <code>.equals()</code> 方法。   </li><li>当比较两个字符串对象是否相等时，请使用<code>==</code>操作符。</li></ul></blockquote><h4 id="TypeScript入门教程"><a href="#TypeScript入门教程" class="headerlink" title="TypeScript入门教程"></a><a href="https://ts.xcatliu.com/" target="_blank" rel="noopener">TypeScript入门教程</a></h4><blockquote><p>本书是作者在学习 <a href="http://www.typescriptlang.org/" target="_blank" rel="noopener">TypeScript</a> 后整理的学习笔记。</p></blockquote><h4 id="15种CSS居中的方式，你都用过哪几种"><a href="#15种CSS居中的方式，你都用过哪几种" class="headerlink" title="15种CSS居中的方式，你都用过哪几种"></a><a href="https://cloud.tencent.com/developer/article/1115615" target="_blank" rel="noopener">15种CSS居中的方式，你都用过哪几种</a></h4><blockquote><p>CSS居中是前端工程师经常要面对的问题，也是基本技能之一。今天有时间把CSS居中的方案汇编整理了一下，目前包括水平居中，垂直居中及水平垂直居中方案共15种。如有漏掉的，还会陆续的补充进来，算做是一个备忘录吧。<br>本文作者的博客：<a href="http://42du.cn/" target="_blank" rel="noopener">http://42du.cn/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这里记录过去一周，我的一些小总结。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="每周分享" scheme="http://liugezhou.online/categories/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="每周分享" scheme="http://liugezhou.online/tags/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>No1.宏观视角下的浏览器</title>
    <link href="http://liugezhou.online/2019/11/03/No1.%E5%AE%8F%E8%A7%82%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    <id>http://liugezhou.online/2019/11/03/No1.宏观视角下的浏览器/</id>
    <published>2019-11-03T15:20:00.000Z</published>
    <updated>2019-11-13T06:01:20.570Z</updated>
    
    <content type="html"><![CDATA[<h6 id="前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。"><a href="#前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。" class="headerlink" title="前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。"></a>前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。</h6><h6 id="本篇是这个专栏的第一章：《宏观视角下的浏览器》。本章分为六讲。"><a href="#本篇是这个专栏的第一章：《宏观视角下的浏览器》。本章分为六讲。" class="headerlink" title="本篇是这个专栏的第一章：《宏观视角下的浏览器》。本章分为六讲。"></a>本篇是这个专栏的第一章：《宏观视角下的浏览器》。本章分为六讲。</h6><a id="more"></a><h4 id="01-Chrome架构：仅仅打开一个页面，为什么有四个进程"><a href="#01-Chrome架构：仅仅打开一个页面，为什么有四个进程" class="headerlink" title="01.Chrome架构：仅仅打开一个页面，为什么有四个进程"></a>01.Chrome架构：仅仅打开一个页面，为什么有四个进程</h4><hr><blockquote><p>在谷歌浏览器随便打开一个页面，点击“选项”菜单，选择“更多工具”，点击“任务管理器”，这将打开Chrome的任务管理器的窗口，你会发现一个页面上有四个以上的进程。为什么会有四个进程呢？<br>本章通过分析浏览器的进化史而展开探讨这个问题。<br>开始之前，我们必须得了解一下这个<code>进程</code>与<code>线程</code>的概念。  </p></blockquote><h5 id="线程-VS-进程"><a href="#线程-VS-进程" class="headerlink" title="线程 VS 进程"></a>线程 VS 进程</h5><blockquote><p><code>线程这个东西它是不能单独存在的，它是由进程来启动和管理的。</code> </p><p><code>一个进程就是一个程序的运行实例</code>。</p><p><code>线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率</code>。  </p><p>总结，线程与进程之间的关系有以下四个特点：</p><ol><li>进程中任一线程执行出错，都会导致整个进程崩溃。 </li><li>线程之间共享进程的数据。   </li><li>当一个进程关闭之后，操作系统会回收进程所占用的内存。   </li><li>进程之间的内容都互相隔离。(如果进程之间需要进行数据的通信，这时候需要使用用于进程间通讯(IPC)机制了)。</li></ol></blockquote><h5 id="单进程浏览器时代"><a href="#单进程浏览器时代" class="headerlink" title="单进程浏览器时代"></a>单进程浏览器时代</h5><blockquote><p>早在07年之前，市面上的浏览器都是单进程的。单进程，顾名思义是指：浏览器的所有功能模块都运行在同一个进程里。<br>如此多的功能模块运行在一个进程里，导致单进程浏览器<code>不稳定</code>、<code>不流畅</code>、<code>不安全</code>。<br>具体的表现就不说了，总之体验非常差，于是进入了“多线程浏览器”时代。    </p></blockquote><h5 id="多进程浏览器时代"><a href="#多进程浏览器时代" class="headerlink" title="多进程浏览器时代"></a>多进程浏览器时代</h5><blockquote><ul><li>多进程浏览器由于进程相互隔离，所以当一个页面或者插件崩溃的时候，影响的仅仅是当前的页面进程或者插件过程。这就完美解决了页面或者插件崩溃而导致的整个浏览器崩溃问题。JS的渲染若出现问题，影响的同样是当前的渲染页面，没有响应的仅对当前页面。而且在多进程浏览器时代，当关闭一个页面的时候，整个渲染进程会被关闭，该进程占用的内存都会被系统回收，这样也就轻松解决了浏览器页面的内存泄露问题。    </li><li>此外有关安全方面的问题：使用多线程架构可以使用<code>安全沙箱</code>。  </li></ul><p>可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在硬盘上写入任何数据，也不能在敏感位置读取任何数据(例如文档和桌面)，Chrome把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。</p></blockquote><h5 id="目前多进程架构"><a href="#目前多进程架构" class="headerlink" title="目前多进程架构"></a>目前多进程架构</h5><blockquote><p>最新的Chrome进程架构：Chrome浏览器包括：<code>1个浏览器(Brower)主进程，1个GPU进程、一个网络(NetWork)进程、多个渲染进程和多个插件进程</code>。<br>虽然多进程模型提升了浏览器的稳定性、流畅性、安全性，但是同样也会不可避免带来一些问题：  </p><ul><li><code>更高的资源占用</code> ：因为每个进程都会包含公共基础结构的副本（如JavaScript运行环境），这意味着浏览器会消耗更多的资源。  </li><li><code>更复杂的体系架构</code>：浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求。 </li></ul></blockquote><h5 id="未来面向服务的架构-SOP"><a href="#未来面向服务的架构-SOP" class="headerlink" title="未来面向服务的架构(SOP)"></a>未来面向服务的架构(SOP)</h5><blockquote><p>为了解决这些问题，2016年，Chrome团队使用“面向服务的架构“（SOP）思想设计了新的Chrome架构，这也是现阶段Chrome团队的一个主要任务。</p></blockquote><h4 id="02｜TCP协议：如何保证页面文件能被完整的送达浏览器"><a href="#02｜TCP协议：如何保证页面文件能被完整的送达浏览器" class="headerlink" title="02｜TCP协议：如何保证页面文件能被完整的送达浏览器"></a>02｜TCP协议：如何保证页面文件能被完整的送达浏览器</h4><hr><blockquote><p>在衡量Web页面性能的时候有一个重要的指标叫”FP(First Paint)”,是指从页面加载到首次开始绘制的时长。其中影响FP的一个重要因素就是<code>网络加载速度</code>。 </p><p>要优化网络加载速度，需要对网络有充分的了解，这一节重点介绍<code>在Web世界中的TCP/IP是如何工作的</code>。 </p><p>在网络中，一个文件通常会被拆分为很多数据包来进行传输，而数据包在传输过程中有很大概览丢失或者出错，那么如何保证页面文件能被完整地送达浏览器？</p></blockquote><h5 id="一个数据包的“旅程”"><a href="#一个数据包的“旅程”" class="headerlink" title="一个数据包的“旅程”"></a>一个数据包的“旅程”</h5><blockquote><ol><li><p>IP:把数据包送达目的主机<br>计算机的地址称为IP地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。<br>当从主机A向主机B发送数据(即发送数据包)，传输前，数据包会被附加上主机A和主机B的IP地址信息，这些信息会被封到一个叫做IP头的数据结构里，在这个IP头中包含IP数据包开头的信息(IP版本、源IP地址、目标地址、生存时间等信息)，于是数据包从主机A发送到主机B。  </p></li><li><p>UDP:把数据包送达应用程序<br>IP通过IP地址信息把数据包发送给指定的电脑，而UDP通过端口号把数据包发给正确的程序。<br>UDP发送数据，有各种因素会导致数据包出错，虽然UDP可以校验数据是否正确，但是<code>UDP不提供重发机制</code>，只是丢弃当前的包，且UDP在发送之后无法知道能否到达目的地。<br><code>UDP不能保证数据可靠性，但是传输速度却非常快</code>，因此UDP应用在一些关注速度但不那么严格要求数据完整性的领域，例如：在线视频、互动游戏等。  </p></li><li><p>TCP:把数据完整的送达应用程序<br>TCP(Transmission Control Protocol,传输控制协议)：他是一种面向连接的、可靠的、基于字节流的传输层通信协议。相对于UDP而言：  </p></li></ol><ul><li>对于数据包丢失情况，提供重传机制。  </li><li>TCP引入数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。 </li></ul></blockquote><h5 id="完整的TCP连接过程"><a href="#完整的TCP连接过程" class="headerlink" title="完整的TCP连接过程"></a>完整的TCP连接过程</h5><blockquote><p>我们现在已经知道TCP单个数据包的传输流程和UDP流程差不多，不同在于，通过TCP头信息可以保证一块大的数据传输的完整性。<br>一个完整的TCP连接过程，其生命周期包括了“建立连接“、”数据传输“、”断开连接“三个阶段。</p><ul><li>建立连接阶段：这个阶段通过“三次握手”来建立客户端和服务器之间的连接。  </li><li>数据传输阶段：在该阶段，接收端需要对每个数据包进行确认操作。接收端应该在接收数据后要发送确认数据包给发送端，若发送端没有接收到这个确认，则判断数据包丢失，并触发发送端的重发机制。  </li><li>断开连接阶段：数据传输完毕，终止连接，通过最后一个阶段“四次挥手”来保证双方都能断开连接。</li></ul></blockquote><h4 id="03｜HTTP请求流程：为什么很多站点第二次打开速度会很快？"><a href="#03｜HTTP请求流程：为什么很多站点第二次打开速度会很快？" class="headerlink" title="03｜HTTP请求流程：为什么很多站点第二次打开速度会很快？"></a>03｜HTTP请求流程：为什么很多站点第二次打开速度会很快？</h4><hr><blockquote><p>首先的首先我们知道：HTTP协议建立在TCP连接基础之上的。<code>HTTP是一种允许浏览器向服务器获取资源的协议，是Web的基础。HTTP是浏览器使用最广的协议</code>。</p><p>简单说说HTTP和TCP的关系：浏览器使用HTTP协议作为<code>应用层协议</code>，用来封装请求的文本信息，并使用TCP/IP作为<code>传输层协议</code>将它发到网路上,所以HTTP工作前，需要通过TCP与服务器建立连接，也就是说：<code>HTTP的内容是通过TCP的传输数据阶段来实现的</code>。</p></blockquote><h5 id="浏览器端发起HTTP请求流程"><a href="#浏览器端发起HTTP请求流程" class="headerlink" title="浏览器端发起HTTP请求流程"></a>浏览器端发起HTTP请求流程</h5><blockquote><p>如果在浏览器地址栏里输入：<a href="https://www.liugezhou.online" target="_blank" rel="noopener">https://www.liugezhou.online</a> 这个网址后,浏览器这个庞然大物，它的背后都做些什么呢？</p></blockquote><ul><li>构建请求<blockquote><p>首先浏览器构建请求行信息，构建好之后，浏览器准备发起网路请求。</p></blockquote></li><li>查找缓存<blockquote><p>在准备发起网路请求阶段，浏览器偷偷的在它的缓存中查询是否有要请求的资源。<br>若有：拦截请求，返回资源副本，直接结束请求。<br>若缓存查找失败：继续下一步。  </p></blockquote></li><li>准备IP地址和端口号<blockquote><p>这个IP地址和端口号的获取，肯定是通过域名与其映射，即“域名系统”，也就是我们熟知的DNS。<br>于是，浏览器第一步会请求DNS返回域名对应的IP，如果没有特别指明端口号，则默认为80。<br>(浏览器提供了DNS数据缓存服务，若缓存过也就不会去请求，直接解析。从而减少一次网络请求)</p></blockquote></li><li>等待TCP队列<blockquote><p>拿到IP地址与端口号后，还需要在TCP队列中排队才能建立TCP连接。<br>这是因为：Chrome有个机制，同一个域名同时最多只能建立6个TCP连接，若此刻同时有10个请求发生。则四个会进入TCP队列进行排队。<br>当然，若当前请求数量少于6个，则会直接进入下一步。 </p></blockquote></li><li>建立TCP连接 <blockquote><p>建立TCP连接，上一节我们已经知道，一个完整的TCP连接过程包括“建立连接”、“数据传输”、“断开连接“三个阶段。  </p></blockquote></li><li>发送HTTP请求<blockquote><p>HTTP请求是在TCP连接的数据传输阶段工作的，这个时候浏览器向服务器发送请求行，它包括请求方法、请求URI、HTTP版本协议。，HTTP中的数据在这个通信过程中传输。</p></blockquote></li></ul><h5 id="服务器端处理HTTP请求流程"><a href="#服务器端处理HTTP请求流程" class="headerlink" title="服务器端处理HTTP请求流程"></a>服务器端处理HTTP请求流程</h5><blockquote><p>这里可以在命令行中输入<code>curl -i https://www.google.com</code>来查看返回请求数据。 (-i 返回响应行、响应头和响应体信息。 -I 不返回响应体。)<br>返回网站的HTTP协议、Connection、Location、Cache-Control等信息。 </p><p>通常情况，一旦服务器向客户端返回了请求数据，它就要关闭TCP连接，但是如果浏览器或者服务器设置了<code>Connection:keep-alive</code>，那么TCP连接在发送后将仍保持打开状态。<code>保持TCP连接可以省去下次请求时需要建立连接的时间，提升资源加载速度</code>。</p></blockquote><h5 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h5><ol><li>为什么很多站点第二次打开速度会很快？<blockquote><p>主要原因肯定是第一次加载页面的过程中，缓存了一些数据(从上面的过程分析，我们知道<code>DNS缓存</code>和<code>页面资源缓存</code>这两块数据是会被浏览器缓存起来的).<br>网站把很多资源都缓存到了本地，浏览器缓存直接使用本地副本来回应请求，而不会产生真实的网络请求，从而节省了时间。</p></blockquote></li><li>登录状态是如何保持的 <blockquote><p>简单地说，如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保持到本地。当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。</p></blockquote></li></ol><h4 id="04｜导航流程：从输入URl到页面展示，这中间发生了什么"><a href="#04｜导航流程：从输入URl到页面展示，这中间发生了什么" class="headerlink" title="04｜导航流程：从输入URl到页面展示，这中间发生了什么"></a>04｜导航流程：从输入URl到页面展示，这中间发生了什么</h4><hr><blockquote><p>流程开始前，回顾下浏览器进程、网络进程、渲染进程的各自主要职责：  </p><ul><li>浏览器进程：主要负责<code>用户交互</code>、<code>子进程管理</code>和<code>文件储存</code>等功能。  </li><li>网络进程：面向渲染进程或浏览器进程提供<code>网络资源下载</code>。  </li><li>渲染进程：将HTML、CSS、JS、图片等资源解析为可以显示和交互的页面。 </li></ul></blockquote><h5 id="过程大致描述"><a href="#过程大致描述" class="headerlink" title="过程大致描述"></a>过程大致描述</h5><blockquote><ul><li>首先，用户从浏览器进程中输入请求信息。  </li><li>然后，网络进程发起URL请求。 </li><li>服务器响应URL请求后，浏览器进程开始准备渲染进程。 </li><li>渲染进程准备好以后，需要先向渲染进程提交页面数据，这称之为文档提交阶段。  </li><li>渲染进程接收到文档信息之后，便开始解析页面和加载子资源，完成页面的渲染。<br>这其中，用户发出URL请求到页面开始解析的过程，就叫做导航。</li></ul></blockquote><h5 id="从输入URL到页面展示–过程细节"><a href="#从输入URL到页面展示–过程细节" class="headerlink" title="从输入URL到页面展示–过程细节"></a>从输入URL到页面展示–过程细节</h5><blockquote><ul><li>响应数据类型处理：根据服务端返回的<code>Content-Type</code>字段来决定如何显示响应体的内容。</li><li>同一站点下的多个页面会运行在一个渲染进程中。</li></ul></blockquote><h5 id="“从输入-URL-到页面展示，这中间发生了什么？”-留言总结"><a href="#“从输入-URL-到页面展示，这中间发生了什么？”-留言总结" class="headerlink" title="“从输入 URL 到页面展示，这中间发生了什么？”(留言总结)"></a>“从输入 URL 到页面展示，这中间发生了什么？”(留言总结)</h5><blockquote><ol><li>用户输入url并回车·</li><li>浏览器进程检查url，组装协议，构成完整的url</li><li>浏览器进程通过进程间通信（IPC）把url请求发送给网络进程</li><li>网络进程接收到url请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程</li><li>如果没有，网络进程向web服务器发起http请求（网络请求），请求流程如下：<br>5.1 进行DNS解析，获取服务器ip地址，端口<br>5.2 利用ip地址和服务器建立tcp连接<br>5.3 构建请求头信息<br>5.4 发送请求头信息<br>5.5 服务器响应后，网络进程接收响应头和响应信息，并解析响应内容</li><li>网络进程解析响应流程；<br>6.1 检查状态码，如果是301/302，则需要重定向，从Location自动中读取地址，重新进行第4步<br>6.2 200响应处理： <pre><code>检查响应类型Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行后续的渲染，如果是html则通知浏览器进程准备渲染进程准备进行渲染。</code></pre></li><li>准备渲染进程<br>7.1 浏览器进程检查当前url是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程</li><li>传输数据、更新状态<br>8.1 渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”<br>8.2 渲染进程接收完数据后，向浏览器发送“确认提交”<br>8.3 浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏url、前进后退的历史状态、更新web页面。</li></ol></blockquote><h4 id="05｜渲染流程-上-：HTML、CSS和JavaScript，是如何变成页面的"><a href="#05｜渲染流程-上-：HTML、CSS和JavaScript，是如何变成页面的" class="headerlink" title="05｜渲染流程(上)：HTML、CSS和JavaScript，是如何变成页面的"></a>05｜渲染流程(上)：HTML、CSS和JavaScript，是如何变成页面的</h4><hr><blockquote><p>按照渲染的时间顺序，渲染流水线可分为以下几个构建阶段：<br><code>构建DOM树</code>、<code>样式计算</code>、<code>布局阶段</code>、<code>分层</code>、<code>绘制</code>、<code>光栅化</code>、<code>合成</code>。<br>本节主要讨论前三个阶段。  </p></blockquote><h5 id="构建DOM树"><a href="#构建DOM树" class="headerlink" title="构建DOM树"></a>构建DOM树</h5><blockquote><p>因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。<br>DOM树和HTML内容几乎一样，但和HTML不同的是：DOM是保存在内存中的树结构。  </p></blockquote><h5 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h5><blockquote><ol><li>把CSS转换为浏览器能够理解的结构。</li><li>转换样式表中的属性值，使其标准化。<br>「例如rem -&gt; px, red -&gt; rgb(255,0,0),bold -&gt; 700」  </li><li>计算出DOM树中每个节点的具体样式。<br>「CSS继承：每个DOM节点都包含有父节点的样式」<br>「CSS层叠：它在 CSS 处于核心地位，定义了如何合并来自多个源的属性值的算法」<br>「样式来源：如果一个元素不提供任何样式，默认使用的是UserAgent样式—浏览器提供的一组默认样式」。</li></ol></blockquote><h5 id="布局阶段"><a href="#布局阶段" class="headerlink" title="布局阶段"></a>布局阶段</h5><blockquote><p>内容： 布局阶段是根据DOM树和样式计算出元素的几何位置。 </p><ol><li>创建布局树「构建一颗只包含可见元素的布局树」  </li><li>布局计算 </li></ol></blockquote><blockquote><p>「在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 <code>LayoutNG</code>，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。」</p></blockquote><h4 id="06-渲染流程-下-：HTML、CSS和JavaScript，是如何变成页面的"><a href="#06-渲染流程-下-：HTML、CSS和JavaScript，是如何变成页面的" class="headerlink" title="06|渲染流程(下)：HTML、CSS和JavaScript，是如何变成页面的"></a>06|渲染流程(下)：HTML、CSS和JavaScript，是如何变成页面的</h4><hr><h5 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h5><blockquote><p>为了生成一些复杂效果(3D变换、页面滚动、z轴排序等)，渲染引擎还需要为特定的节点生成专用的图层，生成一颗对应的图层树.</p><ul><li>并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层.   </li><li>素有了层叠上下文的属性或者需要被剪裁，满足这任意一点，就会被提升成为单独一层。  </li></ul></blockquote><h5 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h5><blockquote><p>一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个<code>待绘制列表</code>。「可在浏览器开发者工具的Layers中查看。」</p></blockquote><h5 id="栅格化操作"><a href="#栅格化操作" class="headerlink" title="栅格化操作"></a>栅格化操作</h5><blockquote><p>所谓栅格化，是指将图块转换为位图。<br>栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中. </p></blockquote><h5 id="合成和显示"><a href="#合成和显示" class="headerlink" title="合成和显示"></a>合成和显示</h5><blockquote><p>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。经过浏览器就会显示出页面。  </p></blockquote><blockquote><p>一个完整的渲染流程大致可总结为如下：  </p><ul><li>渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。 </li><li>渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。  </li><li>创建布局树，并计算元素的布局信息。对布局树进行分层，并生成分层树。  </li><li>为每个图层生成绘制列表，并将其提交到合成线程。  </li><li>合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。  </li><li>合成线程发送绘制图块命令 DrawQuad 给浏览器进程。浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。</li></ul></blockquote><h5 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h5><h6 id="重排-更新了元素的几何属性"><a href="#重排-更新了元素的几何属性" class="headerlink" title="重排(更新了元素的几何属性)"></a>重排(更新了元素的几何属性)</h6><blockquote><p>使用CSS或者JS使元素的几何位置发生了改变，例如改变元素的宽度、高度等，这会使得浏览器触发重新布局、解析之后的一系列子阶段，这个过程就是重排。无疑，重排需要更新完整的渲染流水线，所以开销是最大的。 </p></blockquote><h6 id="重绘-更新元素的绘制属性"><a href="#重绘-更新元素的绘制属性" class="headerlink" title="重绘(更新元素的绘制属性)"></a>重绘(更新元素的绘制属性)</h6><blockquote><p>比如改变了元素的背景色，这会触发浏览器进行重绘之后的操作。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。  </p></blockquote><h6 id="直接合成阶段"><a href="#直接合成阶段" class="headerlink" title="直接合成阶段"></a>直接合成阶段</h6><blockquote><p>那如果你更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成.<br>例如CSS的transform实现的动画效果，可以避开重排和重绘阶段，相对于重绘和重排，合成能大大提升绘制效率。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot;&gt;&lt;a href=&quot;#前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot; class=&quot;headerlink&quot; title=&quot;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot;&gt;&lt;/a&gt;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&lt;/h6&gt;&lt;h6 id=&quot;本篇是这个专栏的第一章：《宏观视角下的浏览器》。本章分为六讲。&quot;&gt;&lt;a href=&quot;#本篇是这个专栏的第一章：《宏观视角下的浏览器》。本章分为六讲。&quot; class=&quot;headerlink&quot; title=&quot;本篇是这个专栏的第一章：《宏观视角下的浏览器》。本章分为六讲。&quot;&gt;&lt;/a&gt;本篇是这个专栏的第一章：《宏观视角下的浏览器》。本章分为六讲。&lt;/h6&gt;
    
    </summary>
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>每周总结第十七期</title>
    <link href="http://liugezhou.online/2019/11/03/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93%E7%AC%AC%E5%8D%81%E4%B8%83%E6%9C%9F/"/>
    <id>http://liugezhou.online/2019/11/03/每周总结第十七期/</id>
    <published>2019-11-03T15:00:00.000Z</published>
    <updated>2019-11-03T15:03:31.694Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这里记录过去一周，我的一些小总结。</p></blockquote><a id="more"></a><h4 id="Feeling"><a href="#Feeling" class="headerlink" title="Feeling"></a>Feeling</h4><blockquote><p>想想自己从小到大一直在做的事，除了抽烟就是喝酒。<br>二十多年来，不止一次的想要去坚持做一件事，但是往往三天结束，高考那会也未曾幸免，可能以后也不会幸免。<br>但我还是比较觉得“常立志”，比“立长志”要来的热血一些。因为时不时的兴奋一把，会让我在这活不明白的世上多去感受一些东西。<br>之前是受阮一峰，阮老师的周五公号文章推送影响，后来是看到很多人在坚持做的一些事，让我也感觉作为一个个体而言，一定要尝试去坚持做一件事。做什么事可能不重要，做的对不对可能也不重要，做的好不好或许也不重要，重要的是不停寻找，找到了这么一件想坚持做下去的事。如果这件事还带给了极大的乐趣与自我满足，那么便是极好的。<br>就像找另一半一样，如果当作人生的目标去寻找，那肯定会找到的，然后接下来就是油盐酱醋茶，如何平淡而不失乐趣的经营下去。</p></blockquote><h4 id="小丑-Joker"><a href="#小丑-Joker" class="headerlink" title="小丑(Joker)"></a>小丑(Joker)</h4><blockquote><p>《小丑》这部电影与今年10月4日在美国上映，「本片的故事独立于DCEU（DC[正义联盟]系列）之外，故事背景设置在20世纪80年代，讲述了一位生活陷入困境的脱口秀喜剧演员渐渐走向精神的崩溃，在哥谭市开始了疯狂的犯罪生涯，最终成为了蝙蝠侠的宿敌“小丑”的故事。」   </p></blockquote><blockquote><p>「他是美国DC漫画旗下的超级反派，常年稳居美媒票选的TOP100漫画反派角色第一名的位置，IGN评选的史上最伟大漫画反派角色中，小丑排名第一。」 </p><p>看这部电影的来源是：<a href="https://movie.douban.com/review/10454598/" target="_blank" rel="noopener">《小丑》超万字终极解析，一个精神病患者从受害者到恶魔的自白</a> </p><p>看完这部电影最大的感受是：思想能够上上下下、完完全全改变一个人的所有。</p><p>当然这个角色被多数人熟知是在《蝙蝠侠～黑暗骑士》中，在这部电影中，这个小丑「向观众展现了没有逻辑的恶」，小丑饰演者「希斯·莱杰」，「2008年1月22日，被人发现死于纽约的公寓内，时年28岁。很多人猜测他是因为受到了小丑这一角色的不良影响而自杀」。 </p></blockquote><h4 id="人人网"><a href="#人人网" class="headerlink" title="人人网"></a>人人网</h4><blockquote><p>「人人网曾是中国领先的实名制社交网络平台。」<br>「2015年1月30日，人人网发消息称将下线站内信功能。」<br>「2018年11月14日，人人公司宣布以2000万美元代价把人人社交网络全部资产出售予北京多牛互动传媒股份有限公司 。」<br>「2019年10月，“人人”APP在苹果商店上架。」</p></blockquote><blockquote><p>目前人人网之前的账号仍可登录，明星大V们的信息记录都清空了，而作者本人未删除的消息都还在，然后我看了一下之前转发的一些文章，链接到的地址七七八八的被删的差不多。<br>由小看大，这很有可能说明在网络的世界里，人类的文明、言语、艺术、文化等一些人们真正关注的东西，可能不被历史铭记。各种网站、巨头公司当不存在商业运作的动力时，业务不再继续，信息记录会永远丢在某个硬盘里。人们的言论、关注也在一次次嘈杂之中被淹没。<br>然而我之前一直认为现在的历史不可能会发生“焚书坑儒”之事，然而，有可能发生的事就一定会发生的。</p></blockquote><h4 id="三种JS方法重定向到另一个网页的方法"><a href="#三种JS方法重定向到另一个网页的方法" class="headerlink" title="三种JS方法重定向到另一个网页的方法"></a>三种JS方法重定向到另一个网页的方法</h4><blockquote><ul><li>location.href </li><li>location.replace </li><li>location.assign<br>所有方法的输出都相同，但location.replace()方法从文档历史记录中删除当前文档的url。因此，如果希望选项导航回原始文档，最好使用location.assign()方法。</li></ul></blockquote><h4 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h4><h6 id="Vue源码"><a href="#Vue源码" class="headerlink" title="Vue源码"></a>Vue源码</h6><blockquote><p>「Vue.js 3.x 想全面替代 Vue.js 2.x 需要有相当长的路要走，未来相当长一段时间 Vue.js 2.x 仍然是主流，Vue.js 2.x 的源码学习并没有过时，如果你是一个 Vue.js 2.x 的使用者，就应该去学习 Vue.js 2.x 的源码。」</p></blockquote><h6 id="Vue组件通信有哪几种方式"><a href="#Vue组件通信有哪几种方式" class="headerlink" title="Vue组件通信有哪几种方式"></a>Vue组件通信有哪几种方式</h6><blockquote><ul><li>父子组件通信 : <code>props/$emit</code> </li><li>父子组件通信: <code>ref与$parent/$children</code> </li><li>父子、隔代、兄弟组件通信:<code>EventBus($emit/$on)</code> </li><li>隔代组件通信:<code>$attrs/$listeners</code>    </li><li>隔代组件通信:<code>provide/inject</code>    </li><li>Vuex适用于父子、隔代、兄弟组件通信。主要包括的模块为：State、getter、Mutation、Action、Module</li></ul></blockquote><h6 id="在Vue2-x中，是如何实现数据双向绑定的"><a href="#在Vue2-x中，是如何实现数据双向绑定的" class="headerlink" title="在Vue2.x中，是如何实现数据双向绑定的"></a>在Vue2.x中，是如何实现数据双向绑定的</h6><blockquote><p>一句话总结：Vue内部通过Object.defineProperty方法属性拦截的方式，把data对象里的每个数据的读写转换成getter/setter，当数据变化时视图发生更新。 </p><p>但是Object.defineProperty方法只能对属性进行数据劫持，不能对整个对象进行劫持，同理无法对数组进行劫持，但是，我们在使用Vue框架的时候都知道，Vue能检测到对象和数组（部分方法的操作）的变化，那么它是怎么实现的呢？   </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Observe a list of Array items.</span><br><span class="line"> */</span><br><span class="line">observeArray (items: Array&lt;any&gt;) &#123;</span><br><span class="line">  for (let i = 0, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">    observe(items[i])  // observe 功能为监测数据的变化</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 对属性进行递归遍历</span><br><span class="line"> */</span><br><span class="line">let childOb = !shallow &amp;&amp; observe(val) // observe 功能为监测数据的变化</span><br></pre></td></tr></table></figure><blockquote><p>通过以上 Vue 源码部分查看，我们就能知道 Vue 框架是通过遍历数组 和递归遍历对象，从而达到利用 Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听。</p></blockquote><h6 id="Proxy与Object-definePropertyObject-defineProperty优劣对比"><a href="#Proxy与Object-definePropertyObject-defineProperty优劣对比" class="headerlink" title="Proxy与Object.definePropertyObject.defineProperty优劣对比"></a>Proxy与Object.definePropertyObject.defineProperty优劣对比</h6><blockquote><p>Proxy优势：</p><ul><li>Proxy可以直接监听对象而非属性</li><li>Proxy可以直接监听数组的变化 </li><li>Proxy有多达13中拦截方法，不限于apply、ownKeys、deleteProperty、has等等是Object.defineProperty不具备的。 </li><li>Proxy返回的是一个新对象，我们可以只操作新的对象达到目的，而Object.defineProperty只能遍历对象属性直接修改。 </li><li>Proxy作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利。<br>而Object.defineProperty兼容性好，支持IE9，Proxy存在浏览器兼容性问题，无法用polyfill磨平。</li></ul></blockquote><h5 id="30-道-Vue-面试题，内含详细讲解"><a href="#30-道-Vue-面试题，内含详细讲解" class="headerlink" title="30 道 Vue 面试题，内含详细讲解"></a><a href="https://juejin.im/post/5d59f2a451882549be53b170#heading-18" target="_blank" rel="noopener">30 道 Vue 面试题，内含详细讲解</a></h5>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这里记录过去一周，我的一些小总结。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="每周分享" scheme="http://liugezhou.online/categories/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="每周分享" scheme="http://liugezhou.online/tags/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>每周分享第十六期</title>
    <link href="http://liugezhou.online/2019/10/27/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC%E5%8D%81%E5%85%AD%E6%9C%9F/"/>
    <id>http://liugezhou.online/2019/10/27/每周分享第十六期/</id>
    <published>2019-10-27T13:06:00.000Z</published>
    <updated>2019-10-27T13:05:54.147Z</updated>
    
    <content type="html"><![CDATA[<h2 id="每周分享第十六期"><a href="#每周分享第十六期" class="headerlink" title="每周分享第十六期"></a>每周分享第十六期</h2><blockquote><p>这里记录我的周末，我的关注以及值得记录的东西。</p></blockquote><a id="more"></a><h4 id="刊首语"><a href="#刊首语" class="headerlink" title="刊首语"></a>刊首语</h4><blockquote><p>我们在这个世界上辛苦劳作，来回奔波是为了什么？<br>所有这些贪婪和欲望，所有这些对财富、权利和名声的追求，其目的到底何在？<br>归根结底，是为了得到他人的爱和认同。<br><cite>亚当·斯密《道德情操论》</cite></p></blockquote><h4 id="拼多多百亿补贴"><a href="#拼多多百亿补贴" class="headerlink" title="拼多多百亿补贴"></a>拼多多百亿补贴</h4><blockquote><p>双十一就来了，我是一个不怎么在购物网站混战的小年轻，特别是近几年看到的各种打折券、更是眼花缭乱，因此买东西一般只买那种不搞价、官方统一价的物品。<br>然后这几天看到了PDD的百亿补贴活动，MacBookPro双十一补贴到手价不到一万七，比我买的时候整整便宜了三千块，血亏啊。<br>貌似是在本周五纳斯达克收盘价时，拼多多股价上涨12.5%，其市值超越京东，成为中国第四大互联网公司，一个成长仅四年的公司发展这么迅速，真是挺牛皮的。<br>因此双十一要买东西的话，可以在拼多多上看一下，货比三家瞅一瞅。</p></blockquote><h4 id="Github可视化大数据平台"><a href="#Github可视化大数据平台" class="headerlink" title="Github可视化大数据平台"></a>Github可视化大数据平台</h4><blockquote><p>现在做政府项目的大数据可视化平台挺火，很多政府机构都喜欢打造各个行业的大数据可视化平台。<br>Github上有个开源项目，基于Vue构建一个Github的可视化大数据平台，这个开源项目是：<a href="https://github.com/HongqingCao/GitDataV" target="_blank" rel="noopener">GitDataV</a>.<br>Github主页的生成效果图：<br><img src="http://img.liugezhou.online/GitDataV.png" alt="GitDataV"></p></blockquote><h4 id="nodebestpractices"><a href="#nodebestpractices" class="headerlink" title="nodebestpractices"></a><a href="https://github.com/goldbergyoni/nodebestpractices" target="_blank" rel="noopener">nodebestpractices</a></h4><blockquote><p>一本在线书籍–Node.js最佳实践。是对Node.js最佳实践中排名最高的内容的总结和分享。 Star：35.1k.</p></blockquote><h4 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a><a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">leetcode</a></h4><blockquote><p>leetcode题解，记录自己的leetcode解题之路。</p></blockquote><h4 id="这个网站的确很酷"><a href="#这个网站的确很酷" class="headerlink" title="这个网站的确很酷"></a><a href="https://bruno-simon.com/" target="_blank" rel="noopener">这个网站的确很酷</a></h4><blockquote><p>阮老师Twitter文：<br>“这是很久以来，我见过的最酷主页，整个页面需要3D导航。<a href="https://bruno-simon.com" target="_blank" rel="noopener">https://bruno-simon.com</a><br>页面源码是开源的。<a href="https://github.com/brunosimon/folio-2019”" target="_blank" rel="noopener">https://github.com/brunosimon/folio-2019”</a></p></blockquote><blockquote><p>Made with #thressJS and # canonJS</p></blockquote><h4 id="Vue-js3-x源码解析先导"><a href="#Vue-js3-x源码解析先导" class="headerlink" title="Vue.js3.x源码解析先导"></a><a href="https://mp.weixin.qq.com/s/q8PVgF7_sL0XhcBfP1WDPA" target="_blank" rel="noopener">Vue.js3.x源码解析先导</a></h4><blockquote><p>黄老师的一篇对于3.0源码的介绍。</p></blockquote><h4 id="是学不动还是不想学"><a href="#是学不动还是不想学" class="headerlink" title="是学不动还是不想学"></a>是学不动还是不想学</h4><blockquote><p>各种技术文章、各种公众号推送、各种人工智能培训班广告、各种知识付费APP，充斥眼球与大脑.<br>我们都知道技术是学不完的，但还是有看到什么新的课程慌的一批的感觉，什么TS、Vue3源码、WebGL、NodeJS等等等等，我知道应该去动身学习，但是总是会出现学不下去的情况，造成这种情况的原因是现在各种分散注意力的消息过于庞杂，一会东、一会西，太容易找不到方向。<br>这种情况下，得收心，管他弱水三千，只取一瓢。<br>并不是学不动，是不想学罢了。  </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;每周分享第十六期&quot;&gt;&lt;a href=&quot;#每周分享第十六期&quot; class=&quot;headerlink&quot; title=&quot;每周分享第十六期&quot;&gt;&lt;/a&gt;每周分享第十六期&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;这里记录我的周末，我的关注以及值得记录的东西。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="每周分享" scheme="http://liugezhou.online/categories/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="每周分享" scheme="http://liugezhou.online/tags/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>每周分享第十五期</title>
    <link href="http://liugezhou.online/2019/10/20/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC%E5%8D%81%E4%BA%94%E6%9C%9F/"/>
    <id>http://liugezhou.online/2019/10/20/每周分享第十五期/</id>
    <published>2019-10-20T10:20:00.000Z</published>
    <updated>2019-10-20T10:21:30.758Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这里记录我的周末，我的关注以及值得记录的东西。</p></blockquote><a id="more"></a><h5 id="刊首语"><a href="#刊首语" class="headerlink" title="刊首语"></a>刊首语</h5><blockquote><p>不同肤色、不同文化、不同国籍的生活在这个星球上的人，大都觉得是按自己的生活方式在度此生。<br>我也会这么认为，但事实可能大相径庭。<br>很多时候，我会觉得自己是悲哀的：没有文化、没有信仰、没有追求、没有修养、不了解历史、不敢关心政治。<br>总结为一句话就是：没有过意识形态的形成。 </p><p>不知是对世界百花齐放思想散播的招架不住，还是由于人类本质劣性的残留，亦或者是社会发展带来的人心躁动，我竟记不起上次在何时感动，我竟再未关注社会生活那些人性与善良，进入眼帘的的只有动乱与不幸。<br>我不再抱有一颗怜悯之心、有些厌倦社会生活的伪装，我想是因为还不能聚焦自己，未能再作出一件有成就的事、也再未能给人带来些快乐与微笑。<br>这是我个人的悲哀，可能也是社会的一个缩影·。<br><cite>看动漫《赌博默示录》、《赌博破戒录》而感</cite></p></blockquote><h4 id="马拉松"><a href="#马拉松" class="headerlink" title="马拉松"></a>马拉松</h4><blockquote><p><code>肯尼亚</code>的世界纪录保持者<code>埃留德·基普乔格</code>（Eliud Kipchoge）10月12日在维也纳以<code>1:59:40</code>的成绩，成为第一个马拉松进入两小时以内的人！  </p><p>这相当于，100米的平均速度为17秒，然后不间断跑422个这样的100米。</p><p>不过，由于这是一次专门为他破记录举办的挑战赛，为了创造记录，有41个人配合他跑，为他挡风和配速，所以国际田联不会承认这个纪录.</p></blockquote><h4 id="英雄联盟"><a href="#英雄联盟" class="headerlink" title="英雄联盟"></a>英雄联盟</h4><blockquote><p>英雄联盟手游预约开启，新一轮的手游狂潮要到来了，吗？  </p></blockquote><h4 id="世界互联网大会"><a href="#世界互联网大会" class="headerlink" title="世界互联网大会"></a>世界互联网大会</h4><blockquote><p>第六届世界互联网大会，将于10月20日-22日在浙江乌镇召开。本次大会以“智能互联 开放合作——携手共建网络空间命运共同体”为主题。</p></blockquote><h4 id="VSCode–mock数据"><a href="#VSCode–mock数据" class="headerlink" title="VSCode–mock数据"></a>VSCode–mock数据</h4><blockquote><p>掘金沸点上看到一个VSCode插件：<code>Mock_Myself</code>，为日常开发提供mock数据，在后端接口还未完善下，可以先自己模拟一些数据进行页面展示数据的代码开发。</p></blockquote><h4 id="javascript-questions"><a href="#javascript-questions" class="headerlink" title="javascript-questions"></a><a href="https://github.com/lydiahallie/javascript-questions/blob/master/zh-CN/README-zh_CN.md" target="_blank" rel="noopener">javascript-questions</a></h4><blockquote><p>JavaScript 进阶问题列表。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;我在我的 Instagram 上每天都会发布 JavaScript 的多选问题，并且同时也会在这个仓库中发布。  </span><br><span class="line">从基础到进阶，测试你有多了解 JavaScript，刷新你的知识，或者帮助你的 coding 面试！ 💪 🚀 我每周都会在这个仓库下更新新的问题。  </span><br><span class="line">答案在问题下方的折叠部分，点击即可展开问题。祝你好运 ❤️&quot;</span><br></pre></td></tr></table></figure></blockquote><h4 id="奶牛快传"><a href="#奶牛快传" class="headerlink" title="奶牛快传"></a><a href="https://cowtransfer.com/" target="_blank" rel="noopener">奶牛快传</a></h4><blockquote><p>平时我们用微信发送文件大小会限制在20M，不怎么方便，这是一个在线快传文件网站，上传文件速度特别快，不用注册就可以在线传输本地的文件，传输完毕后只需要将下载链接发送给对方在线下载即可，不需要使用U盘等拷贝文件，非常方便。<br>可能会有风险，管理员会看得到，如若担心推荐此网站的楼主建议压缩文件的时候设置密码上传。  </p></blockquote><h4 id="IPhone使用小技巧"><a href="#IPhone使用小技巧" class="headerlink" title="IPhone使用小技巧"></a>IPhone使用小技巧</h4><blockquote><p>IPhone在文本框输入文字或者网站的时候，会出现这样一个问题：直接用手指点击刚输入内容到某处时，极不方便。<br>这个时候，你可以长按默认输入法的空格键，然后指针便可以拖动了。  </p></blockquote><h4 id="当然我在扯淡"><a href="#当然我在扯淡" class="headerlink" title="当然我在扯淡"></a><a href="http://yinwang.org" target="_blank" rel="noopener">当然我在扯淡</a></h4><blockquote><p>个人博客：<a href="http://yinwang.org" target="_blank" rel="noopener">当然我在扯淡</a>。<br>王垠[yín]，四川大学97级本科毕业，保送到清华大学计算机系直博。期间曾在清华大学计算机系软件工程专业就读，主要进行集成电路布线算法的研究。在此期间，他因《完全用GNU/Linux工作》一文和对TeX的推广等“非研究成果的业余东西”而出名。 在只剩一年就要博士毕业的时候，他申请退学，并将1万7千余字的“退学申请书”（题为清华梦的粉碎）公布在网上，引起舆论界一时对教育体制、理想主义等的热议。</p></blockquote><h4 id="idea激活码"><a href="#idea激活码" class="headerlink" title="idea激活码"></a>idea激活码</h4><blockquote><p>一大批idea激活码失效，window系统下激活码地址：<a href="https://www.lanzous.com/i5clxlc" target="_blank" rel="noopener">https://www.lanzous.com/i5clxlc</a>  </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这里记录我的周末，我的关注以及值得记录的东西。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="每周分享" scheme="http://liugezhou.online/categories/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="每周分享" scheme="http://liugezhou.online/tags/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>弱(强)类型语言、静(动)态语言、编译(解释)型语言概念总览</title>
    <link href="http://liugezhou.online/2019/10/15/%E5%BC%B1(%E5%BC%BA)%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80%E3%80%81%E9%9D%99(%E5%8A%A8)%E6%80%81%E8%AF%AD%E8%A8%80%E3%80%81%E7%BC%96%E8%AF%91(%E8%A7%A3%E9%87%8A)%E5%9E%8B%E8%AF%AD%E8%A8%80%E6%A6%82%E5%BF%B5%E6%80%BB%E8%A7%88/"/>
    <id>http://liugezhou.online/2019/10/15/弱(强)类型语言、静(动)态语言、编译(解释)型语言概念总览/</id>
    <published>2019-10-14T16:00:00.000Z</published>
    <updated>2019-10-15T02:56:46.475Z</updated>
    
    <content type="html"><![CDATA[<h4 id="这篇文章用来彻底区分各种语言概念的区别"><a href="#这篇文章用来彻底区分各种语言概念的区别" class="headerlink" title="这篇文章用来彻底区分各种语言概念的区别."></a>这篇文章用来彻底区分各种<code>语言</code>概念的区别.</h4><a id="more"></a><h3 id="动态语言-VS-静态语言"><a href="#动态语言-VS-静态语言" class="headerlink" title="动态语言 VS 静态语言"></a>动态语言 VS 静态语言</h3><blockquote><p>每种编程语言都具有内建的数据类型，但它们的数据类型常有不同之处，使用方式也不一样，比如C语言、Java语言在定义变量前，就需要确定变量的类型。<br>这种声明变量的特点是：在声明变量之前需要先定义变量类型。我们把这种在使用之前就需要确认其变量数据类型的称为<code>静态语言</code>。<br>相反地，我们把在运行过程中需要检查数据类型的语言称为<code>动态语言</code>。</p></blockquote><h3 id="强类型语言-VS-弱类型语言"><a href="#强类型语言-VS-弱类型语言" class="headerlink" title="强类型语言 VS 弱类型语言"></a>强类型语言 VS 弱类型语言</h3><blockquote><p>虽然 C 语言是静态，但是在 C 语言中，我们可以把其他类型的数据赋予给一个声明好的变量， 比如在C语言中声明好了两个变量 ： </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = 1;</span><br><span class="line">bool b = true;</span><br><span class="line">b = a;</span><br></pre></td></tr></table></figure><blockquote><p>我们把 int 型的变量 a 赋值给了 bool 型的变量b，这段代码也是可以编译执行的，因为在赋值过程中，C编译器会把 int 型的变量悄悄转换为 bool 型的变量.<br>通常把偷偷进行类型转换的操作成为<code>隐式类型转换</code>：<br>支持因此类型转换的语言称为<code>弱类型语言</code>，不支持隐式类型转换的语言称为<code>强类型语言</code>。</p></blockquote><h3 id="编译型语言-VS-解释型语言"><a href="#编译型语言-VS-解释型语言" class="headerlink" title="编译型语言 VS 解释型语言"></a>编译型语言 VS 解释型语言</h3><blockquote><p>编译型语言代表有：C语言，C++、Object-C以及swift.<br>通常都会对源代码进行编译，生成可以执行的二进制代码，执行的是编译后的结果. </p><p>解释型语言代表有：JavaScript、Python、Erlang、PHP、Perl、Ruby<br>通常不用对源代码进行编译，一般是通过解释器载入脚本后运行。由于每个语句都是执行的时候才进行解释翻译，这样解释性语言每次执行就要翻译一次，效率相对要低。</p><p>Java具有编译与解释两种特性：既可以将其源代码当作脚本执行，也可以进行编译成.class代码（字节码）载入运行.</p><p><a href="https://www.liugezhou.online/2018/12/31/编译型语言与解释型语言的区别/" target="_blank" rel="noopener">拓展–编译型语言与解释型语言的区别–详细介绍</a></p></blockquote><h4 id="盗图"><a href="#盗图" class="headerlink" title="盗图"></a>盗图</h4><blockquote><p><img src="http://img.liugezhou.online/language.jpg" alt="语言类型"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;这篇文章用来彻底区分各种语言概念的区别&quot;&gt;&lt;a href=&quot;#这篇文章用来彻底区分各种语言概念的区别&quot; class=&quot;headerlink&quot; title=&quot;这篇文章用来彻底区分各种语言概念的区别.&quot;&gt;&lt;/a&gt;这篇文章用来彻底区分各种&lt;code&gt;语言&lt;/code&gt;概念的区别.&lt;/h4&gt;
    
    </summary>
    
      <category term="编程概念类" scheme="http://liugezhou.online/categories/%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5%E7%B1%BB/"/>
    
    
      <category term="编程概念类" scheme="http://liugezhou.online/tags/%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>每周分享第十四期</title>
    <link href="http://liugezhou.online/2019/10/13/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC%E5%8D%81%E5%9B%9B%E6%9C%9F/"/>
    <id>http://liugezhou.online/2019/10/13/每周分享第十四期/</id>
    <published>2019-10-13T15:10:00.000Z</published>
    <updated>2019-10-13T15:32:34.377Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这里记录我的周末，强迫自己要去总结点什么的东西。</p></blockquote><a id="more"></a><h4 id="Rocket"><a href="#Rocket" class="headerlink" title="Rocket"></a><a href="https://weibo.com/u/3393510594?refer_flag=1005055013_" target="_blank" rel="noopener">Rocket</a></h4><blockquote><p>“对于此次”火箭经理辱华”事件的各路带哥们，我想说，继续带节奏让事态扩大吧，逞口舌之快只会两败俱伤，双方都是。我们已经忍了一百多年，不就是硬实力掰不过吗？古训讲究一个忍，厚积薄发、一击制胜。</p><p>这个事再发酵下去那就不单单是一个NBA的问题了，现在这个时期就从政治到文化开始全面撕票真的明智？我双手支持我国立场，只是反对极端化发展，戾气太重、无脑热血只会被人利用。</p><p>而且肯定存在其它的解决方法，莫雷、肖华都不能代表整个NBA，换句话说，川普对我国也不友好，那么我们就要跟美帝全面断交？而且现在国人有发表中立缓和意见的，马上会有一批喷子赶来问候同族的家人，这是理智爱国？？”</p><p><cite>引自‘沉默的羔羊’</cite></p></blockquote><h4 id="武汉颁发自动驾驶商用牌照"><a href="#武汉颁发自动驾驶商用牌照" class="headerlink" title="武汉颁发自动驾驶商用牌照"></a><a href="http://www.xinhuanet.com/2019-09/22/c_1125025261.htm" target="_blank" rel="noopener">武汉颁发自动驾驶商用牌照</a></h4><blockquote><p>武汉，简称“汉”，别称江城，是湖北省省会，中部六省唯一的副省级市和特大城市，中国中部地区的中心城市.</p><p>国家智能网联汽车（武汉）测试示范区22日在江城武汉揭牌，百度、海梁科技、深兰科技等企业获得武汉市交通部门颁发的自动驾驶车辆商用牌照.  </p><p>今后，无人驾驶车辆不仅可在开放道路进行载人测试，也可进行商业化运营探索。 </p><p>武汉市交通运输局综合协调处胡浩军表示，在示范区内首期建成的28公里支持智能网联汽车示范应用道路上，此次获牌照的巴士、公交、出租车等，均可上路正常载客运营。“市民上车‘刷卡’后即可乘车，但不实际扣费。”  </p><p>颁发自动驾驶商用牌照的最大意义在于，相关企业可在原有测试基础上，加强测试远程驾驶、车路协同等在5G环境下的新功能，并进行载人试运营，从而推动智能驾驶技术在真实场景下的应用。</p></blockquote><h4 id="呦呦鹿鸣"><a href="#呦呦鹿鸣" class="headerlink" title="呦呦鹿鸣"></a>呦呦鹿鸣</h4><blockquote><p>10月8日媒体报道以来，关于北大附中实验学校教学楼的空气质量问题在北大附中师生和社会一定范围间散播开来，并逐渐演化成为一起舆论事件。 </p><p>公众号《呦呦鹿鸣》，文章还在还可以阅读，但是最近的两篇文章因违反《微信公众号运营规范》，文章被禁止分享。</p></blockquote><h4 id="远方青木"><a href="#远方青木" class="headerlink" title="远方青木"></a>远方青木</h4><blockquote><p>公众号《远方青木》，差不多篇篇文章10万+。 </p><p>前公众号《紫竹张先生》的作者，猜测可能是由于彩票事件，被央视新闻点名，做封号处理。 </p><p>沉寂一段时间后，换了此公众号，文章针对社会热点事件总是有理有据、更具煽动，其文章逻辑分析强行洗脑，学识渊博，会总结会写文。</p><p>可能是在被约谈之后，更明白什么样的文章更具传播性。  </p><p>就像不是没有好记者，只是我们不知道一样–这个世界上有太多的能人，不为我们所知。有的风生水起，有的苟延残喘，有的高风亮节，有的同流合污，然而对于我们多数没见过市面的普通老百姓而言，遵从社会的主流价值观才算我们也有价值观。</p><p><cite>此为揣测。</cite></p></blockquote><h4 id="一句话"><a href="#一句话" class="headerlink" title="一句话"></a>一句话</h4><blockquote><p>一项研究发现，在线课程的完成率只有4%，100个报名网上课程的人，只有4个能坚持学完。</p></blockquote><h4 id="Octotree"><a href="#Octotree" class="headerlink" title="Octotree"></a>Octotree</h4><blockquote><p>Chrome浏览器应用商店上的插件，安装此插件后，在Github仓库下，会对仓库源文件进行目录排版。 </p></blockquote><h4 id="Teamview"><a href="#Teamview" class="headerlink" title="Teamview"></a>Teamview</h4><blockquote><p>APT41 安全组织已经攻破了 TeamViewer 公司，使其能够访问安装了 TeamViewer 的任何系统。<br>所以，简单来说，请卸载你的 TeamViewer 软件.</p></blockquote><h4 id="Vue3-0代码仓库公开"><a href="#Vue3-0代码仓库公开" class="headerlink" title="Vue3.0代码仓库公开"></a><a href="https://github.com/vuejs/vue-next" target="_blank" rel="noopener">Vue3.0代码仓库公开</a></h4><blockquote><p>Vue3.0完全由TypeScript编写，目前处于alpha阶段，计划与2020年第一季度发布。</p><p>最重要的变化之一是，受React Hooks的启发，新的API将允许使用基于函数的方式编写组件。 </p><p><a href="https://mp.weixin.qq.com/s/sOOGQvnRLrgRbz_0TEY93w" target="_blank" rel="noopener">Vue3.0的五个关键变化</a>：速度、体积、可维护性、面向原生、易用性。 </p></blockquote><h4 id="女装大佬项目"><a href="#女装大佬项目" class="headerlink" title="女装大佬项目"></a><a href="https://github.com/komeiji-satori/Dress" target="_blank" rel="noopener">女装大佬项目</a></h4><blockquote><p>表面上是”面向可爱的蓝孩子的Git学习实践项目 on Github”,实际上是让程序员po出自己的女装照片。 </p><p>这个项目全部是男孩穿女装的照片，很辣眼睛。喜欢看男孩穿女装的人儿这回可大饱眼福了。</p></blockquote><h4 id="Postwoman"><a href="#Postwoman" class="headerlink" title="Postwoman"></a><a href="https://github.com/liyasthomas/postwoman" target="_blank" rel="noopener">Postwoman</a></h4><blockquote><p>一个在线 HTTP 请求调试工具，类似 Postman，不过是 Web 版。</p></blockquote><h4 id="前端面试每日3-1"><a href="#前端面试每日3-1" class="headerlink" title="前端面试每日3+1"></a><a href="https://github.com/haizlin/fe-interview" target="_blank" rel="noopener">前端面试每日3+1</a></h4><blockquote><p>前端面试每日 3+1，以面试题来驱动学习，提倡每日学习与思考，每天进步一点！每天早上5点纯手工发布面试题（死磕自己，愉悦大家）。</p></blockquote><h4 id="购房"><a href="#购房" class="headerlink" title="购房"></a><a href="https://github.com/houshanren/hangzhou_house_knowledge" target="_blank" rel="noopener">购房</a></h4><blockquote><p>2017年买房经历总结出来的买房购房知识分享给大家，希望对大家有所帮助。买房不易，且买且珍惜。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这里记录我的周末，强迫自己要去总结点什么的东西。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="每周分享" scheme="http://liugezhou.online/categories/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="每周分享" scheme="http://liugezhou.online/tags/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>每周分享第十三期</title>
    <link href="http://liugezhou.online/2019/09/28/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC%E5%8D%81%E4%B8%89%E6%9C%9F/"/>
    <id>http://liugezhou.online/2019/09/28/每周分享第十三期/</id>
    <published>2019-09-28T10:10:00.000Z</published>
    <updated>2019-09-30T03:30:19.488Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这里记录我的周末，强迫自己要去总结点什么的东西。</p></blockquote><a id="more"></a><h3 id="Brendan-Ecich"><a href="#Brendan-Ecich" class="headerlink" title="Brendan Ecich"></a>Brendan Ecich</h3><blockquote><p>布兰登～艾克，1961年7月4日生人，JavaScript发明人。</p><p>这个哥们上大学时，主修的时物理学，到了大三因人家的兴趣改变主修为计算机科学，后获取了数学与计算机科学学士学位，后来上了个研究生，25岁时获取了计算机科学硕士学位。</p><p>毕业后进入SGI工作，工作七年负责操作系统与网络功能，之后他在MicroUnity工作了三年。1995年4月，任职于网景期间，为网景浏览器开发出JavaScript，之后成为网页浏览器领域应用最广泛的脚本语言之一。1998年，艾克协助成立Mozilla.org，2003年在美国在线决定结束网景部门营运后，艾克协助成立了Mozilla基金会。2014年4月3日，艾克宣布从Mozilla离职，2015年5月28日，艾克成立Brave软件公司，这是一家互联网安全公司，2016年1月20日，该公司发布了Brave网页浏览器。</p></blockquote><blockquote><p>下载了一下Brave网页浏览器，作为一个开发者，第一关注的当然是其开发调试功能，第一感觉是跟谷歌一个模子。</p><p>当前版本是v0.68.142,从网上查阅资料得知，当前 0.xx 版本是基于 electron 开发的，但未来的 1.0 版本将会是基于 chromium 魔改而来。</p><p>这个浏览器据说是想改变web商业模式，目前 Web 基于广告的商业模式有很多问题，Brave 浏览器提出了一个新的思路，就是用户给内容提供者打赏付钱，我这里把它叫做“打赏模式”。</p><p>它的打赏按钮在地址栏的右侧，点击后会有网站的验证是否经Brave网页验证。<br>这个模式很有意思。</p><p>官网地址：<a href="https://brave.com" target="_blank" rel="noopener">https://brave.com</a></p></blockquote><h3 id="长尾理论"><a href="#长尾理论" class="headerlink" title="长尾理论"></a>长尾理论</h3><blockquote><p>1897年，意大利经济学家发现一个经济规律：在任何一组东西中，最重要的只占其中一小部分，约20%，其余80%尽管占多数，却是次要的，这被称为<code>帕累托法则</code>，或者叫二八定律。80%的东西之所以次要，不是因为没有人需要，而是因为发现或呈现它们的成本实在太高了。</p></blockquote><blockquote><p>长尾理论的提出者是：克里斯·安德森。</p><p>安德森开始的一项工程，在考察了所有互联网电商公司的数据后，得出了几乎惊人一致的结论：在互联网世界里，任何商品都能找到它的消费者。  </p><p>由于关注的成本大大降低，人们有可能以很低的成本关注正态分布曲线的“尾部”，而且，关注“尾部”产生的总体效益甚至会超过“头部”. </p><p>在互联网环境下，<code>帕累托法则</code>失灵了，取而代之的是倒二八法则，即所谓的“长尾理论”。这一理论也推导出了一种新的互联网经营模式。</p></blockquote><blockquote><p>在长尾理论一书中，安德森总结了9个法则：</p><ol><li>数字化仓储是降低库存成本的最佳办法；</li><li>挖掘消费者心理数据，让他们参与生产；</li><li>从多个传播渠道挖掘潜在需求，深入长尾的尾部；</li><li>不要试图生产一款适合所有人的商品；</li><li>建立更加灵活的定价策略；</li><li>在企业与顾客之间建立共享信息的机制，达到双赢的效果；</li><li>结合自身产品的特点，考虑产品之间的“和”与“或”的问题；</li><li>借助长尾效应，根据市场自身淘汰结果来做出相应的反应，让市场替你做事；</li><li>重视免费的力量。<br><cite><a href="https://mp.weixin.qq.com/s/zJbXy8GwPJoISkxvLRWf4g" target="_blank" rel="noopener">文章来源</a></cite></li></ol></blockquote><h3 id="Github-Actions"><a href="#Github-Actions" class="headerlink" title="Github Actions"></a>Github Actions</h3><blockquote><p>之前在Github上注册了Actions，但是当时也不知道是干嘛的，今日读到一篇文章,虽然还是有点蒙。<br>在大脑里留个印象，在用到的时候，可以再来了解一下。</p><p><cite><a href="https://mp.weixin.qq.com/s/ILg6Ba7EGeqhDFYfIuo6kg" target="_blank" rel="noopener">玩转GitHub Actions ，简化npm发布流程</a></cite></p></blockquote><h3 id="阮一峰–周分享内容"><a href="#阮一峰–周分享内容" class="headerlink" title="阮一峰–周分享内容"></a>阮一峰–周分享内容</h3><blockquote><h4 id="35岁以后油腻中年人该去哪"><a href="#35岁以后油腻中年人该去哪" class="headerlink" title="35岁以后油腻中年人该去哪"></a><a href="https://mp.weixin.qq.com/s/AXmXQye9_puIFVn_okTEPw" target="_blank" rel="noopener">35岁以后油腻中年人该去哪</a></h4><p>这篇文章挺有意思。</p><h4 id="starcharts"><a href="#starcharts" class="headerlink" title="starcharts"></a><a href="https://github.com/caarlos0/starcharts" target="_blank" rel="noopener">starcharts</a></h4><p>一个开源工具，可以查看 GitHub 仓库的 Star 变化情况，生成折线图。<br>但是比较受欢迎的项目比如Vue、React等，显示：<br>Please try again in a few minutes. This might not work for very famous repository.<br>不过对一些小众，不是太famous的项目，还是可以的。</p><h4 id="showme-bug"><a href="#showme-bug" class="headerlink" title="showme.bug"></a><a href="https://showme.bug" target="_blank" rel="noopener">showme.bug</a></h4><p>一个国产的在线实时编程环境，程序员面试助手，可以实时观看应聘者远程编程。</p><p>作为技术人员，手敲代码的能力毕竟最重要的。随着技术人才的不断年轻化，面试过程的不断考察实力化，像我这种还没学什么就要老了的人，如果不好好在自己的职业技术上下点功夫，混吃等死，那技能只能一步步退化，手里端的这碗饭很是危险啊。</p><h4 id="GK-Docs"><a href="#GK-Docs" class="headerlink" title="GK Docs"></a><a href="http://geekdocs.cn/" target="_blank" rel="noopener">GK Docs</a></h4><p>面向前端开发者的网址导航站。</p></blockquote><h3 id="JS字符串方法"><a href="#JS字符串方法" class="headerlink" title="JS字符串方法"></a>JS字符串方法</h3><blockquote><p>基础知识要牢固，最后来温习一下20个常用的JavaScript字符串方法。<br><cite><a href="https://mp.weixin.qq.com/s/YfO_Cdp6f0WmRt2S2JhCIA" target="_blank" rel="noopener">20个常用的JavaScript字符串方法</a></cite></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这里记录我的周末，强迫自己要去总结点什么的东西。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="每周分享" scheme="http://liugezhou.online/categories/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="每周分享" scheme="http://liugezhou.online/tags/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>浏览器工作原理与实践</title>
    <link href="http://liugezhou.online/2019/09/16/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <id>http://liugezhou.online/2019/09/16/浏览器工作原理与实践/</id>
    <published>2019-09-16T02:15:00.000Z</published>
    <updated>2019-11-15T05:39:03.800Z</updated>
    
    <content type="html"><![CDATA[<h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><h5 id="本文主要是从极客时间专栏《浏览器工作原理与实践》，对其每一章的学习进行系统性总结–总版。"><a href="#本文主要是从极客时间专栏《浏览器工作原理与实践》，对其每一章的学习进行系统性总结–总版。" class="headerlink" title="本文主要是从极客时间专栏《浏览器工作原理与实践》，对其每一章的学习进行系统性总结–总版。"></a>本文主要是从极客时间专栏《浏览器工作原理与实践》，对其每一章的学习进行系统性总结–总版。</h5><hr><a id="more"></a><h3 id="宏观视角下的浏览器-6讲"><a href="#宏观视角下的浏览器-6讲" class="headerlink" title="宏观视角下的浏览器(6讲)"></a>宏观视角下的浏览器(6讲)</h3><h4 id="01-Chrome架构：仅仅打开一个页面，为什么有四个进程"><a href="#01-Chrome架构：仅仅打开一个页面，为什么有四个进程" class="headerlink" title="01.Chrome架构：仅仅打开一个页面，为什么有四个进程"></a>01.Chrome架构：仅仅打开一个页面，为什么有四个进程</h4><hr><blockquote><p>在谷歌浏览器随便打开一个页面，点击“选项”菜单，选择“更多工具”，点击“任务管理器”，这将打开Chrome的任务管理器的窗口，你会发现一个页面上有四个以上的进程。为什么会有四个进程呢？<br>本章通过分析浏览器的进化史而展开探讨这个问题。<br>开始之前，我们必须得了解一下这个<code>进程</code>与<code>线程</code>的概念。  </p></blockquote><h5 id="线程-VS-进程"><a href="#线程-VS-进程" class="headerlink" title="线程 VS 进程"></a>线程 VS 进程</h5><blockquote><p><code>线程这个东西它是不能单独存在的，它是由进程来启动和管理的。</code> </p><p><code>一个进程就是一个程序的运行实例</code>。</p><p><code>线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率</code>。  </p><p>总结，线程与进程之间的关系有以下四个特点：</p><ol><li>进程中任一线程执行出错，都会导致整个进程崩溃。 </li><li>线程之间共享进程的数据。   </li><li>当一个进程关闭之后，操作系统会回收进程所占用的内存。   </li><li>进程之间的内容都互相隔离。(如果进程之间需要进行数据的通信，这时候需要使用用于进程间通讯(IPC)机制了)。</li></ol></blockquote><h5 id="单进程浏览器时代"><a href="#单进程浏览器时代" class="headerlink" title="单进程浏览器时代"></a>单进程浏览器时代</h5><blockquote><p>早在07年之前，市面上的浏览器都是单进程的。单进程，顾名思义是指：浏览器的所有功能模块都运行在同一个进程里。<br>如此多的功能模块运行在一个进程里，导致单进程浏览器<code>不稳定</code>、<code>不流畅</code>、<code>不安全</code>。<br>具体的表现就不说了，总之体验非常差，于是进入了“多线程浏览器”时代。    </p></blockquote><h5 id="多进程浏览器时代"><a href="#多进程浏览器时代" class="headerlink" title="多进程浏览器时代"></a>多进程浏览器时代</h5><blockquote><ul><li>多进程浏览器由于进程相互隔离，所以当一个页面或者插件崩溃的时候，影响的仅仅是当前的页面进程或者插件过程。这就完美解决了页面或者插件崩溃而导致的整个浏览器崩溃问题。JS的渲染若出现问题，影响的同样是当前的渲染页面，没有响应的仅对当前页面。而且在多进程浏览器时代，当关闭一个页面的时候，整个渲染进程会被关闭，该进程占用的内存都会被系统回收，这样也就轻松解决了浏览器页面的内存泄露问题。    </li><li>此外有关安全方面的问题：使用多线程架构可以使用<code>安全沙箱</code>。  </li></ul><p>可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在硬盘上写入任何数据，也不能在敏感位置读取任何数据(例如文档和桌面)，Chrome把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。</p></blockquote><h5 id="目前多进程架构"><a href="#目前多进程架构" class="headerlink" title="目前多进程架构"></a>目前多进程架构</h5><blockquote><p>最新的Chrome进程架构：Chrome浏览器包括：<code>1个浏览器(Brower)主进程，1个GPU进程、一个网络(NetWork)进程、多个渲染进程和多个插件进程</code>。<br>虽然多进程模型提升了浏览器的稳定性、流畅性、安全性，但是同样也会不可避免带来一些问题：  </p><ul><li><code>更高的资源占用</code> ：因为每个进程都会包含公共基础结构的副本（如JavaScript运行环境），这意味着浏览器会消耗更多的资源。  </li><li><code>更复杂的体系架构</code>：浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求。 </li></ul></blockquote><h5 id="未来面向服务的架构-SOP"><a href="#未来面向服务的架构-SOP" class="headerlink" title="未来面向服务的架构(SOP)"></a>未来面向服务的架构(SOP)</h5><blockquote><p>为了解决这些问题，2016年，Chrome团队使用“面向服务的架构“（SOP）思想设计了新的Chrome架构，这也是现阶段Chrome团队的一个主要任务。</p></blockquote><h4 id="02｜TCP协议：如何保证页面文件能被完整的送达浏览器"><a href="#02｜TCP协议：如何保证页面文件能被完整的送达浏览器" class="headerlink" title="02｜TCP协议：如何保证页面文件能被完整的送达浏览器"></a>02｜TCP协议：如何保证页面文件能被完整的送达浏览器</h4><hr><blockquote><p>在衡量Web页面性能的时候有一个重要的指标叫”FP(First Paint)”,是指从页面加载到首次开始绘制的时长。其中影响FP的一个重要因素就是<code>网络加载速度</code>。 </p><p>要优化网络加载速度，需要对网络有充分的了解，这一节重点介绍<code>在Web世界中的TCP/IP是如何工作的</code>。 </p><p>在网络中，一个文件通常会被拆分为很多数据包来进行传输，而数据包在传输过程中有很大概览丢失或者出错，那么如何保证页面文件能被完整地送达浏览器？</p></blockquote><h5 id="一个数据包的“旅程”"><a href="#一个数据包的“旅程”" class="headerlink" title="一个数据包的“旅程”"></a>一个数据包的“旅程”</h5><blockquote><ol><li><p>IP:把数据包送达目的主机<br>计算机的地址称为IP地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。<br>当从主机A向主机B发送数据(即发送数据包)，传输前，数据包会被附加上主机A和主机B的IP地址信息，这些信息会被封到一个叫做IP头的数据结构里，在这个IP头中包含IP数据包开头的信息(IP版本、源IP地址、目标地址、生存时间等信息)，于是数据包从主机A发送到主机B。  </p></li><li><p>UDP:把数据包送达应用程序<br>IP通过IP地址信息把数据包发送给指定的电脑，而UDP通过端口号把数据包发给正确的程序。<br>UDP发送数据，有各种因素会导致数据包出错，虽然UDP可以校验数据是否正确，但是<code>UDP不提供重发机制</code>，只是丢弃当前的包，且UDP在发送之后无法知道能否到达目的地。<br><code>UDP不能保证数据可靠性，但是传输速度却非常快</code>，因此UDP应用在一些关注速度但不那么严格要求数据完整性的领域，例如：在线视频、互动游戏等。  </p></li><li><p>TCP:把数据完整的送达应用程序<br>TCP(Transmission Control Protocol,传输控制协议)：他是一种面向连接的、可靠的、基于字节流的传输层通信协议。相对于UDP而言：  </p></li></ol><ul><li>对于数据包丢失情况，提供重传机制。  </li><li>TCP引入数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。 </li></ul></blockquote><h5 id="完整的TCP连接过程"><a href="#完整的TCP连接过程" class="headerlink" title="完整的TCP连接过程"></a>完整的TCP连接过程</h5><blockquote><p>我们现在已经知道TCP单个数据包的传输流程和UDP流程差不多，不同在于，通过TCP头信息可以保证一块大的数据传输的完整性。<br>一个完整的TCP连接过程，其生命周期包括了“建立连接“、”数据传输“、”断开连接“三个阶段。</p><ul><li>建立连接阶段：这个阶段通过“三次握手”来建立客户端和服务器之间的连接。  </li><li>数据传输阶段：在该阶段，接收端需要对每个数据包进行确认操作。接收端应该在接收数据后要发送确认数据包给发送端，若发送端没有接收到这个确认，则判断数据包丢失，并触发发送端的重发机制。  </li><li>断开连接阶段：数据传输完毕，终止连接，通过最后一个阶段“四次挥手”来保证双方都能断开连接。</li></ul></blockquote><h4 id="03｜HTTP请求流程：为什么很多站点第二次打开速度会很快？"><a href="#03｜HTTP请求流程：为什么很多站点第二次打开速度会很快？" class="headerlink" title="03｜HTTP请求流程：为什么很多站点第二次打开速度会很快？"></a>03｜HTTP请求流程：为什么很多站点第二次打开速度会很快？</h4><hr><blockquote><p>首先的首先我们知道：HTTP协议建立在TCP连接基础之上的。<code>HTTP是一种允许浏览器向服务器获取资源的协议，是Web的基础。HTTP是浏览器使用最广的协议</code>。</p><p>简单说说HTTP和TCP的关系：浏览器使用HTTP协议作为<code>应用层协议</code>，用来封装请求的文本信息，并使用TCP/IP作为<code>传输层协议</code>将它发到网路上,所以HTTP工作前，需要通过TCP与服务器建立连接，也就是说：<code>HTTP的内容是通过TCP的传输数据阶段来实现的</code>。</p></blockquote><h5 id="浏览器端发起HTTP请求流程"><a href="#浏览器端发起HTTP请求流程" class="headerlink" title="浏览器端发起HTTP请求流程"></a>浏览器端发起HTTP请求流程</h5><blockquote><p>如果在浏览器地址栏里输入：<a href="https://www.liugezhou.online" target="_blank" rel="noopener">https://www.liugezhou.online</a> 这个网址后,浏览器这个庞然大物，它的背后都做些什么呢？</p></blockquote><ul><li>构建请求<blockquote><p>首先浏览器构建请求行信息，构建好之后，浏览器准备发起网路请求。</p></blockquote></li><li>查找缓存<blockquote><p>在准备发起网路请求阶段，浏览器偷偷的在它的缓存中查询是否有要请求的资源。<br>若有：拦截请求，返回资源副本，直接结束请求。<br>若缓存查找失败：继续下一步。  </p></blockquote></li><li>准备IP地址和端口号<blockquote><p>这个IP地址和端口号的获取，肯定是通过域名与其映射，即“域名系统”，也就是我们熟知的DNS。<br>于是，浏览器第一步会请求DNS返回域名对应的IP，如果没有特别指明端口号，则默认为80。<br>(浏览器提供了DNS数据缓存服务，若缓存过也就不会去请求，直接解析。从而减少一次网络请求)</p></blockquote></li><li>等待TCP队列<blockquote><p>拿到IP地址与端口号后，还需要在TCP队列中排队才能建立TCP连接。<br>这是因为：Chrome有个机制，同一个域名同时最多只能建立6个TCP连接，若此刻同时有10个请求发生。则四个会进入TCP队列进行排队。<br>当然，若当前请求数量少于6个，则会直接进入下一步。 </p></blockquote></li><li>建立TCP连接 <blockquote><p>建立TCP连接，上一节我们已经知道，一个完整的TCP连接过程包括“建立连接”、“数据传输”、“断开连接“三个阶段。  </p></blockquote></li><li>发送HTTP请求<blockquote><p>HTTP请求是在TCP连接的数据传输阶段工作的，这个时候浏览器向服务器发送请求行，它包括请求方法、请求URI、HTTP版本协议。，HTTP中的数据在这个通信过程中传输。</p></blockquote></li></ul><h5 id="服务器端处理HTTP请求流程"><a href="#服务器端处理HTTP请求流程" class="headerlink" title="服务器端处理HTTP请求流程"></a>服务器端处理HTTP请求流程</h5><blockquote><p>这里可以在命令行中输入<code>curl -i https://www.google.com</code>来查看返回请求数据。 (-i 返回响应行、响应头和响应体信息。 -I 不返回响应体。)<br>返回网站的HTTP协议、Connection、Location、Cache-Control等信息。 </p><p>通常情况，一旦服务器向客户端返回了请求数据，它就要关闭TCP连接，但是如果浏览器或者服务器设置了<code>Connection:keep-alive</code>，那么TCP连接在发送后将仍保持打开状态。<code>保持TCP连接可以省去下次请求时需要建立连接的时间，提升资源加载速度</code>。</p></blockquote><h5 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h5><ol><li>为什么很多站点第二次打开速度会很快？<blockquote><p>主要原因肯定是第一次加载页面的过程中，缓存了一些数据(从上面的过程分析，我们知道<code>DNS缓存</code>和<code>页面资源缓存</code>这两块数据是会被浏览器缓存起来的).<br>网站把很多资源都缓存到了本地，浏览器缓存直接使用本地副本来回应请求，而不会产生真实的网络请求，从而节省了时间。</p></blockquote></li><li>登录状态是如何保持的 <blockquote><p>简单地说，如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保持到本地。当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。</p></blockquote></li></ol><h4 id="04｜导航流程：从输入URl到页面展示，这中间发生了什么"><a href="#04｜导航流程：从输入URl到页面展示，这中间发生了什么" class="headerlink" title="04｜导航流程：从输入URl到页面展示，这中间发生了什么"></a>04｜导航流程：从输入URl到页面展示，这中间发生了什么</h4><hr><blockquote><p>流程开始前，回顾下浏览器进程、网络进程、渲染进程的各自主要职责：  </p><ul><li>浏览器进程：主要负责<code>用户交互</code>、<code>子进程管理</code>和<code>文件储存</code>等功能。  </li><li>网络进程：面向渲染进程或浏览器进程提供<code>网络资源下载</code>。  </li><li>渲染进程：将HTML、CSS、JS、图片等资源解析为可以显示和交互的页面。 </li></ul></blockquote><h5 id="过程大致描述"><a href="#过程大致描述" class="headerlink" title="过程大致描述"></a>过程大致描述</h5><blockquote><ul><li>首先，用户从浏览器进程中输入请求信息。  </li><li>然后，网络进程发起URL请求。 </li><li>服务器响应URL请求后，浏览器进程开始准备渲染进程。 </li><li>渲染进程准备好以后，需要先向渲染进程提交页面数据，这称之为文档提交阶段。  </li><li>渲染进程接收到文档信息之后，便开始解析页面和加载子资源，完成页面的渲染。<br>这其中，用户发出URL请求到页面开始解析的过程，就叫做导航。</li></ul></blockquote><h5 id="从输入URL到页面展示–过程细节"><a href="#从输入URL到页面展示–过程细节" class="headerlink" title="从输入URL到页面展示–过程细节"></a>从输入URL到页面展示–过程细节</h5><blockquote><ul><li>响应数据类型处理：根据服务端返回的<code>Content-Type</code>字段来决定如何显示响应体的内容。</li><li>同一站点下的多个页面会运行在一个渲染进程中。</li></ul></blockquote><h5 id="“从输入-URL-到页面展示，这中间发生了什么？”-留言总结"><a href="#“从输入-URL-到页面展示，这中间发生了什么？”-留言总结" class="headerlink" title="“从输入 URL 到页面展示，这中间发生了什么？”(留言总结)"></a>“从输入 URL 到页面展示，这中间发生了什么？”(留言总结)</h5><blockquote><ol><li>用户输入url并回车·</li><li>浏览器进程检查url，组装协议，构成完整的url</li><li>浏览器进程通过进程间通信（IPC）把url请求发送给网络进程</li><li>网络进程接收到url请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程</li><li>如果没有，网络进程向web服务器发起http请求（网络请求），请求流程如下：<br>5.1 进行DNS解析，获取服务器ip地址，端口<br>5.2 利用ip地址和服务器建立tcp连接<br>5.3 构建请求头信息<br>5.4 发送请求头信息<br>5.5 服务器响应后，网络进程接收响应头和响应信息，并解析响应内容</li><li>网络进程解析响应流程；<br>6.1 检查状态码，如果是301/302，则需要重定向，从Location自动中读取地址，重新进行第4步<br>6.2 200响应处理： <pre><code>检查响应类型Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行后续的渲染，如果是html则通知浏览器进程准备渲染进程准备进行渲染。</code></pre></li><li>准备渲染进程<br>7.1 浏览器进程检查当前url是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程</li><li>传输数据、更新状态<br>8.1 渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”<br>8.2 渲染进程接收完数据后，向浏览器发送“确认提交”<br>8.3 浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏url、前进后退的历史状态、更新web页面。</li></ol></blockquote><h4 id="05｜渲染流程-上-：HTML、CSS和JavaScript，是如何变成页面的"><a href="#05｜渲染流程-上-：HTML、CSS和JavaScript，是如何变成页面的" class="headerlink" title="05｜渲染流程(上)：HTML、CSS和JavaScript，是如何变成页面的"></a>05｜渲染流程(上)：HTML、CSS和JavaScript，是如何变成页面的</h4><hr><blockquote><p>按照渲染的时间顺序，渲染流水线可分为以下几个构建阶段：<br><code>构建DOM树</code>、<code>样式计算</code>、<code>布局阶段</code>、<code>分层</code>、<code>绘制</code>、<code>光栅化</code>、<code>合成</code>。<br>本节主要讨论前三个阶段。  </p></blockquote><h5 id="构建DOM树"><a href="#构建DOM树" class="headerlink" title="构建DOM树"></a>构建DOM树</h5><blockquote><p>因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。<br>DOM树和HTML内容几乎一样，但和HTML不同的是：DOM是保存在内存中的树结构。  </p></blockquote><h5 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h5><blockquote><ol><li>把CSS转换为浏览器能够理解的结构。</li><li>转换样式表中的属性值，使其标准化。<br>「例如rem -&gt; px, red -&gt; rgb(255,0,0),bold -&gt; 700」  </li><li>计算出DOM树中每个节点的具体样式。<br>「CSS继承：每个DOM节点都包含有父节点的样式」<br>「CSS层叠：它在 CSS 处于核心地位，定义了如何合并来自多个源的属性值的算法」<br>「样式来源：如果一个元素不提供任何样式，默认使用的是UserAgent样式—浏览器提供的一组默认样式」。</li></ol></blockquote><h5 id="布局阶段"><a href="#布局阶段" class="headerlink" title="布局阶段"></a>布局阶段</h5><blockquote><p>内容： 布局阶段是根据DOM树和样式计算出元素的几何位置。 </p><ol><li>创建布局树「构建一颗只包含可见元素的布局树」  </li><li>布局计算 </li></ol></blockquote><blockquote><p>「在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 <code>LayoutNG</code>，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。」</p></blockquote><h4 id="06-渲染流程-下-：HTML、CSS和JavaScript，是如何变成页面的"><a href="#06-渲染流程-下-：HTML、CSS和JavaScript，是如何变成页面的" class="headerlink" title="06|渲染流程(下)：HTML、CSS和JavaScript，是如何变成页面的"></a>06|渲染流程(下)：HTML、CSS和JavaScript，是如何变成页面的</h4><hr><h5 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h5><blockquote><p>为了生成一些复杂效果(3D变换、页面滚动、z轴排序等)，渲染引擎还需要为特定的节点生成专用的图层，生成一颗对应的图层树.</p><ul><li>并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层.   </li><li>素有了层叠上下文的属性或者需要被剪裁，满足这任意一点，就会被提升成为单独一层。  </li></ul></blockquote><h5 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h5><blockquote><p>一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个<code>待绘制列表</code>。「可在浏览器开发者工具的Layers中查看。」</p></blockquote><h5 id="栅格化操作"><a href="#栅格化操作" class="headerlink" title="栅格化操作"></a>栅格化操作</h5><blockquote><p>所谓栅格化，是指将图块转换为位图。<br>栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中. </p></blockquote><h5 id="合成和显示"><a href="#合成和显示" class="headerlink" title="合成和显示"></a>合成和显示</h5><blockquote><p>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。经过浏览器就会显示出页面。  </p></blockquote><blockquote><p>一个完整的渲染流程大致可总结为如下：  </p><ul><li>渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。 </li><li>渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。  </li><li>创建布局树，并计算元素的布局信息。对布局树进行分层，并生成分层树。  </li><li>为每个图层生成绘制列表，并将其提交到合成线程。  </li><li>合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。  </li><li>合成线程发送绘制图块命令 DrawQuad 给浏览器进程。浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。</li></ul></blockquote><h5 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h5><h6 id="重排-更新了元素的几何属性"><a href="#重排-更新了元素的几何属性" class="headerlink" title="重排(更新了元素的几何属性)"></a>重排(更新了元素的几何属性)</h6><blockquote><p>使用CSS或者JS使元素的几何位置发生了改变，例如改变元素的宽度、高度等，这会使得浏览器触发重新布局、解析之后的一系列子阶段，这个过程就是重排。无疑，重排需要更新完整的渲染流水线，所以开销是最大的。 </p></blockquote><h6 id="重绘-更新元素的绘制属性"><a href="#重绘-更新元素的绘制属性" class="headerlink" title="重绘(更新元素的绘制属性)"></a>重绘(更新元素的绘制属性)</h6><blockquote><p>比如改变了元素的背景色，这会触发浏览器进行重绘之后的操作。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。  </p></blockquote><h6 id="直接合成阶段"><a href="#直接合成阶段" class="headerlink" title="直接合成阶段"></a>直接合成阶段</h6><blockquote><p>那如果你更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成.<br>例如CSS的transform实现的动画效果，可以避开重排和重绘阶段，相对于重绘和重排，合成能大大提升绘制效率。</p></blockquote><h3 id="浏览器中的JavaScript执行机制-5讲"><a href="#浏览器中的JavaScript执行机制-5讲" class="headerlink" title="浏览器中的JavaScript执行机制 (5讲)"></a>浏览器中的JavaScript执行机制 (5讲)</h3><h4 id="07｜变量提升：JavaScript代码是按顺序执行的吗？"><a href="#07｜变量提升：JavaScript代码是按顺序执行的吗？" class="headerlink" title="07｜变量提升：JavaScript代码是按顺序执行的吗？"></a>07｜变量提升：JavaScript代码是按顺序执行的吗？</h4><hr><blockquote><p>本节主要讲解<code>执行上下文</code>相关的内容。</p></blockquote><blockquote><p>通过一些代码的执行顺序与经验我们知道：    </p><ul><li>在执行过程中，若使用了未声明的变量，那么 JavaScript 执行会报错。    </li><li>在一个变量定义之前使用它，不会出错，但是该变量的值会为 undefined，而不是定义时的值。    </li><li>在一个函数定义之前使用它，不会出错，且函数能正确执行。</li></ul></blockquote><h5 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h5><blockquote><p>所谓的变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined.<br>之所以会发生变量提升，是因为一段JavaScript代码在执行之前，需要被JavaScript引擎编译，编译完成之后，才会进入执行阶段。也就是说在编译阶段，变量和函数的声明提升到了开头。    </p></blockquote><h4 id="08-｜调用栈：为什么JavaScript代码会出现栈溢出？"><a href="#08-｜调用栈：为什么JavaScript代码会出现栈溢出？" class="headerlink" title="08 ｜调用栈：为什么JavaScript代码会出现栈溢出？"></a>08 ｜调用栈：为什么JavaScript代码会出现栈溢出？</h4><hr><blockquote><p>一般有三种情况，当一段代码执行的时候JS引擎对其进行编译并创建执行上下文：</p><ol><li>当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份.  </li><li>当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。   </li><li>当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。</li></ol></blockquote><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><blockquote><ul><li>每调用一个函数，JavaScript 引擎会为其创建执行上下文，并把该执行上下文压入调用栈，然后 JavaScript 引擎开始执行函数代码。 </li><li>如果在一个函数 A 中调用了另外一个函数 B，那么 JavaScript 引擎会为 B 函数创建执行上下文，并将 B 函数的执行上下文压入栈顶。   </li><li>当前函数执行完毕后，JavaScript 引擎会将该函数的执行上下文弹出栈。   </li><li>当分配的调用栈空间被占满时，会引发“堆栈溢出”问题。</li></ul></blockquote><h4 id="09-块级作用域：var缺陷以及为什么要引入let和const"><a href="#09-块级作用域：var缺陷以及为什么要引入let和const" class="headerlink" title="09 | 块级作用域：var缺陷以及为什么要引入let和const"></a>09 | 块级作用域：var缺陷以及为什么要引入let和const</h4><hr><h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><blockquote><p>作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。<br>ES6出现之前，JS的作用域只有两种：<code>全局作用域</code>和<code>函数作用域</code>。 ES6出现，引入了<code>块级作用域</code>。</p></blockquote><h5 id="在同一段代码中，ES6-是如何做到既要支持变量提升的特性，又要支持块级作用域的呢？"><a href="#在同一段代码中，ES6-是如何做到既要支持变量提升的特性，又要支持块级作用域的呢？" class="headerlink" title="在同一段代码中，ES6 是如何做到既要支持变量提升的特性，又要支持块级作用域的呢？"></a>在同一段代码中，ES6 是如何做到既要支持变量提升的特性，又要支持块级作用域的呢？</h5><blockquote><p>当一段代码里面既有var声明的变量也有let声明的变量的时候：  </p><ul><li>函数内部通过var声明的变量，在编译阶段全都被存放到<code>变量环境</code>里面.  </li><li>通过let声明的变量，在编译阶段会被存放到<code>词法环境</code>中。 </li><li>在函数作用域内部，通过let声明的变量并没有被存放到词法环境中。<br>也就是说：通过理解词法环境的结构和工作机制，块级作用域是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现的，通过两者的结合，JavaScript引擎也就同时支持了变量 提升和块级作用域了。</li></ul></blockquote><h4 id="10-｜-作用域和闭包：代码中出现相同的变量，JavaScript引擎是如何选择的"><a href="#10-｜-作用域和闭包：代码中出现相同的变量，JavaScript引擎是如何选择的" class="headerlink" title="10 ｜ 作用域和闭包：代码中出现相同的变量，JavaScript引擎是如何选择的"></a>10 ｜ 作用域和闭包：代码中出现相同的变量，JavaScript引擎是如何选择的</h4><hr><h5 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h5><blockquote><p>理解作用域链是理解闭包的基础，而闭包在JavaScript中无处不在，同时作用域和作用域链还是作用语言的基础，所以我们先来学习一下<code>作用域链</code>。<br>理解了调用栈、执行上下文、词法环境、变量环境等概念，那么你理解起来作用域链也会很容易,看下面一段代码：</p><pre><code>function bar() {   console.log(myName)}function foo() {   var myName = &quot;局部变量&quot;   bar()}var myName = &quot;全局变量&quot;foo()</code></pre><p>通过上面的代码，我们知道最终打印出来的结果是：”全局变量“。<br>这是因为，当一段代码使用了一个变量后，JavaScript引擎会首先在“当前的执行上下文”中去查找该变量。若没有找到，由于每个执行上下文都包含一个外部引用指向外部执行上下文，所以bar函数中的变量会去全局上下文中区域查找。我们把这个查找的链条就称为作用域链。</p></blockquote><h5 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h5><blockquote><p>foo 函数调用的 bar 函数，那为什么 bar 函数的外部引用是全局执行上下文，而不是 foo 函数的执行上下文？了解这个问题我们继续来学习词法作用域：<br>词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。<br>然后，根据词法作用域，foo 和 bar 的上级作用域都是全局作用域，所以如果 foo 或者 bar 函数使用了一个它们没有定义的变量，那么它们会到全局作用域去查找。也就是说，词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系。</p></blockquote><h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><blockquote><p>在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。<br>在使用闭包的时候，要尽量注意一个原则：如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。</p></blockquote><h4 id="11-｜-this：从JavaScript执行上下文的视角讲清楚this"><a href="#11-｜-this：从JavaScript执行上下文的视角讲清楚this" class="headerlink" title="11 ｜ this：从JavaScript执行上下文的视角讲清楚this"></a>11 ｜ this：从JavaScript执行上下文的视角讲清楚this</h4><hr><blockquote><p>首先我们要知道，在对象内部的方法中使用对象内部的属性是一个非常普遍的需求，但是JavaScript作用域机制并不支持这一点，基于这个需求，JavaScript搞出了一套this机制。    </p></blockquote><blockquote><p>在前几节中，我们提到执行上下文中包含了：<code>变量环境</code>、<code>词法环境</code>、<code>外部环境</code>、还有一个没有提及的<code>this</code>,this是和执行上下文绑定的，每个执行上下文都有一个this。<br>在08节我们总结了执行上下文主要分三种：全局执行上下文、函数执行上下文和eval执行上下文。<br>对应的this也只有这三种：全局执行上下文中的this、函数执行上下中的this和eval中的this(不做讨论)。    </p><ul><li>全局执行上下文中的this：全局执行上下文中的this指向window对象。  </li><li>函数执行上下文中的this：<ol><li>默认情况下调用一个函数，其执行上下文中的 this 也是指向 window 对象的.  </li><li>通过函数的call方法设置其this指向其他对象（还可以使用bind和apply方法来设置函数执行上下文中的this）。   </li><li>通过对象调用方法设置。（使用对象来调用其内部的一个方法，该方法的 this 是指向对象本身的。在全局环境中调用一个函数，函数内部的this指向的是全局变量window）。   </li><li>通过构造函数中设置。   </li></ol></li></ul></blockquote><h5 id="this的设计缺陷以及应对方案"><a href="#this的设计缺陷以及应对方案" class="headerlink" title="this的设计缺陷以及应对方案"></a>this的设计缺陷以及应对方案</h5><blockquote><ol><li>嵌套函数的this不会从外层函数中继承。==&gt;  1⃣️、将this保存一个self变量，利用变量作用域机制传递给嵌套函数。2⃣️、将乔套函数改为箭头函数。   </li><li>普通函数中的this默认指向全局对象window。==&gt;可以通过设置JavaScript的“严格模式”来解决。</li></ol></blockquote><h3 id="V8工作原理-3讲"><a href="#V8工作原理-3讲" class="headerlink" title="V8工作原理(3讲)"></a>V8工作原理(3讲)</h3><hr><h4 id="12-栈空间和堆空间：数据是如何存储的？"><a href="#12-栈空间和堆空间：数据是如何存储的？" class="headerlink" title="12 | 栈空间和堆空间：数据是如何存储的？"></a>12 | 栈空间和堆空间：数据是如何存储的？</h4><blockquote><p>我们把这种在使用之前就需要确认其变量数据类型的称为<code>静态语言</code>。<br>相反地，我们把在运行过程中需要检查数据类型的语言称为<code>动态语言</code>。</p></blockquote><blockquote><p>通常把偷偷转换的操作成为隐式类型转换：支持因此类型转换的语言称为<code>弱类型语言</code>，不支持隐式类型转换的语言称为<code>强类语言</code>。</p></blockquote><blockquote><p>原始数据类型的值都是直接保存在“栈”中，引用数据类型的值是存放在“堆”中的。</p></blockquote><h4 id="13-垃圾回收：垃圾数据是如何自动回收的？"><a href="#13-垃圾回收：垃圾数据是如何自动回收的？" class="headerlink" title="13 | 垃圾回收：垃圾数据是如何自动回收的？"></a>13 | 垃圾回收：垃圾数据是如何自动回收的？</h4><hr><blockquote><p>通常情况下：垃圾数据回收分为<code>手动回收</code>和<code>自动回收</code>两种策略。</p><p>JavaScript、Java、Python 等语言，产生的垃圾数据是由垃圾回收期来释放的，并不需要手动通过代码来释放。</p></blockquote><h5 id="调用栈中的数据是如何回收的"><a href="#调用栈中的数据是如何回收的" class="headerlink" title="调用栈中的数据是如何回收的"></a>调用栈中的数据是如何回收的</h5><blockquote><p>在调用栈中，有一个记录当前执行状态的指针(称为ESP),当一个函数执行结束之后，JavaScript引擎会通过向下移动ESP来销毁该函数保存在栈中的执行上下文。</p></blockquote><h5 id="堆中的数据是如何回收的"><a href="#堆中的数据是如何回收的" class="headerlink" title="堆中的数据是如何回收的"></a>堆中的数据是如何回收的</h5><blockquote><p>堆中的数据是如何回收的—-回收堆中的垃圾数据，需要用到JavaScript中的<code>垃圾回收期</code>。</p><p><b>前置知识点：代际假说的两个特点：</b>(代际假说时垃圾回收领域一个重要的术语)  </p><ul><li>第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问。  </li><li>第二个是不死的对象，会活的更久。</li></ul><p>有了代际假说基础，我们便可以探讨V8是如何实现垃圾回收的了：<br>在V8中会把堆分为<code>新生代</code>和<code>老生代</code>两个区域，新生代存放的是<code>生存时间极短的对象</code>，老生代中存放的是<code>生存时间久的对象</code>。</p><ul><li>副垃圾回收器，主要负责新生代的垃圾回收。</li><li>主垃圾回收期，主要负责老生代的垃圾回收。</li></ul><p>接下来我们开始分析<b>垃圾回收期的工作流程</b><br>V8把堆分成了两个区域，并分别使用不同的垃圾回收期，但不论什么类型回收期，他们使用的是一套共同的执行流程。 </p></blockquote><h5 id="副垃圾回收器"><a href="#副垃圾回收器" class="headerlink" title="副垃圾回收器"></a>副垃圾回收器</h5><blockquote><p>新生代中用Scavenge算法来处理：即把新生代空间对半划分为两个区域：一半是<code>对象区域</code>，一半是<code>空闲区域</code>。<br>对象区域与回收区域会经过反复的角色翻转操作。<br>JavaScipt引擎采用了对象晋升策略，也就是经过两次垃圾回收仍然存活的对象，会被移动到老生区中。</p></blockquote><h5 id="主垃圾回收器"><a href="#主垃圾回收器" class="headerlink" title="主垃圾回收器"></a>主垃圾回收器</h5><blockquote><p>主要负责老生区中的垃圾回收，老生区中的对象有两个特点：一个是对象占用空间大，一个是对象存活时间长。<br>采用标记-清除(Mark-Sweep)的算法进行垃圾回收。<br>由于碎片过多而导致大对象无法分配到足够的连续内存，于是又产生来另外一种算法–标记-整理(Mark-Compact)。 </p><p>全停顿：为了降低老生代的垃圾回收而造成的卡顿，V8将标记过程分为一个个的子标记过程，同时让垃圾回收标记和JavaScript应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记(Incremental Marking)算法。</p></blockquote><h4 id="14-编译器和解释器：V8是如何执行一段JavaScript代码的？"><a href="#14-编译器和解释器：V8是如何执行一段JavaScript代码的？" class="headerlink" title="14 | 编译器和解释器：V8是如何执行一段JavaScript代码的？"></a>14 | 编译器和解释器：V8是如何执行一段JavaScript代码的？</h4><hr><blockquote><p>了解V8的编译流程能让你对语言以及相关工具有更充分的认识。<br>深入理解V8的工作原理，这里我们需要搞清楚一些概念和原理：<code>编译器(Compiler)</code>、<code>解释器(Interpreter)</code>、<code>抽象语法树(AST)</code>、<code>字节码(Bytecode)</code>、<code>即时编译器(JIT)</code>等概念。</p></blockquote><h5 id="编译器和解释器"><a href="#编译器和解释器" class="headerlink" title="编译器和解释器"></a>编译器和解释器</h5><blockquote><p>按语言的执行流程，可以把语言划分为编译型语言和解释型语言。<br><code>编译型语言</code>在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。<br>而由<code>解释型语言</code>编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行。</p></blockquote><h5 id="V8时如何执行一段JavaScript代码的"><a href="#V8时如何执行一段JavaScript代码的" class="headerlink" title="V8时如何执行一段JavaScript代码的"></a>V8时如何执行一段JavaScript代码的</h5><blockquote><p>V8在执行过程中既有解释器Ignition，也有编译器TurboFan.下面分解其执行流程：  </p><ol><li>生成抽象<code>语法树(AST)</code>和执行上下文。<br>AST的结构和代码的结构非常相似。因此可以把AST看成代码的结构化表示，编译器和解释器后续的工作都需要依赖于AST,而不是源代码。<br>抽象语法树(AST)的应用：Babel、ESLint。  </li></ol><p>生成AST需要经过两个阶段：第一阶段是分词(tokenize)，又称为词法分析。第二个阶段是解析(parse)，又称为语法分析。<br>这就是 AST 的生成过程，先分词，再解析。<br>有了AST后，接下来V8就会生成该代码的执行上下文。</p><ol start="2"><li><p>生成<code>字节码</code><br>第一步的AST和执行上下文搞定后，下一步就是解释器登场，根据AST生成字节码，并解释执行字节码。<br>说到字节码，其实一开始的时候V8是没有字节码的，而是直接将AST转换为机器码。但是随着Chrome在手机上普及，内存占用问题暴露出来了（这是因为V8需要消耗大量的内存在存放转换后的机器码）。因此为了解决内存占用问题，引入来字节码。</p><p><b>字节码就是介于AST和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。</b></p></li><li><p>执行代码<br>通常，如果有一段第一次执行的字节码，解释器 Ignition会逐条解释执行，若发现有热点代码，那么编译器TurboFan就会把该段热点的字节码编译为高效的机器码，再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了。<br>我们把这种技术称为<code>即时编译(JIT)</code>。</p></li></ol></blockquote><h5 id="JavaScript的性能优化"><a href="#JavaScript的性能优化" class="headerlink" title="JavaScript的性能优化"></a>JavaScript的性能优化</h5><blockquote><p>在过去几年中，JavaScript的性能得到了大幅提升，这得益于V8团队对解释器和编译器的不断改进和优化。<br>应该将优化的中心聚焦在单次脚本的执行时间和脚本的网络下载上，主要关注以下三点内容：  </p><ul><li>提升单次脚本执行速度 。 </li><li>避免大的内联脚本 。 </li><li>减少JavScript文件容量。  </li></ul></blockquote><h3 id="浏览器中的页面循环系统-5讲"><a href="#浏览器中的页面循环系统-5讲" class="headerlink" title="浏览器中的页面循环系统(5讲)"></a>浏览器中的页面循环系统(5讲)</h3><h4 id="15-消息队列和事件循环：页面上怎么“活”起来的？"><a href="#15-消息队列和事件循环：页面上怎么“活”起来的？" class="headerlink" title="15 | 消息队列和事件循环：页面上怎么“活”起来的？"></a>15 | 消息队列和事件循环：页面上怎么“活”起来的？</h4><hr><blockquote><p>浏览器页面是由消息队列和事件循环系统来驱动的。</p></blockquote><blockquote><p>如果把一个渲染进程比作一个国家，在线程世界里，我们将主线程比作一个总统。总统公务如此繁忙，当然需要一些得力大臣来帮助统筹调度等，我们这里要说的得力大臣就是要学习的<code>消息队列</code>和<code>事件循环系统</code>.  </p></blockquote><h5 id="在线程运行中处理新任务"><a href="#在线程运行中处理新任务" class="headerlink" title="在线程运行中处理新任务"></a>在线程运行中处理新任务</h5><blockquote><p>要想在线程运行过程中，能接受并执行新的任务，就需要采用事件循环机制。</p></blockquote><h5 id="处理其它线程发送过来的任务"><a href="#处理其它线程发送过来的任务" class="headerlink" title="处理其它线程发送过来的任务"></a>处理其它线程发送过来的任务</h5><blockquote><p>处理其它线程发送过来的任务通用模式是消息队列。<br><code>消息队列</code>说一种数据结构，可以存放要执行的任务。它符合队列“先进先出”的特点。</p></blockquote><h5 id="处理其它进程发送过来的任务"><a href="#处理其它进程发送过来的任务" class="headerlink" title="处理其它进程发送过来的任务"></a>处理其它进程发送过来的任务</h5><blockquote><p>渲染进程专门有一个IO线程用来接受其他进程传进来的消息。接受到消息后将这些消息组装成任务发送给主线程，后续步骤同上述。</p></blockquote><h5 id="消息队列中的任务类型"><a href="#消息队列中的任务类型" class="headerlink" title="消息队列中的任务类型"></a>消息队列中的任务类型</h5><blockquote><p>输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript定时器等等。<br>消息队列还包含了很多与页面相关的事件：JavaScript执行、解析DOM、样式计算、布局计算、CSS动画等。</p></blockquote><h4 id="16-WebAPI：setTimeout是如何实现的？"><a href="#16-WebAPI：setTimeout是如何实现的？" class="headerlink" title="16 | WebAPI：setTimeout是如何实现的？"></a>16 | WebAPI：setTimeout是如何实现的？</h4><hr><blockquote><p>setTimeout。一个定时器，用来指定某个函数在多少毫秒之后执行。 </p><p>首先，为了支持定时器实现，浏览器增加了延时队列。<br>其次，由于消息队列排队和一些系统级别的限制，通过setTimeout设置的回调任务并非总是可以实时地执行，这样就不能满足一些实时性要求较高的需求了。<br>最后，在定时器中使用过程中，还存在一些陷阱需要去留意。</p></blockquote><h4 id="17-WebAPI：XMLHttpRequest是怎么实现的？"><a href="#17-WebAPI：XMLHttpRequest是怎么实现的？" class="headerlink" title="17 | WebAPI：XMLHttpRequest是怎么实现的？"></a>17 | WebAPI：XMLHttpRequest是怎么实现的？</h4><hr><h5 id="回调函数-VS-系统调用栈"><a href="#回调函数-VS-系统调用栈" class="headerlink" title="回调函数 VS  系统调用栈"></a>回调函数 VS  系统调用栈</h5><h4 id="18-宏任务和微任务：不是所有任务都是一个待遇"><a href="#18-宏任务和微任务：不是所有任务都是一个待遇" class="headerlink" title="18 | 宏任务和微任务：不是所有任务都是一个待遇"></a>18 | 宏任务和微任务：不是所有任务都是一个待遇</h4><hr><p>##### </p><h4 id="19-Promise：使用Promise，告别回调函数"><a href="#19-Promise：使用Promise，告别回调函数" class="headerlink" title="19 | Promise：使用Promise，告别回调函数"></a>19 | Promise：使用Promise，告别回调函数</h4><hr><blockquote><p>Promise已经成为现代前端的“水”和“电”，很是关键，学好Promise势在必行！</p></blockquote><blockquote><p>Promise解决的是异步编码风格的问题。</p></blockquote><h5 id="Promise：消灭嵌套调用和多次错误处理"><a href="#Promise：消灭嵌套调用和多次错误处理" class="headerlink" title="Promise：消灭嵌套调用和多次错误处理"></a>Promise：消灭嵌套调用和多次错误处理</h5><h3 id="浏览器中的页面-8讲"><a href="#浏览器中的页面-8讲" class="headerlink" title="浏览器中的页面(8讲)"></a>浏览器中的页面(8讲)</h3><h4 id="21-Chrome开发者工具：利用网络面板做性能分析"><a href="#21-Chrome开发者工具：利用网络面板做性能分析" class="headerlink" title="21 | Chrome开发者工具：利用网络面板做性能分析"></a>21 | Chrome开发者工具：利用网络面板做性能分析</h4><hr><blockquote><p>这节内容是介绍了我们平时开发用到的Chrome浏览器的面板。下面记录一下从这篇文章加深印象的知识点：</p><p>控制器：红色圆点表示“开始/暂停抓包”。<br>Disabled cache:禁止从Cache中加载资源。<br>下载信息概要：重点关注【DOMContentLoaded】和【Load】两个事件。</p><ul><li>DOMContentLoaded:这个事件发生后，说明页面已经构建好DOM，意味着构建DOM需要的HTML文件、JavaScript、CSSCSS文件都已经下载完成。</li><li>Load:说明浏览器已经加载了所有的资源（样式、图片等）。<br>单个资源的时间线面板：</li><li>Queuing:导致排队有三个原因，一为资源优先级别；二是浏览器会为每个域名最多维护6个TCP连接；第三个是网络进程为数据分配磁盘空间。</li><li>Stalled：排队完成，进入连接状态，进入连接之前，还有一些原因会导致连接过程被推迟，体现在此。</li><li>Request send:网络进程准备请求数据，并将它发送至网络。这个时间通常不超过1毫秒。</li><li>Waiting(TTFB):数据发送出去，等待接受服务器的第一个字节的数据，通常称为“第一字节时间“。反映服务器响应时间的重要指标。</li></ul></blockquote><h4 id="22-DOM树-JavaScript是如何影响DOM树构建的"><a href="#22-DOM树-JavaScript是如何影响DOM树构建的" class="headerlink" title="22 | DOM树 | JavaScript是如何影响DOM树构建的"></a>22 | DOM树 | JavaScript是如何影响DOM树构建的</h4><hr><p><code>什么是DOM？</code> </p><blockquote><p>从网络传给渲染引擎的HTML文件字节流是无法直接被渲染引擎理解的。<br>所以要将其转化为渲染引擎能够理解的内部结构。<br>这个结构就是DOM。<br><code>DOM三个层面的作用：</code>  </p><ul><li>从页面视角看，DOM是生成页面的基础数据结构。  </li><li>从JS视角来看，DOM提供了给JS脚本操作的接口，JS通过这套接口可以对DOM进行访问，从而改变文档的内容、结构、样式。  </li><li>从安全视角来看，DOM是一道安全防护线。一些不安全的内容在DOM解析阶段被拒之门外。<br>总结：DOM是表述HTML的内部文件，它将Web页面和JavaScript脚本连接起来，并过滤一些不安全的内容。<br><code>DOM树如何生成</code><br>通过<code>HTML解析器</code>：它存在与渲染引擎内部，负责将HTML字节流转换为DOM结构。<br>注意：HTML解析器不是等整个文档加载完毕之后再去解析的，而是网络进程加载了多少数据，HTML解析器便解析多少数据。 </li><li>第一个阶段：通过分词器将字节流转换为Token。（分为Tag Token和文本Token），Tag Token又分为StartTag和EndTag。  </li><li>第二三阶段同步：需要将Token解析为DOM节点，并将DOM节点添加到DOM树中。  </li></ul></blockquote><blockquote><p>JavaScript的下载过程会阻塞DOM的解析。Chrome对此做了优化，其中最主要的一个优化是<code>预解析操作</code>(预解析线程会提前下载这些文件)。 </p></blockquote><h4 id="23-渲染流水线：CSS如何影响首次加载时的白屏时间"><a href="#23-渲染流水线：CSS如何影响首次加载时的白屏时间" class="headerlink" title="23 | 渲染流水线：CSS如何影响首次加载时的白屏时间"></a>23 | 渲染流水线：CSS如何影响首次加载时的白屏时间</h4><hr><p><code>渲染流水线视角下的CSS</code> </p><blockquote><p>合成布局树需要CSSOM和DOM。</p></blockquote><blockquote><p>同HTML一样，浏览器渲染引擎是不理解CSS的，需要将其解析成渲染引擎能够理解的结构：CSSOM。<br>CSSOM有两个作用：第一个是提供给JavaScript操作样式表的能力，第二个是为布局树的合成提供基础的样式信息。 </p></blockquote><blockquote><p>等DOM和CSSOM都构建好之后，渲染引擎就会构造布局树.<br>CSS的白屏出现的通常瓶颈主要体现在：下载CSS文件、下载JavaScript文件和执行JavaSCript。  </p></blockquote><blockquote><p>缩短白屏时间的策略：  </p><ul><li>通过内敛JavaScript、内敛CSS来移除这两种类型的文件下载，这样获取到HTML文件后就可以直接开始渲染流程。 </li><li>在不适合内敛的场景下，减少文件体积，比如通过Webpack等工具移除一些不必要的注释，并压缩JavaScript文件。 </li><li>可以将一些不需要在解析HTML阶段使用的JavaScrit，标记上async活defer。 </li><li>对于特大的CSS文件，可以通过媒体查询属性，将其拆分为不同用途的多CSS文件。</li></ul></blockquote><h4 id="24-分层和合成机制：为什么CSS动画比JavaScript高效？"><a href="#24-分层和合成机制：为什么CSS动画比JavaScript高效？" class="headerlink" title="24 | 分层和合成机制：为什么CSS动画比JavaScript高效？"></a>24 | 分层和合成机制：为什么CSS动画比JavaScript高效？</h4><hr><blockquote><p>关于任意一桢的生成方式，有重排、重绘和合成三种方式。 </p><p>本节主要学习渲染引擎的分层和合成机制，因为分层和合成机制代表了浏览器最为先进的合成技术。<br>Chrome中的合成技术，用三个词来概括的话：分层、分块、合成。  </p></blockquote><h3 id="浏览器安全-5讲"><a href="#浏览器安全-5讲" class="headerlink" title="浏览器安全(5讲)"></a>浏览器安全(5讲)</h3><h4 id="35-CSRF攻击、陌生链接不要点"><a href="#35-CSRF攻击、陌生链接不要点" class="headerlink" title="35 | CSRF攻击、陌生链接不要点"></a>35 | CSRF攻击、陌生链接不要点</h4><hr><blockquote><p><code>黑客经常采用的三种攻击方式是：</code> </p><ul><li>自动发起Get请求。 </li><li>自动发起Post请求。</li><li>引诱用户点击链接。<br>和XSS攻击不同的是，CSRF攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来展开攻击。 </li></ul></blockquote><blockquote><p><code>要发起CSRF攻击需要具备三个条件：</code>  </p><ul><li>目标站点存在服务器漏洞。  </li><li>用户登录过目标站点。  </li><li>黑客需要通过第三方站点发起攻击。<br>黑客通过CSRF攻击，最关键的一点是找到服务器的漏洞，所以说对于CSRF攻击的主要防护手段是提升服务器的安全性。  </li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;导读&quot;&gt;&lt;a href=&quot;#导读&quot; class=&quot;headerlink&quot; title=&quot;导读&quot;&gt;&lt;/a&gt;导读&lt;/h3&gt;&lt;h5 id=&quot;本文主要是从极客时间专栏《浏览器工作原理与实践》，对其每一章的学习进行系统性总结–总版。&quot;&gt;&lt;a href=&quot;#本文主要是从极客时间专栏《浏览器工作原理与实践》，对其每一章的学习进行系统性总结–总版。&quot; class=&quot;headerlink&quot; title=&quot;本文主要是从极客时间专栏《浏览器工作原理与实践》，对其每一章的学习进行系统性总结–总版。&quot;&gt;&lt;/a&gt;本文主要是从极客时间专栏《浏览器工作原理与实践》，对其每一章的学习进行系统性总结–总版。&lt;/h5&gt;&lt;hr&gt;
    
    </summary>
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>每周分享第十二期</title>
    <link href="http://liugezhou.online/2019/09/15/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC%E5%8D%81%E4%BA%8C%E6%9C%9F/"/>
    <id>http://liugezhou.online/2019/09/15/每周分享第十二期/</id>
    <published>2019-09-15T07:00:00.000Z</published>
    <updated>2019-09-30T03:18:02.129Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="有的人-将跑步贯穿自己的生命"><a href="#有的人-将跑步贯穿自己的生命" class="headerlink" title="有的人 将跑步贯穿自己的生命"></a>有的人 将跑步贯穿自己的生命</h4><h4 id="有的人-把对动物的呵护作为一种消遣"><a href="#有的人-把对动物的呵护作为一种消遣" class="headerlink" title="有的人 把对动物的呵护作为一种消遣"></a>有的人 把对动物的呵护作为一种消遣</h4><h4 id="有的人-通过看书来来作为自己追求自由的一种方式"><a href="#有的人-通过看书来来作为自己追求自由的一种方式" class="headerlink" title="有的人 通过看书来来作为自己追求自由的一种方式"></a>有的人 通过看书来来作为自己追求自由的一种方式</h4><h4 id="有的人-读史写史，想要观测人生的意义"><a href="#有的人-读史写史，想要观测人生的意义" class="headerlink" title="有的人 读史写史，想要观测人生的意义"></a>有的人 读史写史，想要观测人生的意义</h4><h4 id="有的人-无为而治-平淡的对着一切喜怒哀乐"><a href="#有的人-无为而治-平淡的对着一切喜怒哀乐" class="headerlink" title="有的人 无为而治 平淡的对着一切喜怒哀乐"></a>有的人 无为而治 平淡的对着一切喜怒哀乐</h4><h4 id="有的人-悲观乐观交至，无奈的挥洒着每一滴汗水"><a href="#有的人-悲观乐观交至，无奈的挥洒着每一滴汗水" class="headerlink" title="有的人 悲观乐观交至，无奈的挥洒着每一滴汗水"></a>有的人 悲观乐观交至，无奈的挥洒着每一滴汗水</h4><h4 id="有的人-不喜思考不愿作为，按着别人的意识走着自以为的康庄大道"><a href="#有的人-不喜思考不愿作为，按着别人的意识走着自以为的康庄大道" class="headerlink" title="有的人 不喜思考不愿作为，按着别人的意识走着自以为的康庄大道"></a>有的人 不喜思考不愿作为，按着别人的意识走着自以为的康庄大道</h4></blockquote><a id="more"></a><blockquote><h4 id="不管怎样，在未来或者现在，当回收往事的时候，有那么一件、两件、三四件我们为之自豪、骄傲、坚持的事，那我们便是幸运的。"><a href="#不管怎样，在未来或者现在，当回收往事的时候，有那么一件、两件、三四件我们为之自豪、骄傲、坚持的事，那我们便是幸运的。" class="headerlink" title="不管怎样，在未来或者现在，当回收往事的时候，有那么一件、两件、三四件我们为之自豪、骄傲、坚持的事，那我们便是幸运的。"></a>不管怎样，在未来或者现在，当回收往事的时候，有那么一件、两件、三四件我们为之自豪、骄傲、坚持的事，那我们便是幸运的。</h4></blockquote><h3 id="门萨俱乐部"><a href="#门萨俱乐部" class="headerlink" title="门萨俱乐部"></a>门萨俱乐部</h3><hr><blockquote><p>门萨的英文名为：<code>MENSA</code>, 是拉丁语中”圆桌”的意思。</p><p>MENSA不涉及任何政治、宗教及社会事务而只关注纯粹的智商问题。</p><p>MENSA特别注重的是它是一个非营利性社团，在其运作中可能产生的少量获利都用作其活动经费且受到严格监控。</p><p>除了高智商外，MENSA的会员可以说并无其他特征。参加MENSA的惟一途径便是参加考试并脱颖而出（平均每一百人中有两人有机会被吸纳为正式会员）。</p><p>MENSA拥有十万会员，分布遍及世界100个国家和地区.</p></blockquote><h3 id="双峰干涉实验–《天才最左，疯子在右》"><a href="#双峰干涉实验–《天才最左，疯子在右》" class="headerlink" title="双峰干涉实验–《天才最左，疯子在右》"></a>双峰干涉实验–《天才最左，疯子在右》</h3><hr><blockquote><p>这本书在三四年前看了一些，根本不知道写的是个什么，最近打开这本书瞅了瞅激起了一些兴趣。</p></blockquote><blockquote><p>其中印象比较深刻的一节–<code>迷失的旅行者</code>，提到了关于双峰干涉实验的一个解释–多重宇宙。</p></blockquote><blockquote><p>未曾查到此书是真记录还是真噱头，只是抱着一种不求甚解的感觉，引发一些遐想。</p></blockquote><h3 id="左耳朵耗子"><a href="#左耳朵耗子" class="headerlink" title="左耳朵耗子"></a>左耳朵耗子</h3><hr><blockquote><p>微博用户【左耳朵耗子】。</p></blockquote><blockquote><p>陈皓：20年软件开发相关工作经验，10年以上项目和团队管理经验，个人网站：<a href="https://coolshell.cn/" target="_blank" rel="noopener">https://coolshell.cn/</a></p><p>之前读过他的好几篇文章，很有想法。时不时的跟人在网上怼两句，也被人怼。</p><p>他在微博的很多言论、有意思。</p></blockquote><h3 id="Zoom"><a href="#Zoom" class="headerlink" title="Zoom"></a>Zoom</h3><hr><blockquote><p>如果你的团队需要开视频会议，可以使用Zoom。<br>但不幸的是前几天：左耳朵耗子在他的微博上说Zoom被墙。</p></blockquote><h3 id="邮箱"><a href="#邮箱" class="headerlink" title="邮箱"></a>邮箱</h3><hr><blockquote><p>由于邮箱众多，很早之前便开始使用网易邮箱大师，今天突然发现还是IPhone自带的邮件功能好用很多，纯天然无广告。</p></blockquote><h3 id="Research"><a href="#Research" class="headerlink" title="Research"></a><a href="http://www.suiyuanka.com" target="_blank" rel="noopener">Research</a></h3><blockquote><p>一个中文搜索的聚合网站，显示同一个关键字在不同网站的搜索结果。</p></blockquote><h3 id="在开源项目中展示广告的后续"><a href="#在开源项目中展示广告的后续" class="headerlink" title="在开源项目中展示广告的后续"></a><a href="https://mp.weixin.qq.com/s/UnRg1CuiupNos_h2XRNf-w" target="_blank" rel="noopener">在开源项目中展示广告的后续</a></h3><hr><blockquote><p>前一段时间，一个 Star 数超过 2.2 万的 Standard JS 开源项目做了一个尝试，通过终端安装后展示赞助商的广告。<br><b>事件后续:</b><br>0、该实验自开启后就遭到很多批评，两个赞助商也退出了；<br>1、实验发起人之一的 feross，在其个人博客发文，宣告实验终结；<br>2、npm 公司的 CTO 已对外作出回应，不接受在终端展示商业广告。另外，npm 会修改更新政策.</p></blockquote><h3 id="better-scroll"><a href="#better-scroll" class="headerlink" title="better-scroll"></a>better-scroll</h3><hr><blockquote><p>BetterScroll 是一款重点解决移动端（已支持 PC）各种滚动场景需求的插件。它的核心是借鉴的 iscroll 的实现，它的 API 设计基本兼容 iscroll，在 iscroll 的基础上又扩展了一些 feature 以及做了一些性能优化。</p></blockquote><blockquote><p>关于此插件：<br><a href="https://better-scroll.github.io/docs/zh-CN/guide/" target="_blank" rel="noopener">better-scroll的官方文档</a><br><a href="https://zhuanlan.zhihu.com/p/27407024" target="_blank" rel="noopener">当better-scroll遇见Vue</a></p></blockquote><h3 id="数据记录"><a href="#数据记录" class="headerlink" title="数据记录"></a>数据记录</h3><hr><blockquote><p>阮一峰的本周分享刊首语提到了如何让三分钟热度的用户坚持下来的一个解决方法：就是数据记录。每天都记录下来干的事情。可以看到自己的进步，产生一种不断挑战自己、超越自己的愿望。<br>正如文中提到的，GitHub 个人页的日历栏目，以及我现在所磕磕盼盼的周总结，希望可以通过数据记录的方式、看到自己的进步，让自己在这个做什么都像是浪费生命的世界里有些记录。</p></blockquote><h3 id="蚂蚁搬家工具"><a href="#蚂蚁搬家工具" class="headerlink" title="蚂蚁搬家工具"></a><a href="https://github.com/ant-move/antmove" target="_blank" rel="noopener">蚂蚁搬家工具</a></h3><hr><blockquote><p>小程序跨平台开发工具。一键实现微信小程序项目到支付宝小程序的迁徙，不再为重复开发而烦恼。</p></blockquote><h3 id="HelloDjango-Django-博客教程"><a href="#HelloDjango-Django-博客教程" class="headerlink" title="HelloDjango - Django 博客教程"></a><a href="https://www.zmrenwu.com/courses/hellodjango-blog-tutorial/" target="_blank" rel="noopener">HelloDjango - Django 博客教程</a></h3><hr><blockquote><p>Django 框架的中文入门教程，免费带你学 django 全栈。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h4 id=&quot;有的人-将跑步贯穿自己的生命&quot;&gt;&lt;a href=&quot;#有的人-将跑步贯穿自己的生命&quot; class=&quot;headerlink&quot; title=&quot;有的人 将跑步贯穿自己的生命&quot;&gt;&lt;/a&gt;有的人 将跑步贯穿自己的生命&lt;/h4&gt;&lt;h4 id=&quot;有的人-把对动物的呵护作为一种消遣&quot;&gt;&lt;a href=&quot;#有的人-把对动物的呵护作为一种消遣&quot; class=&quot;headerlink&quot; title=&quot;有的人 把对动物的呵护作为一种消遣&quot;&gt;&lt;/a&gt;有的人 把对动物的呵护作为一种消遣&lt;/h4&gt;&lt;h4 id=&quot;有的人-通过看书来来作为自己追求自由的一种方式&quot;&gt;&lt;a href=&quot;#有的人-通过看书来来作为自己追求自由的一种方式&quot; class=&quot;headerlink&quot; title=&quot;有的人 通过看书来来作为自己追求自由的一种方式&quot;&gt;&lt;/a&gt;有的人 通过看书来来作为自己追求自由的一种方式&lt;/h4&gt;&lt;h4 id=&quot;有的人-读史写史，想要观测人生的意义&quot;&gt;&lt;a href=&quot;#有的人-读史写史，想要观测人生的意义&quot; class=&quot;headerlink&quot; title=&quot;有的人 读史写史，想要观测人生的意义&quot;&gt;&lt;/a&gt;有的人 读史写史，想要观测人生的意义&lt;/h4&gt;&lt;h4 id=&quot;有的人-无为而治-平淡的对着一切喜怒哀乐&quot;&gt;&lt;a href=&quot;#有的人-无为而治-平淡的对着一切喜怒哀乐&quot; class=&quot;headerlink&quot; title=&quot;有的人 无为而治 平淡的对着一切喜怒哀乐&quot;&gt;&lt;/a&gt;有的人 无为而治 平淡的对着一切喜怒哀乐&lt;/h4&gt;&lt;h4 id=&quot;有的人-悲观乐观交至，无奈的挥洒着每一滴汗水&quot;&gt;&lt;a href=&quot;#有的人-悲观乐观交至，无奈的挥洒着每一滴汗水&quot; class=&quot;headerlink&quot; title=&quot;有的人 悲观乐观交至，无奈的挥洒着每一滴汗水&quot;&gt;&lt;/a&gt;有的人 悲观乐观交至，无奈的挥洒着每一滴汗水&lt;/h4&gt;&lt;h4 id=&quot;有的人-不喜思考不愿作为，按着别人的意识走着自以为的康庄大道&quot;&gt;&lt;a href=&quot;#有的人-不喜思考不愿作为，按着别人的意识走着自以为的康庄大道&quot; class=&quot;headerlink&quot; title=&quot;有的人 不喜思考不愿作为，按着别人的意识走着自以为的康庄大道&quot;&gt;&lt;/a&gt;有的人 不喜思考不愿作为，按着别人的意识走着自以为的康庄大道&lt;/h4&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="每周分享" scheme="http://liugezhou.online/categories/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="每周分享" scheme="http://liugezhou.online/tags/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
</feed>
