<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>六个周</title>
  
  <subtitle>liugezhou</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liugezhou.online/"/>
  <updated>2020-01-04T15:38:54.595Z</updated>
  <id>http://liugezhou.online/</id>
  
  <author>
    <name>liugezhou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>node入门</title>
    <link href="http://liugezhou.online/2020/01/03/node%E5%85%A5%E9%97%A8/"/>
    <id>http://liugezhou.online/2020/01/03/node入门/</id>
    <published>2020-01-03T10:00:00.000Z</published>
    <updated>2020-01-04T15:38:54.595Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><hr><blockquote><p>最近有一个node服务的项目需要去接手，于是在阅读学习各种有关node的文章，零零总总的看了一些文章，感觉还是一团浆糊，遂整理总结出此文。<br>此文并未加入自己的理解，主要是从网上查阅资料看到的一些入门教程，将教程中的讲解进行重点知识的记录、梳理。</p></blockquote><a id="more"></a><h3 id="教程一-廖雪峰官网的Node-js"><a href="#教程一-廖雪峰官网的Node-js" class="headerlink" title="教程一:廖雪峰官网的Node.js"></a>教程一:<a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023025235359040" target="_blank" rel="noopener">廖雪峰官网的Node.js</a></h3><h4 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h4><hr><blockquote><p>在2009年，Ryan正式推出了基于JavaScript语言和V8引擎的开源Web服务器项目，命名为Node.js。虽然名字很土，但是，Node第一次把JavaScript带入到后端服务器开发，加上世界上已经有无数的JavaScript开发人员，所以Node一下子就火了起来。    </p></blockquote><blockquote><p>由于一群开发者对Joyent公司的策略不满(Node幕后一直由Joyent公司资助)，于2014年从Node.js项目fork出了io.js项目，决定单独发展，但两者实际上是兼容的。  </p></blockquote><blockquote><p>“分久必合，合久必分”,Joyent公司表示要和解,io.js项目又决定回归Node.js。    </p></blockquote><blockquote><p>将来io.js将首先添加新的特性，如果大家测试用得爽，就把新特性加入Node.js。io.js是“尝鲜版”，而Node.js是线上稳定版，</p></blockquote><h4 id="安装node-js和npm"><a href="#安装node-js和npm" class="headerlink" title="安装node.js和npm"></a>安装node.js和npm</h4><hr><blockquote><p>首先，从Node.js官网下载对应平台的安装程序.<br>安装完成后，在终端中输出：<code>node -v</code>,显示版本号，说明安装成功。</p></blockquote><blockquote><p>npm是Node.js的包管理工具（package manager）。<br>npm已经在Node.js安装的时候顺带装好了。我们在命令提示符或者终端输入<code>npm -v</code>,显示版本号。</p></blockquote><h4 id="第一个Node程序"><a href="#第一个Node程序" class="headerlink" title="第一个Node程序"></a>第一个Node程序</h4><hr><blockquote><p>命令行模式下，输入<code>node</code>回车，进入Node交互式环境。<br>或者也可以直接<code>node hello.js</code>运行一个.js文件。</p></blockquote><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><hr><blockquote><p>在Node环境中，一个.js文件就称之为一个模块（module）。<br>使用模块可以避免函数名和变量名冲突。这是因为：JavaScript是一种<code>函数式编程语言</code>，它支持闭包。如果我们把一段JavaScript代码用一个函数包装起来，这段代码的所有“全局”变量就变成了函数内部的局部变量。而Node加载一个模块，其实就是对代码进行了一层包装。</p></blockquote><blockquote><p>要在模块中对外输出变量，用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module.exports = variable;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>输出的变量可以是任意对象、函数、数组等等。<br>要引入其他模块输出的对象，用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var foo = require(&apos;other_module&apos;);</span><br></pre></td></tr></table></figure></blockquote><blockquote><p> 引入的对象具体是什么，取决于引入模块输出的对象。</p></blockquote><blockquote><p>关于Node.js的模块原理：<br>JavaScript语言本身并没有一种模块机制来保证不同模块可以使用相同的变量名。而是因为由于JavaScript是一种函数式编程语言，它支持闭包，Node加载一个js文件，就相当于把代码包装了一下，原来代码中的全局变量变成了函数内部的局部变量，因此每个模块中定义的全局变量并不会相互干扰。</p></blockquote><h4 id="基本模块"><a href="#基本模块" class="headerlink" title="基本模块"></a>基本模块</h4><hr><blockquote><p>Node.js内置的常用模块是为了实现基本的服务器功能，这些模块在浏览器环境中是无法执行的，因为它们的底层代码是用C/C++在Node.js运行环境中实现的。   </p></blockquote><blockquote><ul><li>global:相当于浏览器环境中的window。<br>在终端中输入node进入node环境，然后输入：<code>for (var k of Object.keys(global)) { console.log(k);}</code>,可以查看输出的结果，以更好理解global。</li></ul></blockquote><blockquote><ul><li>process: 是Node.js提供的一个对象，它代表当前Node.js进程。<br>如果我们想要在下一次事件响应中执行代码，可以调用process.nextTick().</li></ul></blockquote><h4 id="fs"><a href="#fs" class="headerlink" title="fs"></a>fs</h4><hr><blockquote><p>Node.js内置的fs模块是文件系统模块，负责读写文件。<br>fs模块同时提供了异步和同步的方法。 </p></blockquote><h5 id="异步读取文件"><a href="#异步读取文件" class="headerlink" title="异步读取文件"></a>异步读取文件</h5><blockquote><p>异步读取一个文件的代码如下： <code>fs.readFile(&#39;sample.txt&#39;,&#39;utf-8&#39;,function(err, data){})</code><br>异步读取时，传入的回调函数接受两个参数，当正常读取时，err参数为null，data参数为读取到的string。当读取发生错误时，err参数代表一个错误对象，data为undefined。<br>这也是Node.js标准的回调函数：第一个参数代表错误信息，第二个参数代表结果。后面我们会经常用到这种回调函数。 </p></blockquote><blockquote><p>读取二进制文件时，<code>fs.readFile(&#39;demo.png&#39;,function(err, data){}</code><br>不传入文件编码时，回调函数的data返回的是一个Buffer对象。在Node中，Buffer对象就是一个包含零个或任意个字节数的数组(与Array不同)。<br>Buffer对象转换为String：<code>data.toString(&#39;utf-8&#39;)</code>;<br>String对象转换为Buffer：<code>Buffer.from(data,&#39;utf-8&#39;)</code>;  </p></blockquote><h5 id="同步读取文件"><a href="#同步读取文件" class="headerlink" title="同步读取文件"></a>同步读取文件</h5><blockquote><p><code>fs.readFileSync()</code>;</p></blockquote><h5 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h5><blockquote><p><code>fs.writeFile(&#39;output.txt&#39;,data, function(err){}</code>;<br>writeFile()的参数依次为文件名、数据和回调函数。<br>和readFileSync()类似，写入文件也有一个同步方法：writeFileSync();  </p></blockquote><h5 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h5><blockquote><p>如果我们要获取文件大小、创建时间等信息，可以使用fs.stat()方法，此方法返回一个stat对象，能告诉我们目录文件详细信息。<br>是否是文件：<code>stat.isFile()</code>;<br>是否是目录：<code>stat.isDirectory()</code>;<br>若是文件，文件大小： <code>stat.size</code>;<br>若是文件，文件创建时间：<code>stat.birthtime</code>;<br>若是文件，文件修改时间：<code>stat.mtime</code>; </p></blockquote><blockquote><p><code>stat()</code>也有一个对应的同步方法：<code>statSync()</code>;</p></blockquote><h4 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h4><hr><blockquote><p>stream是Node.js提供的又一个仅在服务端可用的模块，目的是支持“流”这种数据结构。<br>流分为：stain(标准输入流)、staout(标准输出流)。   </p></blockquote><blockquote><p>读取文件流的核心语法是： <code>fs.createReadStream()</code>,代码见：<a href="https://github.com/liugezhou/koa/blob/master/basic/steam/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%96%87%E6%9C%AC.js" target="_blank" rel="noopener">文件读取文本</a>  </p></blockquote><blockquote><p>以流的形式写入文件，只有不断调用write()方法，代码见：<a href="https://github.com/liugezhou/koa/blob/master/basic/steam/%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6.js" target="_blank" rel="noopener">文本写入文件</a></p></blockquote><blockquote><p>将Readable流和Writable流串起来，所有的数据从Readable流进入Writable流，这种操作叫做pipe。在Node.js中，Readable流有一个pipe()方法，就是用来干这件事的。代码见：<a href="https://github.com/liugezhou/koa/blob/master/basic/steam/pipe.js" target="_blank" rel="noopener">pipe</a></p></blockquote><h4 id="http"><a href="#http" class="headerlink" title="http"></a>http</h4><hr><blockquote><p>要开发HTTP服务器程序，从头处理TCP连接，解析HTTP是不现实的。这些工作实际上已经由Node.js自带的http模块完成了。应用程序并不直接和HTTP协议打交道，而是操作http模块提供的request和response对象。</p></blockquote><blockquote><p>request对象封装了HTTP请求，我们调用request对象的属性和方法就可以拿到所有HTTP请求的信息；</p></blockquote><blockquote><p>response对象封装了HTTP响应，我们操作response对象的方法，就可以把HTTP响应返回给浏览器。</p></blockquote><h4 id="crypto"><a href="#crypto" class="headerlink" title="crypto"></a>crypto</h4><hr><blockquote><p>crypto模块的目的是为了提供通用的加密和哈希算法。用纯JavaScript代码实现这些功能不是不可能，但速度会非常慢。Nodejs用C/C++实现这些算法后，通过crypto这个模块暴露为JavaScript接口，这样用起来方便，速度也快。 </p></blockquote><blockquote><ul><li>MD5和SHA1是常用的哈希算法，用于给任意数据一个“签名”，这个签名通常用一个十六进制的字符串表示。   </li><li>Hmac算法：也是一种哈希算法，不同的是，它还需要加一个密钥。  </li><li>AES算法：是一种常用的对称加密算法，加解密都用同一个密钥。   </li><li>Diffie-Hellman：DH算法是一种密钥交换协议。  </li><li>RAS：RAS算法是一种对称加密算法</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;最近有一个node服务的项目需要去接手，于是在阅读学习各种有关node的文章，零零总总的看了一些文章，感觉还是一团浆糊，遂整理总结出此文。&lt;br&gt;此文并未加入自己的理解，主要是从网上查阅资料看到的一些入门教程，将教程中的讲解进行重点知识的记录、梳理。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Node.js" scheme="http://liugezhou.online/categories/Node-js/"/>
    
    
      <category term="node" scheme="http://liugezhou.online/tags/node/"/>
    
      <category term="js" scheme="http://liugezhou.online/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>每周总结第二十五期</title>
    <link href="http://liugezhou.online/2019/12/29/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%94%E6%9C%9F/"/>
    <id>http://liugezhou.online/2019/12/29/每周总结第二十五期/</id>
    <published>2019-12-29T04:15:00.000Z</published>
    <updated>2019-12-29T04:15:49.761Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这里记录过去一周，我的一些小总结。<br> <img src="http://img.liugezhou.online/weekly25.jpeg" alt="weekly-25"></p></blockquote><a id="more"></a><h3 id="Feeling"><a href="#Feeling" class="headerlink" title="Feeling"></a>Feeling</h3><blockquote><p>何谓朋友？ </p><p>我曾以狭隘的思考巴拉巴拉的说道：</p><p>其实朋友这个词的出现，是因为身为有意识的个体在这个世界出现后.<br>多数时间的独处.<br>可能因为害怕孤单、可能因为享受快乐，也可能因为骄傲，等等的一些生活感受.<br>而使得想要有所依靠、分享、诉说，因而有了朋友。  </p><p>其实朋友这个名词不重要。<br>还在乎朋友是因为自己内心不够平静.<br>而且你没有发现，很多所谓朋友的交流:<br>在漫漫、而浮于表面—-没有内涵。<br>而且加上因为个体自我的期望没有实现，<br>因此才想要在社交中与他人的交流中去给予自我一些宽慰，这种心理的深处、<br>可能就是不自信、不充实。<br>而朋友出现了，一次次的缓解你这个感触，直到你没有这个感触。</p><p>aliya告诉我说： </p><p>因为你有我.<br>所以可能你会暂时天真的以为没有朋友也没事，<br>你也可以天真的这么突然自以为。<br>但是有的人不是啊，没对象没家庭，那怎么证明自己还活着？<br>就是朋友啊。<br>什么平静、自信、充实，也不过是活着的附加品。<br>朋友的存在就是证明着你还活着。<br>朋友的意义对于一些人来说，对于大多数还没找寻到人生的目标前，朋友是他们生命中一部分的意义。</p></blockquote><h3 id="重磅文件！中国户籍制度大变局"><a href="#重磅文件！中国户籍制度大变局" class="headerlink" title="重磅文件！中国户籍制度大变局"></a><a href="https://mp.weixin.qq.com/s/L4LLwv1Q5SLLqkuU66bLMA" target="_blank" rel="noopener">重磅文件！中国户籍制度大变局</a></h3><blockquote><p>2019年12月25日(本周三)，中共中央办公厅 国务院办公厅印发《关于促进劳动力和人才社会性流动体制机制改革的意见》，详见<a href="http://www.gov.cn/zhengce/2019-12/25/content_5463978.htm" target="_blank" rel="noopener">这里</a>.    </p><p>以下内容来自公众号《最爱大北京》的一些内容摘要，文章链接<a href="https://mp.weixin.qq.com/s/L4LLwv1Q5SLLqkuU66bLMA" target="_blank" rel="noopener">点击这里</a> </p><p><code>全面取消</code>城区常住人口300万以下的城市落户限制，<code>全面放宽</code>城区常住人口300万至500万的大城市落户条件。</p><p><code>完善</code>城区常住人口500万以上的超大特大城市<code>积分落户政策</code>，精简积分项目，确保社会保险缴纳年限和居住年限分数占主要比例。<br>以合肥、昆明、苏州、大连、南宁为代表的I型大城市将全面放宽落户条件，石家庄、南昌、无锡、珠海、常州等II型大城市，以及所有的三四线中小城市，都会<code>全面取消落户限制</code>。</p></blockquote><h3 id="一锤定音，70年产权到期后可续期，房产税要加速来了？"><a href="#一锤定音，70年产权到期后可续期，房产税要加速来了？" class="headerlink" title="一锤定音，70年产权到期后可续期，房产税要加速来了？"></a><a href="https://36kr.com/p/5152186?ktm_source=feed" target="_blank" rel="noopener">一锤定音，70年产权到期后可续期，房产税要加速来了？</a></h3><blockquote><p>70年产权的计算是从开发商拿地开始起计，不是从你买房或拿到房产证那一刻开始算的。<br>世界上其他国家的房产基本都是永久产权，为什么我们国家只有70年的产权呢？<br>产权到期了该怎么办？<br>房产税会怎么征收？</p><p>这是一篇来自2018年9月17日的一篇资讯。<a href="https://36kr.com/p/5152186?ktm_source=feed" target="_blank" rel="noopener">文章来源</a></p></blockquote><h3 id="问医生"><a href="#问医生" class="headerlink" title="问医生"></a>问医生</h3><blockquote><p>微信搜一搜上线健康搜索服务，其中，健康搜索服务中主要分为三方面：健康信息查询、在线问医生，和预约挂号。</p><p>在微信搜一搜中输入病的症状（“头疼”、“发烧”等），搜索结果将展示：病因、就医方法、治疗等说明和建议。</p><p>内容来源包含众多实名医生背书的权威医疗内容、和由权威医学专家团编写的常见疾病及药品百科词条的专业解读。</p></blockquote><h3 id="北京7号线双井站开通"><a href="#北京7号线双井站开通" class="headerlink" title="北京7号线双井站开通"></a><a href="http://www.bjnews.com.cn/news/2019/12/26/666505.html" target="_blank" rel="noopener">北京7号线双井站开通</a></h3><blockquote><p>昨日(周六)，北京7号线东延、八通线南延开通试运营。<br>7号线双井站开通使用，换乘通道将同步开通，不过工作日自首班车至上午10时，7号线和10号线双井站分别独立开放运营，其他时段可以在双井站换乘。</p></blockquote><h3 id="北京新能源指标申请数已超45万！新申请或等9年才有资购车"><a href="#北京新能源指标申请数已超45万！新申请或等9年才有资购车" class="headerlink" title="北京新能源指标申请数已超45万！新申请或等9年才有资购车"></a><a href="https://news.mydrivers.com/1/664/664083.htm" target="_blank" rel="noopener">北京新能源指标申请数已超45万！新申请或等9年才有资购车</a></h3><blockquote><p>12月25日，北京小客车指标办公发布了今年最后一期指标配置数据。新能源小客车指标申请个人共有458673个，单位共有11263家，本期申请人数增加1万人左右。<br>按照每年5.4万个新能源指标计算，且今年的指标已完全用尽。所以，如果按照现行规则不变，新能源指标新申请者或将等待9年，也就是2028年才能获得指标。<br><cite><a href="https://news.mydrivers.com/1/664/664083.htm" target="_blank" rel="noopener">文章来源</a></cite></p></blockquote><h3 id="牙医"><a href="#牙医" class="headerlink" title="牙医"></a>牙医</h3><blockquote><p>美国教育部公布官方数据，美国大学毕业生第一年收入最高的各校专业排名，前十名里面有九个是牙医专业.<br><cite>阮一峰的网络日志</cite></p></blockquote><h3 id="腾讯会议APP"><a href="#腾讯会议APP" class="headerlink" title="腾讯会议APP"></a>腾讯会议APP</h3><blockquote><p>腾讯推出的一块开会APP。<br>全平台运行，手机、电脑、平板、Web一键入会。小程序打开即用，不需要下载任何插件或客户端。支持手机录屏等功能。</p></blockquote><h3 id="圣诞节前成功断网！俄罗斯举行首次国家级断网演习引热议"><a href="#圣诞节前成功断网！俄罗斯举行首次国家级断网演习引热议" class="headerlink" title="圣诞节前成功断网！俄罗斯举行首次国家级断网演习引热议"></a><a href="https://mp.weixin.qq.com/s/XfJvYuMb-M3-kHpibPsOTg" target="_blank" rel="noopener">圣诞节前成功断网！俄罗斯举行首次国家级断网演习引热议</a></h3><blockquote><p>俄罗斯政府宣布，已完成一系列测试，成功地使该国脱离了全球互联网，从而使俄罗斯的RuNet成为全球最大的内部网。此举引发专家担忧和网友热议：这意味着人们将无法就本国正在发生的事情进行对话，而陷入自己的泡沫中。<br><cite><a href="https://mp.weixin.qq.com/s/XfJvYuMb-M3-kHpibPsOTg" target="_blank" rel="noopener">文章来源</a></cite></p></blockquote><h3 id="Tiobe"><a href="#Tiobe" class="headerlink" title="Tiobe"></a>Tiobe</h3><blockquote><p>TIOBE排行榜是根据互联网上有经验的程序员、<code>课程</code>和第三方厂商的数量，并使用搜索引擎（如Google、Bing、Yahoo!）以及Wikipedia、Amazon、YouTube统计出排名数据，只是反映某个编程语言的热门程度，并不能说明一门编程语言好不好，或者一门语言所编写的代码数量多少。<br>2019年12月编程语言排行榜,前十名依次为：<br>Java、C、Python、C++、c#、Visual Basic .NET、JavaScript、PHP、SQL、Swift。<br><cite><a href="https://hellogithub.com/report/tiobe/" target="_blank" rel="noopener">排名来源</a></cite></p></blockquote><h3 id="node入门"><a href="#node入门" class="headerlink" title="node入门"></a>node入门</h3><blockquote><p>这是一篇短小精悍的node入门教程。<br>为了更彻底、清楚的学习本教程，我在Github上整理了一个<a href="https://github.com/liugezhou/nodejs_getting_started" target="_blank" rel="noopener">仓库</a>。</p><p>这篇文章关于JavaScript的一点描述说道：<br>“尽管当想要增强页面的时候，使用jQuery总让你觉得很爽，但到最后，你顶多是个JavaScript用户，而非JavaScript开发者。”  </p><p>于是勉励自己，对JS的掌握，慢慢能成为其开发者，而不仅仅是其用户。</p></blockquote><h3 id="浏览器工作原理与实践"><a href="#浏览器工作原理与实践" class="headerlink" title="浏览器工作原理与实践"></a><a href="https://liugezhou.gitbook.io/liugezhou/" target="_blank" rel="noopener">浏览器工作原理与实践</a></h3><blockquote><p>历时两个月将《极客时间》上的一个专栏进行了通篇学习。并且整理自<a href="https://liugezhou.gitbook.io/liugezhou/" target="_blank" rel="noopener">Gitbook</a>.     </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这里记录过去一周，我的一些小总结。&lt;br&gt; &lt;img src=&quot;http://img.liugezhou.online/weekly25.jpeg&quot; alt=&quot;weekly-25&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="每周分享" scheme="http://liugezhou.online/categories/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="每周分享" scheme="http://liugezhou.online/tags/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>每周总结第二十四期</title>
    <link href="http://liugezhou.online/2019/12/22/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%9B%9B%E6%9C%9F/"/>
    <id>http://liugezhou.online/2019/12/22/每周总结第二十四期/</id>
    <published>2019-12-22T10:08:00.000Z</published>
    <updated>2019-12-23T01:34:54.374Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这里记录过去一周，我的一些小总结。<br> <img src="http://img.liugezhou.online/weekly24.jpeg" alt="weekly-24"></p></blockquote><a id="more"></a><h4 id="Feeling"><a href="#Feeling" class="headerlink" title="Feeling"></a>Feeling</h4><blockquote><p>最近几年喝酒好似没有了年轻时的浪荡不羁。<br>每次喝毕总有一些稀奇古怪的感受，第二天醒来一阵落幕感袭来。<br>就立个flag：以后不喝酒了，Quit Drinking。  </p></blockquote><h4 id="羞愧"><a href="#羞愧" class="headerlink" title="羞愧"></a>羞愧</h4><blockquote><p>当aliya问我什么是车厘子的时候，我说不知道。<br>她说：你应该问此而羞愧，我说的羞愧指的并不是你不知道这个东西 而是你知道你不知道后还不知道。   </p></blockquote><h4 id="关于侵害用户权益行为的APP（第一批）通报"><a href="#关于侵害用户权益行为的APP（第一批）通报" class="headerlink" title="关于侵害用户权益行为的APP（第一批）通报"></a><a href="http://www.miit.gov.cn/n1146290/n1146402/n1146440/c7575066/content.html?tsrrbdcdnht=" target="_blank" rel="noopener">关于侵害用户权益行为的APP（第一批）通报</a></h4><blockquote><p>工业和信息化部信息通信管理局关于侵害用户权益行为的APP通报。   </p></blockquote><h4 id="Maskbook"><a href="#Maskbook" class="headerlink" title="Maskbook"></a><a href="https://mp.weixin.qq.com/s/ZQSy8JdFdoAPug2rJ7ZmJg" target="_blank" rel="noopener">Maskbook</a></h4><blockquote><p>【 Maskbook 给了我一个最直观的感受。这款产品以浏览器插件的形式，把 Facebook 网站变成了一个无法监视的大广场。你依然使用以前的身份账号在这个广场上玩耍 —— 认识新的人、发布自己的动态、交新的朋友 —— 但不同的是，你所发布的数据将被加密成一串串乱码，只有你指定的好友能解读出其中正确的含义。】</p></blockquote><h4 id="图表制作可以很简单-图表魔方-ChartCube"><a href="#图表制作可以很简单-图表魔方-ChartCube" class="headerlink" title="图表制作可以很简单 - 图表魔方 ChartCube"></a><a href="https://chartcube.alipay.com/" target="_blank" rel="noopener">图表制作可以很简单 - 图表魔方 ChartCube</a></h4><blockquote><p>ChartCube 针对快速图表制作的场景，只要有浏览器就可以使用。<br>无论你是谁，都可以用它。你可以完全不懂如何处理数据，你可以没听说过任何图表类库，你也不需要写一行代码。通过最直观的交互，谁都能制作出所需的图表。<br>利用 ChartCube 制作图表，过程非常简单。通常你需要三步：选择图表、配置图表、导出图表。</p></blockquote><h4 id="教育部关于同意某大学章程部分条款修改的批复"><a href="#教育部关于同意某大学章程部分条款修改的批复" class="headerlink" title="教育部关于同意某大学章程部分条款修改的批复"></a><a href="http://www.moe.gov.cn/srcsite/A02/zfs_gdxxzc/201912/t20191216_412276.html" target="_blank" rel="noopener">教育部关于同意某大学章程部分条款修改的批复</a></h4><blockquote><p>以上为教育部网站原文链接。</p></blockquote><h4 id="和“内存杀手”-Chrome-说再见-新版-Edge-即将发布"><a href="#和“内存杀手”-Chrome-说再见-新版-Edge-即将发布" class="headerlink" title="和“内存杀手” Chrome 说再见? 新版 Edge 即将发布"></a><a href="https://mp.weixin.qq.com/s/g9WlXAjw0gPWzjfw0cgGPA" target="_blank" rel="noopener">和“内存杀手” Chrome 说再见? 新版 Edge 即将发布</a></h4><blockquote><p>近日，有不少外媒表示，微软计划于 2020 年 1 月 15 日正式发布基于 Chromium 的 Edge 浏览器，该浏览器支持 Windows 10、Windows 7、Windows 8 和 macOS 等操作系统。同时，更有网友通过对 Edge Chromium Beta 实测后，称新版 Edge 比 Chrome 更好用，比 Firefox 的功能更完善.<br>微软还为 Edge 引入新的 logo 和图<br><img src="https://mmbiz.qpic.cn/mmbiz_gif/Pn4Sm0RsAujIolbibsroulrun7rebicTT0mfUoWsWyQYZJ8j6IGjhhd3aqx5SC9ibDVQ2wN4NvCZajCjf25p5b5Dg/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" alt="logo"></p></blockquote><h4 id="文言文编程语言，可谓年度最骚语言"><a href="#文言文编程语言，可谓年度最骚语言" class="headerlink" title="文言文编程语言，可谓年度最骚语言"></a><a href="https://github.com/LingDong-/wenyan-lang" target="_blank" rel="noopener">文言文编程语言，可谓年度最骚语言</a></h4><blockquote><p>Github上一周左右斩获一万多星的项目。<br>这是一位卡内基梅隆大学（CMU）的大四学生开发。利用 NLP 的一些技术，将文言文程序语法转换到 JavaScript 或 Python 运行，并不是简单的将程序中的英文字符换成了中文。</p></blockquote><h4 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a><a href="https://www.liugezhou.online/2019/12/16/No7.%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8/" target="_blank" rel="noopener">浏览器安全</a></h4><blockquote><p>前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。<br>本篇是这个专栏的第七章，也是最后一章：<a href="https://www.liugezhou.online/2019/12/16/No7.%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8/" target="_blank" rel="noopener">浏览器安全</a>。本章分为六讲。    </p><p>本章主要从Web页面安全、浏览器系统安全、浏览器网络安全三块内容展开。   </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这里记录过去一周，我的一些小总结。&lt;br&gt; &lt;img src=&quot;http://img.liugezhou.online/weekly24.jpeg&quot; alt=&quot;weekly-24&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="每周分享" scheme="http://liugezhou.online/categories/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="每周分享" scheme="http://liugezhou.online/tags/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>No7.浏览器安全</title>
    <link href="http://liugezhou.online/2019/12/16/No7.%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8/"/>
    <id>http://liugezhou.online/2019/12/16/No7.浏览器安全/</id>
    <published>2019-12-16T12:40:00.000Z</published>
    <updated>2019-12-20T07:05:54.154Z</updated>
    
    <content type="html"><![CDATA[<h6 id="前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。"><a href="#前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。" class="headerlink" title="前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。"></a>前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。</h6><h6 id="本篇是这个专栏的最后一章：《浏览器安全》。本章分为六节。"><a href="#本篇是这个专栏的最后一章：《浏览器安全》。本章分为六节。" class="headerlink" title="本篇是这个专栏的最后一章：《浏览器安全》。本章分为六节。"></a>本篇是这个专栏的最后一章：《浏览器安全》。本章分为六节。</h6><a id="more"></a><h4 id="32-同源策略：为什么XMLHttpRequest不能跨域请求资源？"><a href="#32-同源策略：为什么XMLHttpRequest不能跨域请求资源？" class="headerlink" title="32 | 同源策略：为什么XMLHttpRequest不能跨域请求资源？"></a>32 | 同源策略：为什么XMLHttpRequest不能跨域请求资源？</h4><hr><blockquote><p>浏览器安全可以分为三大块–Web页面安全、浏览器网络安全、浏览器系统安全。<br>本节来分析页面中的安全策略。  </p><p>在没有安全保障的 Web 世界中，我们是没有隐私的，因此需要安全策略来保障我们的隐私和数据的安全。这就引出了页面中最基础、最核心的安全策略：<code>同源策略（Same-origin policy）</code>。</p></blockquote><h5 id="什么是同源策略"><a href="#什么是同源策略" class="headerlink" title="什么是同源策略"></a>什么是同源策略</h5><hr><blockquote><p>如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL 同源.<br>浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，我们把这称为同源策略。<br>具体来讲，同源策略主要表现在 DOM、Web 数据和网络这三个层面。  </p><ul><li>第一个：DOM层面。同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。    </li><li>第二个：数据层面。同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。   </li><li>第三个，网络层面。同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。</li></ul></blockquote><h5 id="安全和便利性的权衡"><a href="#安全和便利性的权衡" class="headerlink" title="安全和便利性的权衡"></a>安全和便利性的权衡</h5><hr><blockquote><p>浏览器出让了同源策略的一些安全性。    </p></blockquote><h6 id="1-页面中可以嵌入第三方资源"><a href="#1-页面中可以嵌入第三方资源" class="headerlink" title="1. 页面中可以嵌入第三方资源"></a>1. 页面中可以嵌入第三方资源</h6><blockquote><p>页面中可以嵌入第三方资源，但是却有可能嵌入的是恶意代码，恶意读取Cookie等数据，于是浏览器中引入了内容安全策略，称为CSP。<br>CSP 的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码。</p></blockquote><h6 id="2-跨域资源共享和跨文档消息机制"><a href="#2-跨域资源共享和跨文档消息机制" class="headerlink" title="2. 跨域资源共享和跨文档消息机制"></a>2. 跨域资源共享和跨文档消息机制</h6><blockquote><p>为了解决不同源的资源不能共享问题，引入了<code>跨域资源共享(CORS)</code>，使用该机制可以进行跨域访问控制，从而使跨域数据传输得以安全进行。<br>在介绍同源策略时，我们说明了如果两个页面不是同源的，则无法相互操纵 DOM。不过在实际应用中，经常需要两个不同源的 DOM 之间进行通信，于是浏览器中又引入了跨文档消息机制，可以通过 window.postMessage 的 JavaScript 接口来和不同源的 DOM 进行通信。    </p></blockquote><h4 id="33-跨站脚本攻击-XSS-为什么Cookie中有HttpOnly属性？"><a href="#33-跨站脚本攻击-XSS-为什么Cookie中有HttpOnly属性？" class="headerlink" title="33 | 跨站脚本攻击(XSS):为什么Cookie中有HttpOnly属性？"></a>33 | 跨站脚本攻击(XSS):为什么Cookie中有HttpOnly属性？</h4><hr><blockquote><p>通过上一节我们知道：同源策略可以隔离各个站点之间的 DOM 交互、页面数据和网络通信，虽然严格的同源策略会带来更多的安全，但是也束缚了 Web。这就需要在安全和自由之间找到一个平衡点，所以我们默认页面中可以引用任意第三方资源，然后又引入 CSP 策略来加以限制；默认 XMLHttpRequest 和 Fetch 不能跨站请求资源，然后又通过 CORS 策略来支持其跨域。不过支持页面中的第三方资源引用和 CORS 也带来了很多安全问题，其中最典型的就是 XSS 攻击。  </p></blockquote><h5 id="什么是XSS攻击"><a href="#什么是XSS攻击" class="headerlink" title="什么是XSS攻击"></a>什么是XSS攻击</h5><blockquote><p>XSS 全称是 Cross Site Scripting，为了与“CSS”区分开来，故简称 XSS，翻译过来就是“跨站脚本”。XSS 攻击是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。<br>恶意脚本可以做哪些事情呢？    </p><ul><li>可以获取Cookie消息。    </li><li>可以监听用户行为。  </li><li>可以通过修改DOM伪造假的登录窗口，用来欺骗用户输入用户名和密码等信息。   </li><li>还可以在页面内生成浮窗广告。    </li></ul></blockquote><h5 id="恶意脚本是怎么注入的"><a href="#恶意脚本是怎么注入的" class="headerlink" title="恶意脚本是怎么注入的"></a>恶意脚本是怎么注入的</h5><blockquote><p>常见的注入方式有：存储型XSS攻击、反射型XSS攻击、基于DOM的XSS攻击。    </p></blockquote><h5 id="如何阻止XSS攻击"><a href="#如何阻止XSS攻击" class="headerlink" title="如何阻止XSS攻击"></a>如何阻止XSS攻击</h5><blockquote><ol><li>服务器对输入脚本进行过滤或转码。   </li><li>充分利用CSP。  </li><li>使用 HttpOnly 属性。   </li></ol></blockquote><h4 id="34-CSRF攻击：陌生链接不要点"><a href="#34-CSRF攻击：陌生链接不要点" class="headerlink" title="34 | CSRF攻击：陌生链接不要点"></a>34 | CSRF攻击：陌生链接不要点</h4><hr><blockquote><p>在上一节中我们简单了解了 XSS 攻击，XSS 的攻击方式是黑客往用户的页面中注入恶意脚本，然后再通过恶意脚本将用户页面的数据上传到黑客的服务器上，最后黑客再利用这些数据进行一些恶意操作。XSS 攻击能够带来很大的破坏性，不过另外一种类型的攻击也不容忽视，它就是 CSRF 攻击。 </p></blockquote><h5 id="什么是CSRF攻击"><a href="#什么是CSRF攻击" class="headerlink" title="什么是CSRF攻击"></a>什么是CSRF攻击</h5><blockquote><p>CSRF 英文全称是 Cross-site request forgery，所以又称为“跨站请求伪造”，是指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。简单来讲，CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事。     </p><p>黑客有三种方式实施CSRF攻击：  </p><ul><li>自动发起Get请求。   </li><li>自动发起POST请求。  </li><li>引诱用户点击链接。  </li></ul><p>和 XSS 不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。</p></blockquote><h5 id="如何防止CSRF攻击"><a href="#如何防止CSRF攻击" class="headerlink" title="如何防止CSRF攻击"></a>如何防止CSRF攻击</h5><blockquote><p>发起 CSRF 攻击的三个必要条件：    </p><ul><li>第一个，目标站点一定要有 CSRF 漏洞；    </li><li>第二个，用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态；    </li><li>第三个，需要用户打开一个第三方站点，可以是黑客的站点，也可以是一些论坛。    </li></ul><p>要让服务器避免遭受到 CSRF 攻击，通常有以下几种途径:   </p><ol><li>充分利用好Cookie的SameSite属性。SameSite选项通常有Strict、Lax、None三个值。    </li></ol><ul><li>Strict最为严格，举个例子，黑客从他的网站去去访问你网站的资源，如果你的网站的某些Cookie设置了SamteSite = Strict，那么在黑客网站上的Cookie是不会发送到你的网站上的，只有你从你的站点去请求你站点的资源，才会带上这些Cookie。  </li><li>Lax相对宽松，在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。但如果在第三方站点中使用 Post 方法，或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。 </li><li>而如果使用 None 的话，在任何情况下都会发送 Cookie 数据。</li></ul><ol start="2"><li><p>验证请求的来源站点<br>服务器可以禁止来自第三方站点的请求。那么该怎么判断请求是否来自第三方站点呢？这里介绍的是HTTP请求头中的Referer和Origin属性。<br><code>Referer</code>是HTTP请求头中的一个字段，记录了该HTTP请求的来源地址,会包含具体的 URL 路径。<br>虽然可以通过 Referer 告诉服务器 HTTP 请求的来源，但是有一些场景是不适合将来源 URL 暴露给服务器的，因此浏览器提供给开发者一个选项，可以不用上传 Referer 值，具体可参考 Referrer Policy。<br>但在服务器端验证请求头中的 Referer 并不是太可靠，因此标准委员会又制定了 <code>Origin</code>属性，在一些重要的场合，比如通过 XMLHttpRequest、Fecth 发起跨站请求或者通过 Post 方法发送请求时，都会带上 Origin 属性.<br>Origin 属性只包含了域名信息，并没有包含具体的 URL 路径.   </p></li><li><p>CSRF Token<br>第一步，在浏览器向服务器发起请求时，服务器生成一个 CSRF Token。CSRF Token 其实就是服务器生成的字符串，然后将该字符串植入到返回的页面中。<br>第二步，在浏览器端如果要发起转账的请求，那么需要带上页面中的 CSRF Token，然后服务器会验证该 Token 是否合法。如果是从第三方站点发出的请求，那么将无法获取到 CSRF Token 的值，所以即使发出了请求，服务器也会因为 CSRF Token 不正确而拒绝请求。  </p></li></ol></blockquote><h4 id="35-安全沙箱：页面和系统之间的隔离墙"><a href="#35-安全沙箱：页面和系统之间的隔离墙" class="headerlink" title="35 | 安全沙箱：页面和系统之间的隔离墙"></a>35 | 安全沙箱：页面和系统之间的隔离墙</h4><hr><h5 id="安全视角下的多进程架构"><a href="#安全视角下的多进程架构" class="headerlink" title="安全视角下的多进程架构"></a>安全视角下的多进程架构</h5><blockquote><p>我们通过学习第一节《宏观视角下的浏览器》，了解了浏览器的发展史以及架构的演变，这节是从操作系统安全的视角来看浏览器的多进程架构的。<br>浏览器是被划分为<code>浏览器内核</code>和<code>渲染内核</code>两个核心模块，其中浏览器内核是由网络进程、浏览器主进程和GPU主进程组成的。渲染内核就是渲染进程。这两个模块通过IPC来通信。<br>浏览器多进程架构的设计不单单是为了增加其稳定性，重要的一点也是因为从安全角度去考虑、设计的。   </p></blockquote><h5 id="安全沙箱"><a href="#安全沙箱" class="headerlink" title="安全沙箱"></a>安全沙箱</h5><blockquote><p>基于安全原因(主要是为防止危险资源获取系统权限)，在渲染进程和操作系统之间建了一道墙，即便渲染进程由于存在漏洞被黑客攻击，但由于这道墙，黑客就获取不到渲染进程之外的任何操作权限。将渲染进程和操作系统隔离的这道墙就是安全沙箱。<br>浏览器中的安全沙箱是利用操作系统提供的安全技术，让渲染进程在执行过程中无法访问或者修改操作系统中的数据，在渲染进程需要访问系统资源的时候，需要通过浏览器内核来实现，然后将访问的结果通过 IPC 转发给渲染进程。<br>安全沙箱最小的保护单位是进程。因为单进程浏览器需要频繁访问或者修改操作系统的数据，所以单进程浏览器是无法被安全沙箱保护的，而现代浏览器采用的多进程架构使得安全沙箱可以发挥作用。  </p></blockquote><h4 id="36-｜-HTTPS：让数据传输更安全"><a href="#36-｜-HTTPS：让数据传输更安全" class="headerlink" title="36 ｜ HTTPS：让数据传输更安全"></a>36 ｜ HTTPS：让数据传输更安全</h4><hr><blockquote><p>浏览器安全主要分为三大块内容：页面安全、系统安全、网络完全，本节主要学习网络安全。</p><p>我们使用 HTTP 传输的内容很容易被中间人窃取、伪造和篡改，通常我们把这种攻击方式称为中间人攻击。<br>具体来讲，在将HTTP数据提交给TCP后，数据会经过用户电脑、WIFI路由器、运营商和目标服务器，在这中间的每个环节中，数据都有可能被窃取或篡改。</p></blockquote><h5 id="在HTTP协议栈中引入安全层"><a href="#在HTTP协议栈中引入安全层" class="headerlink" title="在HTTP协议栈中引入安全层"></a>在HTTP协议栈中引入安全层</h5><blockquote><p><img src="https://static001.geekbang.org/resource/image/9e/cf/9e99f797de30a15a11b0e4b4c8f810cf.png" alt="HTTP VS HTTPS"><br>安全层有两个主要的职责：对发起 HTTP 请求的数据进行加密操作和对接收到 HTTP 的内容进行解密操作.<br>我们知道了安全层最重要的就是加解密，那么接下来我们就利用这个安全层，一步一步实现一个从简单到复杂的 HTTPS 协议。  </p><h6 id="第一版-使用对称加密"><a href="#第一版-使用对称加密" class="headerlink" title="第一版:使用对称加密"></a>第一版:使用对称加密</h6><p>提到加密，最简单的方式是使用对称加密。所谓对称加密是指加密和解密都使用的是相同的密钥。<br>将对称加密加到安全层后，实现了第一版的对称加密，但是其中传输的client-random和server-client的过程都是明文，所以黑客其实也是可以拿到并篡改的，因此此数据依然可以破解。  </p><h6 id="第二版：使用非对称加密"><a href="#第二版：使用非对称加密" class="headerlink" title="第二版：使用非对称加密"></a>第二版：使用非对称加密</h6><p>含义：和对称加密只有一个密钥不同，非对称加密算法有 A、B 两把密钥，如果你用 A 密钥来加密，那么只能使用 B 密钥来解密；反过来，如果你要 B 密钥来加密，那么只能用 A 密钥来解密。</p><h6 id="第三版：对称加密和非对称加密搭配使用"><a href="#第三版：对称加密和非对称加密搭配使用" class="headerlink" title="第三版：对称加密和非对称加密搭配使用"></a>第三版：对称加密和非对称加密搭配使用</h6><p>最终选择了一个更加完美的方案，那就是在传输数据阶段依然使用对称加密，但是对称加密的密钥我们采用非对称加密来传输.   </p><h6 id="第四版：添加数字证书"><a href="#第四版：添加数字证书" class="headerlink" title="第四版：添加数字证书"></a>第四版：添加数字证书</h6><p>为了防止黑客通过DNS劫持将用户目标官网的IP地址进行更换，而需添加数字证书，该证书是服务器向浏览器证明“我”就是“我”。 </p></blockquote><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><blockquote><p>由于 HTTP 的明文传输特性，在传输过程中的每一个环节，数据都有可能被窃取或者篡改，这倒逼着我们需要引入加密机制。<br>于是我们在 HTTP 协议栈的 TCP 和 HTTP 层之间插入了一个安全层，负责数据的加密和解密操作。<br>我们使用对称加密实现了安全层，但是由于对称加密的密钥需要明文传输，所以我们又将对称加密改造成了非对称加密。<br>但是非对称加密效率低且不能加密服务器到浏览器端的数据，于是我们又继续改在安全层，采用对称加密的方式加密传输数据和非对称加密的方式来传输密钥，这样我们就解决传输效率和两端数据安全传输的问题。<br>采用这种方式虽然能保证数据的安全传输，但是依然没办法证明服务器是可靠的，于是又引入了数字证书，数字证书是由 CA 签名过的，所以浏览器能够验证该证书的可靠性。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot;&gt;&lt;a href=&quot;#前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot; class=&quot;headerlink&quot; title=&quot;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot;&gt;&lt;/a&gt;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&lt;/h6&gt;&lt;h6 id=&quot;本篇是这个专栏的最后一章：《浏览器安全》。本章分为六节。&quot;&gt;&lt;a href=&quot;#本篇是这个专栏的最后一章：《浏览器安全》。本章分为六节。&quot; class=&quot;headerlink&quot; title=&quot;本篇是这个专栏的最后一章：《浏览器安全》。本章分为六节。&quot;&gt;&lt;/a&gt;本篇是这个专栏的最后一章：《浏览器安全》。本章分为六节。&lt;/h6&gt;
    
    </summary>
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>每周总结第二十三期</title>
    <link href="http://liugezhou.online/2019/12/15/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89%E6%9C%9F/"/>
    <id>http://liugezhou.online/2019/12/15/每周总结第二十三期/</id>
    <published>2019-12-15T15:08:00.000Z</published>
    <updated>2019-12-16T03:01:55.118Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这里记录过去一周，我的一些小总结。<br> <img src="http://img.liugezhou.online/weekly23.jpeg" alt="weekly-23"></p></blockquote><a id="more"></a><h4 id="Feeling"><a href="#Feeling" class="headerlink" title="Feeling"></a>Feeling</h4><blockquote><p>周末去参加了两个群体聚会，本来是有很多的感受的，但是由于本性是善于遗忘，这篇周总结拖沓了一些，什么感受不感受的也都忘光了。  </p></blockquote><h4 id="普法-如果你被裁员，赔偿金是N、N-1、2N呢？"><a href="#普法-如果你被裁员，赔偿金是N、N-1、2N呢？" class="headerlink" title="普法 | 如果你被裁员，赔偿金是N、N+1、2N呢？"></a><a href="https://mp.weixin.qq.com/s/uFUhMlittAbNDcHWjLeZLA" target="_blank" rel="noopener">普法 | 如果你被裁员，赔偿金是N、N+1、2N呢？</a></h4><blockquote><p>最近几个大厂闹了不少事情，各家对裁员的赔偿金额不尽相同，导致很多朋友有所疑惑：到底裁员应该赔偿多少？又一波科普《劳动合同法》的。</p></blockquote><h4 id="二师兄法力无边–CPI破4"><a href="#二师兄法力无边–CPI破4" class="headerlink" title="二师兄法力无边–CPI破4"></a><a href="https://mp.weixin.qq.com/s/DIxLlp9cbrcKm47WQX6oyQ" target="_blank" rel="noopener">二师兄法力无边–CPI破4</a></h4><blockquote><p>据国家统计局发布的数据，11月份全国CPI（居民消费价格指数）同比上涨4.5%，连续9个月涨幅扩大.上一次CPI处在4%以上的高位，还是7年多前.那一轮通胀周期始于2010年下半年，直到2012年初才缓解.<br>猪肉是测算CPI的一篮子商品中权重最大的单品（约占2.5%），对CPI的拉动效果极为明显。</p></blockquote><h4 id="Chrome79发布"><a href="#Chrome79发布" class="headerlink" title="Chrome79发布"></a><a href="https://mp.weixin.qq.com/s/MEV6YhBUcpT82VryKsezgg" target="_blank" rel="noopener">Chrome79发布</a></h4><blockquote><p>Google 发布了适用于 Windows、Mac、Linux、Chrome OS、Android 和 iOS 用户的 Chrome 79。</p><p>Chrome 79 是 2019 年最后一次特性更新。自今年秋天初以来，Chrome 79 一直处在开发中，并于 10 月底进入 Beta 测试。Chrome 79 的更改主要面向开发人员，但安全浏览和内置密码检查工具方面也已有一些改进。</p></blockquote><h4 id="WebAssembly"><a href="#WebAssembly" class="headerlink" title="WebAssembly"></a><a href="https://mp.weixin.qq.com/s/XxdrxkU5ZZKX4kcqIIXIQw" target="_blank" rel="noopener">WebAssembly</a></h4><blockquote><p>2019年的12月5日，WebAssembly(简称WASM) ，被W3C推荐为正式标准，这是继html、css、javascript之后的第4门web语言，同时为Web带来一种支持代码在浏览器中运行的新语言.<br>通过即时编译或解析，WebAssembly引擎可以接近原生平台的速度执行代码编译。   </p><p>关于明年的前端发展趋势，该作者给出以下几点的预测:</p><ol><li>WebAssembly变得越来越普遍，得到了实际采用，并被用于产品中。        </li><li>GraphQL在新的创业公司和新项目上超过了REST，而老牌公司则向其迁移。      </li><li>TypeScript成为创业公司和新项目的默认选择。           </li><li>CSS-in-JS可能会成为默认的样式设置方法，而不是普通的CSS。     </li><li>Flutter可能会取代React Native成为构建跨平台移动应用的最佳方式。 </li></ol></blockquote><h4 id="themostdangerouswritingapp"><a href="#themostdangerouswritingapp" class="headerlink" title="themostdangerouswritingapp"></a><a href="https://github.com/maebert/themostdangerouswritingapp" target="_blank" rel="noopener">themostdangerouswritingapp</a></h4><blockquote><p>最危险的应用写作程序。<br>一旦你开始写作，那就不要停，必须时刻不停的打字。一旦停下（5秒倒计时），便立刻把先前写的所有内容删得一干二净。</p><p>体验地址：<a href="http://www.themostdangerouswritingapp.com" target="_blank" rel="noopener">http://www.themostdangerouswritingapp.com</a></p></blockquote><h4 id="Github或正式登录中国"><a href="#Github或正式登录中国" class="headerlink" title="Github或正式登录中国"></a>Github或正式登录中国</h4><blockquote><p>2019年12月10日，据英国《金融时报》报道， 全球最大程序员交友平台 GitHub <code>渴望</code>在中国开子公司。</p></blockquote><h4 id="力扣"><a href="#力扣" class="headerlink" title="力扣"></a><a href="https://leetcode-cn.com/" target="_blank" rel="noopener">力扣</a></h4><blockquote><p>力扣（LeetCode）上的题目已经有 1000+ 了。一目了然的题目分类力扣的题覆盖面极大，目前已有 1000+ 公开题目资源，涉及了许多算法与数据结构，有贪心，搜索，动态规划，链表，二叉树，哈希表等。<br>如果你是一名程序员，力扣一定要提前准备起来。</p></blockquote><h4 id="浏览器中的网络"><a href="#浏览器中的网络" class="headerlink" title="浏览器中的网络"></a><a href="https://www.liugezhou.online/2019/12/10/No6.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C/" target="_blank" rel="noopener">浏览器中的网络</a></h4><blockquote><p>前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。<br>本篇是这个专栏的第六章：<a href="https://www.liugezhou.online/2019/12/10/No6.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C/" target="_blank" rel="noopener">浏览器中的网络</a>。本章分为三讲。    </p><p>这三讲从浏览器的视角对HTTP的历史演进，进行了整体介绍，分别是即将完成使命的HTTP/1，正在我们走向的HTTP/2，以及未来的HTTP/3.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这里记录过去一周，我的一些小总结。&lt;br&gt; &lt;img src=&quot;http://img.liugezhou.online/weekly23.jpeg&quot; alt=&quot;weekly-23&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="每周分享" scheme="http://liugezhou.online/categories/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="每周分享" scheme="http://liugezhou.online/tags/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>No6.浏览器中的网络</title>
    <link href="http://liugezhou.online/2019/12/10/No6.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C/"/>
    <id>http://liugezhou.online/2019/12/10/No6.浏览器中的网络/</id>
    <published>2019-12-10T12:40:00.000Z</published>
    <updated>2019-12-10T07:15:46.027Z</updated>
    
    <content type="html"><![CDATA[<h6 id="谈及浏览器中的网络，就避不开-HTTP。我们知道-HTTP-是浏览器中最重要且使用最多的协议，是浏览器和服务器之间的通信语言，也是互联网的基石。而随着浏览器的发展，HTTP-为了能适应新的形式也在持续进化，学习-HTTP-的最佳途径就是了解其发展史，所以在接下来的三节文章中，从浏览器发展的视角来学习-HTTP-演进。这三节分别是即将完成使命的-HTTP-1、正在向我们走来的-HTTP-2，以及未来的-HTTP-3。"><a href="#谈及浏览器中的网络，就避不开-HTTP。我们知道-HTTP-是浏览器中最重要且使用最多的协议，是浏览器和服务器之间的通信语言，也是互联网的基石。而随着浏览器的发展，HTTP-为了能适应新的形式也在持续进化，学习-HTTP-的最佳途径就是了解其发展史，所以在接下来的三节文章中，从浏览器发展的视角来学习-HTTP-演进。这三节分别是即将完成使命的-HTTP-1、正在向我们走来的-HTTP-2，以及未来的-HTTP-3。" class="headerlink" title="谈及浏览器中的网络，就避不开 HTTP。我们知道 HTTP 是浏览器中最重要且使用最多的协议，是浏览器和服务器之间的通信语言，也是互联网的基石。而随着浏览器的发展，HTTP 为了能适应新的形式也在持续进化，学习 HTTP 的最佳途径就是了解其发展史，所以在接下来的三节文章中，从浏览器发展的视角来学习 HTTP 演进。这三节分别是即将完成使命的 HTTP/1、正在向我们走来的 HTTP/2，以及未来的 HTTP/3。"></a>谈及浏览器中的网络，就避不开 HTTP。我们知道 HTTP 是浏览器中最重要且使用最多的协议，是浏览器和服务器之间的通信语言，也是互联网的基石。而随着浏览器的发展，HTTP 为了能适应新的形式也在持续进化，学习 HTTP 的最佳途径就是了解其发展史，所以在接下来的三节文章中，从浏览器发展的视角来学习 HTTP 演进。这三节分别是即将完成使命的 HTTP/1、正在向我们走来的 HTTP/2，以及未来的 HTTP/3。</h6><a id="more"></a><h4 id="29-HTTP-1：HTTP性能优化"><a href="#29-HTTP-1：HTTP性能优化" class="headerlink" title="29 | HTTP/1：HTTP性能优化"></a>29 | HTTP/1：HTTP性能优化</h4><hr><blockquote><p>本文主要介绍的是 HTTP/1.1，我们先来学习下 HTTP/1.1 的进化史，然后再介绍在进化过程中所遇到的各种瓶颈，以及对应的解决方法。 </p></blockquote><h5 id="超文本传输协议HTTP-0-9"><a href="#超文本传输协议HTTP-0-9" class="headerlink" title="超文本传输协议HTTP/0.9"></a>超文本传输协议HTTP/0.9</h5><blockquote><p>HTTP/0.9 是于 1991 年提出的，主要用于学术交流，需求很简单——用来在网络之间传递<code>HTML 超文本</code>的内容，所以被称为<code>超文本传输协议</code>。<br>HTTP/0.9 的实现有以下三个特点:    </p><ul><li>第一个是只有一个请求行，并没有 HTTP 请求头和请求体，因为只需要一个请求行就可以完整表达客户端的需求了。  </li><li>第二个是服务器也没有返回头信息，这是因为服务器端并不需要告诉客户端太多信息，只需要返回数据就可以了。    </li><li>第三个是返回的文件内容是以 ASCII 字符流来传输的，因为都是 HTML 格式的文件，所以使用 ASCII 字节码来传输是最合适的。  </li></ul></blockquote><h5 id="被浏览器推动的HTTP-1-0"><a href="#被浏览器推动的HTTP-1-0" class="headerlink" title="被浏览器推动的HTTP/1.0"></a>被浏览器推动的HTTP/1.0</h5><blockquote><p>变化是这个世界永恒不变的主旋律，1994 年底出现了拨号上网服务，同年网景又推出一款浏览器，从此万维网就不局限于学术交流了，而是进入了高速的发展阶段。<br>万维网的高速发展带来了很多新的需求，而 HTTP/0.9 已经不能适用新兴网络的发展，所以这时就需要一个新的协议来支撑新兴网络，这就是 HTTP/1.0 诞生的原因。</p></blockquote><blockquote><p>新兴网络带来了新的需求：首先在浏览器中展示的不单是 HTML 文件了，还包括了 JavaScript、CSS、图片、音频、视频等不同类型的文件。因此支持多种类型的文件下载是 HTTP/1.0 的一个核心诉求，而且文件格式不仅仅局限于 ASCII 编码，还有很多其他类型编码的文件。   </p></blockquote><blockquote><p>为了让客户端和服务器能更深入地交流，HTTP/1.0 引入了<code>请求头</code>和<code>响应头</code>，它们都是以为 Key-Value 形式保存的，在 HTTP 发送请求时，会带上请求头信息，服务器返回数据时，会先返回响应头信息。<br>HTTP/1.0 的方案是通过请求头和响应头来进行协商，在发起请求时候会通过 HTTP 请求头告诉服务器它期待服务器返回什么类型的文件、采取什么形式的压缩、提供什么语言的文件以及文件的具体编码。</p></blockquote><h5 id="缝缝补补的HTTP-1-1"><a href="#缝缝补补的HTTP-1-1" class="headerlink" title="缝缝补补的HTTP/1.1"></a>缝缝补补的HTTP/1.1</h5><blockquote><p>技术继续发展、需求不断迭代更新，HTTP/1.0也不能满足需求了，HTTP/1.1又在HTTP/1.0上继续更新：</p></blockquote><h6 id="改进持久连接"><a href="#改进持久连接" class="headerlink" title="改进持久连接"></a>改进持久连接</h6><blockquote><p>HTTP/1.1 中增加了持久连接的方法，它的特点是在一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持。<br>HTTP 的持久连接可以有效减少 TCP 建立连接和断开连接的次数，这样的好处是减少了服务器额外的负担，并提升整体 HTTP 的请求时长。<br>持久连接在 HTTP/1.1 中是默认开启的，所以你不需要专门为了持久连接去 HTTP 请求头设置信息，如果你不想要采用持久连接，可以在 HTTP 请求头中加上Connection: close。目前浏览器中对于同一个域名，默认允许同时建立 6 个 TCP 持久连接.  </p></blockquote><h6 id="不成熟的HTTP管线化"><a href="#不成熟的HTTP管线化" class="headerlink" title="不成熟的HTTP管线化"></a>不成熟的HTTP管线化</h6><blockquote><p>如果 TCP 通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后面的所有请求，这就是著名的队头阻塞的问题。<br>HTTP/1.1 中试图通过管线化的技术来解决队头阻塞的问题。HTTP/1.1 中的管线化是指将多个 HTTP 请求整批提交给服务器的技术，虽然可以整批发送请求，不过服务器依然需要根据请求顺序来回复浏览器的请求。<br>FireFox、Chrome 都做过管线化的试验，但是由于各种原因，它们最终都放弃了管线化技术. </p></blockquote><h6 id="提供虚拟主机的支持"><a href="#提供虚拟主机的支持" class="headerlink" title="提供虚拟主机的支持"></a>提供虚拟主机的支持</h6><blockquote><p>在 HTTP/1.0 中，每个域名绑定了一个唯一的 IP 地址，因此一个服务器只能支持一个域名。<br>但是随着虚拟主机技术的发展，需要实现在一台物理主机上绑定多个虚拟主机，每个虚拟主机都有自己的单独的域名，这些单独的域名都公用同一个 IP 地址。<br>因此，HTTP/1.1 的请求头中增加了 Host 字段，用来表示当前的域名地址，这样服务器就可以根据不同的 Host 值做不同的处理。</p></blockquote><h6 id="对动态生成的内容提供了完美的支持"><a href="#对动态生成的内容提供了完美的支持" class="headerlink" title="对动态生成的内容提供了完美的支持"></a>对动态生成的内容提供了完美的支持</h6><blockquote><p>在设计 HTTP/1.0 时，需要在响应头中设置完整的数据大小，如Content-Length: 901，这样浏览器就可以根据设置的数据大小来接收数据。<br>不过随着服务器端的技术发展，很多页面的内容都是动态生成的，因此在传输数据之前并不知道最终的数据大小，这就导致了浏览器不知道何时会接收完所有的文件数据。<br>HTTP/1.1 通过引入 Chunk transfer 机制来解决这个问题，服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。这样就提供了对动态内容的支持。</p></blockquote><h6 id="客户端Cookie、安全机制"><a href="#客户端Cookie、安全机制" class="headerlink" title="客户端Cookie、安全机制"></a>客户端Cookie、安全机制</h6><blockquote><p>除此之外，HTTP/1.1 还引入了客户端 Cookie 机制和安全机制。</p></blockquote><h4 id="30-｜-HTTP-2：如何提升网络速度？"><a href="#30-｜-HTTP-2：如何提升网络速度？" class="headerlink" title="30 ｜ HTTP/2：如何提升网络速度？"></a>30 ｜ HTTP/2：如何提升网络速度？</h4><hr><blockquote><p>HTTP/1.1为网络效率做了大量的优化，最核心的三种方式为：    </p><ul><li>增加了持久连接。    </li><li>浏览器为每个域名最多同时支持6个TCP持久连接。    </li><li>使用CDN的实现域名分片机制。 </li></ul></blockquote><h5 id="HTTP-1-1的主要问题"><a href="#HTTP-1-1的主要问题" class="headerlink" title="HTTP/1.1的主要问题"></a>HTTP/1.1的主要问题</h5><blockquote><p>HTTP/1.1对带宽的利用率却并不理想，这也是 HTTP/1.1 的一个核心问题.<br>带宽是指每秒最大能发送或者接收的字节数。我们把每秒能发送的最大字节数称为上行带宽，每秒能够接收的最大字节数称为下行带宽。  </p></blockquote><blockquote><p>出现宽带利用率不理想的原因，主要为：  </p><ul><li>第一个原因，TCP的慢启动。   </li><li>第二个原因，同时开启了多条TCP连接，那么这些连接会竞争固定的宽带。   </li><li>第三个原因，HTTP/1.1队头阻塞的问题。</li></ul></blockquote><h5 id="HTTP-2的多路复用"><a href="#HTTP-2的多路复用" class="headerlink" title="HTTP/2的多路复用"></a>HTTP/2的多路复用</h5><blockquote><p>HTTP/2 的解决方案可以总结为：一个域名只使用一个 TCP 长连接和消除队头阻塞问题.<br>具体实现就是：通过引入二进制分帧层，实现 HTTP 的多路复用技术。</p></blockquote><h5 id="HTTP-2其他特性"><a href="#HTTP-2其他特性" class="headerlink" title="HTTP/2其他特性"></a>HTTP/2其他特性</h5><blockquote><ul><li>可以设置请求的优先级。  </li><li>服务器推送。    </li><li>头部压缩。  </li></ul></blockquote><blockquote><p>HTTP/2 协议规范于 2015 年 5 月正式发布，在那之后，该协议已在互联网和万维网上得到了广泛的实现和部署。从目前的情况来看，国内外一些排名靠前的站点基本都实现了 HTTP/2 的部署。使用 HTTP/2 能带来 20%～60% 的效率提升，至于 20% 还是 60% 要看优化的程度。总之，我们也应该与时俱进，放弃 HTTP/1.1 和其性能优化方法，去“拥抱”HTTP/2</p></blockquote><h4 id="31-HTTP-3-0-甩掉TCP、TLS的包袱，构建高效网络"><a href="#31-HTTP-3-0-甩掉TCP、TLS的包袱，构建高效网络" class="headerlink" title="31 | HTTP/3.0:甩掉TCP、TLS的包袱，构建高效网络"></a>31 | HTTP/3.0:甩掉TCP、TLS的包袱，构建高效网络</h4><blockquote><p>和通常一样，介绍 HTTP/3 之前，我们先来看看 HTTP/2 到底有什么缺陷。    </p></blockquote><h5 id="1-TCP的队头阻塞"><a href="#1-TCP的队头阻塞" class="headerlink" title="1.TCP的队头阻塞"></a>1.TCP的队头阻塞</h5><blockquote><p>在 TCP 传输过程中，由于单个数据包的丢失而造成的阻塞称为 TCP 上的队头阻塞。<br>有测试数据表明，当系统达到了 2% 的丢包率时，HTTP/1.1 的传输效率反而比 HTTP/2 表现得更好。 </p></blockquote><h5 id="2-TCP建立连接的延时"><a href="#2-TCP建立连接的延时" class="headerlink" title="2.TCP建立连接的延时"></a>2.TCP建立连接的延时</h5><blockquote><p>网络延迟又称为 RTT（Round Trip Time）。我们把从浏览器发送一个数据包到服务器，再从服务器返回数据包到浏览器的整个往返时间称为 RTT。RTT 是反映网络性能的一个重要指标。 </p></blockquote><h5 id="3-TCP协议僵化"><a href="#3-TCP协议僵化" class="headerlink" title="3.TCP协议僵化"></a>3.TCP协议僵化</h5><blockquote><p>虽然我们知道了TCP的队头阻塞和建立连接延时等缺点，但是通过改进TCP协议来解决这些问题非常困难，这里说的非常困难就是指TCP协议僵化。<br>TCP协议僵化体现在两个方面：第一个是中间设备的僵化；除中间设备的僵化外，操作系统也是导致TCP协议僵化的另外一个原因。    </p></blockquote><h5 id="QUIC协议"><a href="#QUIC协议" class="headerlink" title="QUIC协议"></a>QUIC协议</h5><blockquote><p>HTTP/3 选择了一个折衷的方法——UDP 协议，基于 UDP 实现了类似于 TCP 的多路数据流、传输可靠性等功能，我们把这套功能称为 QUIC 协议。<br>HTTP/3 中的 QUIC 协议集合了以下几点功能:</p></blockquote><blockquote><ul><li>实现了类似 TCP 的流量控制、传输可靠性的功能。虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。  </li><li>集成了 TLS 加密功能。   </li><li>实现了 HTTP/2 中的多路复用功能。  </li><li>实现了快速握手功能。    </li></ul></blockquote><h5 id="HTTP-3的挑战"><a href="#HTTP-3的挑战" class="headerlink" title="HTTP/3的挑战"></a>HTTP/3的挑战</h5><blockquote><p>通过上面的分析，我们相信在技术层面，HTTP/3 是个完美的协议。不过要将 HTTP/3 应用到实际环境中依然面临着诸多严峻的挑战，这些挑战主要来自于以下三个方面:  </p><ul><li>第一，从目前的情况来看，服务器和浏览器端都没有对 HTTP/3 提供比较完整的支持。Chrome 虽然在数年前就开始支持 Google 版本的 QUIC，但是这个版本的 QUIC 和官方的 QUIC 存在着非常大的差异。    </li><li>第二，部署 HTTP/3 也存在着非常大的问题。因为系统内核对 UDP 的优化远远没有达到 TCP 的优化程度，这也是阻碍 QUIC 的一个重要原因。  </li><li>第三，中间设备僵化的问题。这些设备对 UDP 的优化程度远远低于 TCP，据统计使用 QUIC 协议时，大约有 3%～7% 的丢包率。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;谈及浏览器中的网络，就避不开-HTTP。我们知道-HTTP-是浏览器中最重要且使用最多的协议，是浏览器和服务器之间的通信语言，也是互联网的基石。而随着浏览器的发展，HTTP-为了能适应新的形式也在持续进化，学习-HTTP-的最佳途径就是了解其发展史，所以在接下来的三节文章中，从浏览器发展的视角来学习-HTTP-演进。这三节分别是即将完成使命的-HTTP-1、正在向我们走来的-HTTP-2，以及未来的-HTTP-3。&quot;&gt;&lt;a href=&quot;#谈及浏览器中的网络，就避不开-HTTP。我们知道-HTTP-是浏览器中最重要且使用最多的协议，是浏览器和服务器之间的通信语言，也是互联网的基石。而随着浏览器的发展，HTTP-为了能适应新的形式也在持续进化，学习-HTTP-的最佳途径就是了解其发展史，所以在接下来的三节文章中，从浏览器发展的视角来学习-HTTP-演进。这三节分别是即将完成使命的-HTTP-1、正在向我们走来的-HTTP-2，以及未来的-HTTP-3。&quot; class=&quot;headerlink&quot; title=&quot;谈及浏览器中的网络，就避不开 HTTP。我们知道 HTTP 是浏览器中最重要且使用最多的协议，是浏览器和服务器之间的通信语言，也是互联网的基石。而随着浏览器的发展，HTTP 为了能适应新的形式也在持续进化，学习 HTTP 的最佳途径就是了解其发展史，所以在接下来的三节文章中，从浏览器发展的视角来学习 HTTP 演进。这三节分别是即将完成使命的 HTTP/1、正在向我们走来的 HTTP/2，以及未来的 HTTP/3。&quot;&gt;&lt;/a&gt;谈及浏览器中的网络，就避不开 HTTP。我们知道 HTTP 是浏览器中最重要且使用最多的协议，是浏览器和服务器之间的通信语言，也是互联网的基石。而随着浏览器的发展，HTTP 为了能适应新的形式也在持续进化，学习 HTTP 的最佳途径就是了解其发展史，所以在接下来的三节文章中，从浏览器发展的视角来学习 HTTP 演进。这三节分别是即将完成使命的 HTTP/1、正在向我们走来的 HTTP/2，以及未来的 HTTP/3。&lt;/h6&gt;
    
    </summary>
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>每周总结第二十二期</title>
    <link href="http://liugezhou.online/2019/12/07/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E6%9C%9F/"/>
    <id>http://liugezhou.online/2019/12/07/每周总结第二十二期/</id>
    <published>2019-12-07T14:08:00.000Z</published>
    <updated>2019-12-08T14:09:36.568Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这里记录过去一周，我的一些小总结。<br><img src="http://img.liugezhou.online/20191206weekly.jpeg" alt="weekly-22"></p></blockquote><a id="more"></a><h4 id="Feeling"><a href="#Feeling" class="headerlink" title="Feeling"></a>Feeling</h4><blockquote><p>推出一个新产品很难，组建一个能够持续推出新产品的团队更难。<br>我最引以为傲的产品，就是苹果公司和我在苹果公司建立的团队。<br><cite>史蒂夫·乔布斯</cite></p></blockquote><h4 id="消费者办手机号全面开启人脸比对"><a href="#消费者办手机号全面开启人脸比对" class="headerlink" title="消费者办手机号全面开启人脸比对"></a>消费者办手机号全面开启人脸比对</h4><blockquote><p>据工信部的相关规定，自12月1日起，电信企业需在实体渠道全面实施人像比对技术措施，人像比对一致方可办理入网手续。<br>这意味着，今后，中国所有注册新SIM卡的手机用户都必须接受面部识别扫描。同时，规定要求电信企业部署“人工智能和其他技术方法”以检查注册SIM卡的人员的身份。<br>今年以来，人脸识别技术在国内出现了一系列的负面新闻，比如曾红极一时的换脸软件——ZAO，还有一位大学教授起诉动物园违规采集面部信息的“中国人脸识别第一案”。这些事件背后，说明中国人脸识别行业缺乏统一标准，管理仍然比较混乱，对用户的隐私保护做得不到位。就像“办手机卡”这件事，已经有一些声音开始担心：电信运营商真的能保证我们的人脸数据不外泄吗,不会用于其他的某方面用途吗？</p></blockquote><h4 id="华为作过的恶"><a href="#华为作过的恶" class="headerlink" title="华为作过的恶"></a><a href="https://github.com/evil-huawei/evil-huawei" target="_blank" rel="noopener">华为作过的恶</a></h4><blockquote><p>Gitub上，本周star数凑凑上涨的一个项目：<br>项目介绍：「由于部分内容被控评和删帖，已经无法在中文互联网搜索到，所以本项目将收集华为作过的恶，记录这些不应该被遗忘的历史。」</p></blockquote><h4 id="一键抠图神器"><a href="#一键抠图神器" class="headerlink" title="一键抠图神器"></a><a href="http://www.picup.ai/#/" target="_blank" rel="noopener">一键抠图神器</a></h4><blockquote><p>识别图像中的人体轮廓，与背景进行分离.有人体抠图和物体抠图。   </p></blockquote><h4 id="沙拉查词"><a href="#沙拉查词" class="headerlink" title="沙拉查词"></a>沙拉查词</h4><blockquote><p>一款浏览器插件，推荐。<br><img src="https://user-gold-cdn.xitu.io/2019/10/21/16dec06bb7790bd3?imageView2/2/w/800/q/85" alt="查词"></p></blockquote><h4 id="Grid-代码生成器"><a href="#Grid-代码生成器" class="headerlink" title="Grid 代码生成器"></a><a href="https://cssgrid-generator.netlify.com/" target="_blank" rel="noopener">Grid 代码生成器</a></h4><blockquote><p>可视化地配置 Grid，你可以设置行与列的个数、指定每个格子的类、长宽占比、行间距与列间距大小等，再一键生成 Grid 的 CSS 代码.<br><img src="https://user-gold-cdn.xitu.io/2019/12/6/16eda0f218272486?imageView2/2/w/800/q/85" alt="演示"></p></blockquote><h4 id="GitHub中文排行榜"><a href="#GitHub中文排行榜" class="headerlink" title="GitHub中文排行榜"></a><a href="https://github.com/kon9chunkit/GitHub-Chinese-Top-Charts" target="_blank" rel="noopener">GitHub中文排行榜</a></h4><blockquote><p>GitHub中文排行榜，帮助你发现高分优秀中文项目、更高效地吸收国人的优秀经验成果；榜单每周更新一次.   </p></blockquote><h4 id="浏览器中的页面"><a href="#浏览器中的页面" class="headerlink" title="浏览器中的页面"></a><a href="https://www.liugezhou.online/2019/12/03/No5.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E9%A1%B5%E9%9D%A2/" target="_blank" rel="noopener">浏览器中的页面</a></h4><blockquote><p>前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。<br>本篇是这个专栏的第四章：<a href="https://www.liugezhou.online/2019/12/03/No5.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E9%A1%B5%E9%9D%A2/" target="_blank" rel="noopener">浏览器中的页面</a>。本章分为八讲。</p></blockquote><h4 id="HTTP请求中的Form-Data和Request-Payload的区别"><a href="#HTTP请求中的Form-Data和Request-Payload的区别" class="headerlink" title="HTTP请求中的Form Data和Request Payload的区别"></a>HTTP请求中的Form Data和Request Payload的区别</h4><blockquote><p>前端开发中经常会用到AJAX发送异步请求，对于POST类型的请求会附带请求数据。而常用的两种传参方式为：Form Data 和 Request Payload。    </p></blockquote><blockquote><p>方式一： Form Data形式<br>当POST请求的请求头里设置Content-Type: application/x-www-form-urlencoded(默认), 参数在请求体以标准的Form Data的形式提交，以&amp;符号拼接，参数格式为key=value&amp;key=value&amp;key=value…<br>方式二：Request Payload形式<br>如果使用AJAX原生POST请求,请求头里设置Content-Type:application/json，请求的参数会显示在Request Payload中，参数格式为JSON格式：{“key”:”value”,”key”:”value”…}，这种方式可读性会更好. 后端可以使用getRequestPayload方法来获取.<br><code>Form Data 和 Request Payload 区别</code><br>如果请求头里设置Content-Type: application/x-www-form-urlencoded，那么这个请求被认为是表单请求，参数出现在Form Data里，格式为key=value&amp;key=value&amp;key=value…<br>原生的AJAX请求头里设置Content-Type:application/json，或者使用默认的请求头Content-Type:text/plain;参数会显示在Request payload块里提交。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这里记录过去一周，我的一些小总结。&lt;br&gt;&lt;img src=&quot;http://img.liugezhou.online/20191206weekly.jpeg&quot; alt=&quot;weekly-22&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="每周分享" scheme="http://liugezhou.online/categories/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="每周分享" scheme="http://liugezhou.online/tags/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>No5.浏览器中的页面</title>
    <link href="http://liugezhou.online/2019/12/03/No5.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E9%A1%B5%E9%9D%A2/"/>
    <id>http://liugezhou.online/2019/12/03/No5.浏览器中的页面/</id>
    <published>2019-12-03T12:40:00.000Z</published>
    <updated>2019-12-06T02:49:13.345Z</updated>
    
    <content type="html"><![CDATA[<h6 id="前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。"><a href="#前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。" class="headerlink" title="前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。"></a>前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。</h6><h6 id="本篇是这个专栏的第五章：《No5-浏览器中的页面》。本章分为八节。"><a href="#本篇是这个专栏的第五章：《No5-浏览器中的页面》。本章分为八节。" class="headerlink" title="本篇是这个专栏的第五章：《No5.浏览器中的页面》。本章分为八节。"></a>本篇是这个专栏的第五章：《No5.浏览器中的页面》。本章分为八节。</h6><a id="more"></a><h4 id="21-｜-Chrome开发者工具：利用网络面板做性能分析"><a href="#21-｜-Chrome开发者工具：利用网络面板做性能分析" class="headerlink" title="21 ｜ Chrome开发者工具：利用网络面板做性能分析"></a>21 ｜ Chrome开发者工具：利用网络面板做性能分析</h4><hr><blockquote><p>本节首先对开发者工具的各个模块进行了一个简单介绍，然后重点讲解的是NetWork面板。<br>网络面板包括：控制器、过滤器、抓图信息、时间线、详细列表和下载信息概要六个区域构成。    </p></blockquote><h5 id="1-控制器"><a href="#1-控制器" class="headerlink" title="1.控制器"></a>1.控制器</h5><blockquote><ul><li>“开始/暂停”抓包。   </li><li>全局搜索。    </li><li>Disable cache:禁止从Cache中加载资源。</li><li>Online按钮：模拟2G/3G 网络，模拟弱网环境。  </li></ul></blockquote><h5 id="2-过滤器"><a href="#2-过滤器" class="headerlink" title="2.过滤器"></a>2.过滤器</h5><blockquote><p>过滤功能。 </p></blockquote><h5 id="3-抓图信息"><a href="#3-抓图信息" class="headerlink" title="3.抓图信息"></a>3.抓图信息</h5><blockquote><p>抓图信息区域，可以用来分析用户等待页面加载时间内所看到的内容，分析用户实际的体验情况。  </p></blockquote><h5 id="4-时间线"><a href="#4-时间线" class="headerlink" title="4.时间线"></a>4.时间线</h5><blockquote><p>时间线，主要用来展示 HTTP、HTTPS、WebSocket 加载的状态和时间的一个关系，用于直观感受页面的加载过程。</p></blockquote><h5 id="5-详细列表"><a href="#5-详细列表" class="headerlink" title="5.详细列表"></a>5.详细列表</h5><blockquote><p>详细记录了每个资源从发起请求到完成请求这中间所有过程的状态，以及最终请求完成的数据信息.<br>Queuing：当浏览器发起一个请求的时候，会有很多原因导致该请求不能被立即执行，而是需要排队等待。<br>Stalled： 在发起连接之前，还有一些原因可能导致连接过程被推迟，这个推迟就表现在面板中的 Stalled 上。<br>Proxy Negotiation:若使用代理服务器，会增加一个此阶段。<br>Waiting (TTFB):通常也称为“第一字节时间”。 TTFB 是反映服务端响应速度的重要指标，对服务器来说，TTFB 时间越短，就说明服务器响应越快。<br>Content Download :这意味着从第一字节时间到接收到全部响应数据所用的时间。  </p></blockquote><h5 id="6-下载信息概要"><a href="#6-下载信息概要" class="headerlink" title="6.下载信息概要"></a>6.下载信息概要</h5><blockquote><p>重点关注 DOMContentLoaded和Load两个事件。 </p><ul><li>DOMContentLoaded:这个事件发生后，说明页面已经构建好DOM了，即DOM需要的HTML、JavaScript、CSS等文件已下载完成了。  </li><li>Load：说明浏览器已经加载了所有的资源(图像、样式等)。    </li></ul></blockquote><h4 id="22-DOM树：JavaScript是如何影响DOM树构建的？"><a href="#22-DOM树：JavaScript是如何影响DOM树构建的？" class="headerlink" title="22 | DOM树：JavaScript是如何影响DOM树构建的？"></a>22 | DOM树：JavaScript是如何影响DOM树构建的？</h4><hr><h5 id="什么是DOM"><a href="#什么是DOM" class="headerlink" title="什么是DOM"></a>什么是DOM</h5><blockquote><p>DOM 是表述 HTML 的内部数据结构，它会将 Web 页面和 JavaScript 脚本连接起来，并过滤一些不安全的内容。   </p></blockquote><h5 id="DOM树如何生成"><a href="#DOM树如何生成" class="headerlink" title="DOM树如何生成"></a>DOM树如何生成</h5><blockquote><p>在渲染引擎内部，有一个叫 HTML 解析器（HTMLParser）的模块，它的职责就是负责将 HTML 字节流转换为 DOM 结构。<br>HTML解析器过程是：网络进程加载了多少数据，HTML解析器便解析多少数据。  </p></blockquote><h5 id="JavaScript是如何影响DOM生成的"><a href="#JavaScript是如何影响DOM生成的" class="headerlink" title="JavaScript是如何影响DOM生成的"></a>JavaScript是如何影响DOM生成的</h5><blockquote><ul><li>在两段 div 中间插入了一段 JavaScript 脚本：当HTML解析器解析到script标签的时候会暂停DOM解析，去执行这段JS脚本。 </li><li>在页面中引入 JavaScript文件：整个执行流程还是一样的，执行到 JavaScript 标签时，暂停整个 DOM 的解析，执行 JavaScript 代码，不过这里执行 JavaScript 时，需要先<code>下载这段 JavaScript 代码</code>。这里需要重点关注<code>下载环境</code>，因为 JavaScript 文件的下载过程会阻塞 DOM 解析(Chrome浏览器做的一个主要优化是预解析操作)。<br>另外也有一些相关的策略：比如使用 CDN 来加速 JavaScript 文件的加载，压缩 JavaScript 文件的体积。如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为<code>异步加载</code>，通过 <code>async</code>或<code>defer</code> 来标记代码.  </li></ul><ol><li>async:使用 async 标志的脚本文件一旦加载完成，会立即执行.    </li><li>defer:使用了 defer 标记的脚本文件，需要在 DOMContentLoaded 事件之前执行.</li></ol></blockquote><blockquote><p>通过上面的分析，我们知道了 JavaScript 会阻塞 DOM 生成，而样式文件又会阻塞 JavaScript 的执行，所以在实际的工程中需要重点关注 JavaScript 文件和样式表文件，使用不当会影响到页面性能的。</p></blockquote><h4 id="23-｜-渲染流水线：CSS如何影响首次加载时的白屏问题"><a href="#23-｜-渲染流水线：CSS如何影响首次加载时的白屏问题" class="headerlink" title="23 ｜ 渲染流水线：CSS如何影响首次加载时的白屏问题"></a>23 ｜ 渲染流水线：CSS如何影响首次加载时的白屏问题</h4><hr><blockquote><p>CSS资源是页面中非常重要的一环，本节首先站在渲染流水线的视角来介绍CSS是如何工作的、然后通过CSS工作流程来分分析性能瓶颈、最后讨论如何减少首次加载时的白屏问题。 </p></blockquote><h5 id="渲染流水线视角下的CSS"><a href="#渲染流水线视角下的CSS" class="headerlink" title="渲染流水线视角下的CSS"></a>渲染流水线视角下的CSS</h5><blockquote><p>首先是发起页面请求，网络进程接收到返回的HTML数据，将其发送给渲染进程，渲染进程解析HTML数据并构建DOM。<br>需要特别注意下，请求 HTML 数据和构建 DOM 中间有一段空闲时间，这个空闲时间有可能成为页面渲染的瓶颈。   </p></blockquote><blockquote><p>前面提到一嘴：Chrome浏览器做的一个主要优化是预解析操作。<br>因此，Chrome开启这个预解析进程后，在遇到JavaScript或CSS文件后，会提前下载这些文件。<br>这里也有一个空闲时间需要注意一下，就是在 DOM 构建结束之后、css 文件还未下载完成的这段时间内，渲染流水线无事可做，因为下一步是合成布局树，而合成布局树需要 CSSOM 和 DOM，所以这里需要等待 CSS 加载结束并解析成 CSSOM。 </p></blockquote><blockquote><p>CSSOM的两个作用： </p><ul><li>提供给 JavaScript 操作样式表的能力. </li><li>为布局树的合成提供基础的样式信息。</li></ul></blockquote><h5 id="影响页面展示的因素以及优化策略"><a href="#影响页面展示的因素以及优化策略" class="headerlink" title="影响页面展示的因素以及优化策略"></a>影响页面展示的因素以及优化策略</h5><blockquote><p>从发起 URL 请求开始，到首次显示页面的内容，在视觉上经历的三个阶段:    </p><ol><li>等请求发出去之后，到提交数据阶段，这时页面展示出来的还是之前页面的内容。   </li><li>提交数据之后渲染进程会创建一个空白页面，我们通常把这段时间称为解析白屏，并等待 CSS 文件和 JavaScript 文件的加载完成，生成 CSSOM 和 DOM，然后合成布局树，最后还要经过一系列的步骤准备首次渲染.  </li><li>等首次渲染完成之后，就开始进入完整页面的生成阶段了，然后页面会一点点被绘制出来。   </li></ol></blockquote><blockquote><p>这里重点关注第二个阶段：<br>该阶段的主要任务包括了：解析 HTML、下载 CSS、下载 JavaScript、生成 CSSOM、执行 JavaScript、生成布局树、绘制页面一系列操作。<br>对应策略：</p><ul><li>通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。    </li><li>但并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。 </li><li>还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 sync 或者 defer。    </li><li>对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。 </li></ul></blockquote><h4 id="24-分层和合成机制：为什么CSS动画比JavaScript高效"><a href="#24-分层和合成机制：为什么CSS动画比JavaScript高效" class="headerlink" title="24 | 分层和合成机制：为什么CSS动画比JavaScript高效"></a>24 | 分层和合成机制：为什么CSS动画比JavaScript高效</h4><hr><blockquote><p>在第五节的时候，我们知道DOM构建成功后还要经历布局、分层、绘制、合成、显示等阶段后才能显示出漂亮的页面。<br>这一节主要讲解的是渲染引擎的分层和合成机制，作者说分层和合成机制代表了浏览器最为先进的合成技术，请注意是<code>最为先进的</code>. </p></blockquote><h5 id="显示器是怎么显示图像的"><a href="#显示器是怎么显示图像的" class="headerlink" title="显示器是怎么显示图像的"></a>显示器是怎么显示图像的</h5><blockquote><p>每个显示器的固定刷新频率通常是60HZ，即每秒更新60张图片，更新的图片都来自显卡中一个叫前缓冲区的地方，，显示器所做的任务很简单，就是每秒固定读取 60 次前缓冲区中的图像，并将读取的图像显示到显示器上。<br>显卡的作用：显卡的职责就是合成新的图像，并将图像保存到后缓冲区中，一旦显卡把合成的图像写到后缓冲区，系统就会让后缓冲区和前缓冲区互换，这样就能保证显示器能读取到最新显卡合成的图像。  </p></blockquote><h5 id="帧-VS-帧率"><a href="#帧-VS-帧率" class="headerlink" title="帧 VS 帧率"></a>帧 VS 帧率</h5><blockquote><p>渲染流水线生成的每一张图片称为一帧，渲染流水线每秒更新了多少帧称为帧率。  </p></blockquote><h5 id="如何生成一帧图像"><a href="#如何生成一帧图像" class="headerlink" title="如何生成一帧图像"></a>如何生成一帧图像</h5><blockquote><p>生成一帧图像有三种方式：重排、重绘、合成。 这三种方式的渲染路径不同，通常渲染路径越长，生成图像花费的时间越久。<br>这里聚焦点在合成上 ，为了提升每帧的渲染效率，Chrome 引入了分层和合成的机制，Chrome的合成技术用三个词来概括：分层、分块、合成。</p></blockquote><h5 id="分层和合成"><a href="#分层和合成" class="headerlink" title="分层和合成"></a>分层和合成</h5><blockquote><p>你可以把一张网页想象成是由很多个图片叠加在一起的，每个图片就对应一个图层，将素材分解为多个图层的操作就称为分层。最后将这些图层合并到一起的操作就称为合成。<br>在Chrome渲染流水线中，分层体现在生成布局树之后，渲染引擎根据布局树的特点将其转化为层树，层树是渲染流水线后续流程的基础结构。<br>需要重点关注的是，合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的。这就是为什么经常主线程卡住了，但是 CSS 动画依然能执行的原因。</p></blockquote><h5 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h5><blockquote><p>如果说分层是从宏观上提升了渲染效率，那么分块则是从微观层面提升了渲染效率。<br>在首次合成图块的时候使用一个低分辨率的图片。</p></blockquote><h5 id="如何利用分层技术优化代码"><a href="#如何利用分层技术优化代码" class="headerlink" title="如何利用分层技术优化代码"></a>如何利用分层技术优化代码</h5><blockquote><p>在写 Web 应用的时候，你可能经常需要对某个元素做几何形状变换、透明度变换或者一些缩放操作，如果使用 JavaScript 来写这些效果，会牵涉到整个渲染流水线，所以 JavaScript 的绘制效率会非常低下.<br>这时你可以使用 will-change 来告诉渲染引擎你会对该元素做一些特效变换，CSS 代码如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    will-change: transform, opacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这段代码就是提前告诉渲染引擎 box 元素将要做几何变换和透明度变换操作，这时候渲染引擎会将该元素单独实现一帧，等这些变换发生时，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就大大提升了渲染的效率。这也是 CSS 动画比 JavaScript 动画高效的原因.   </p></blockquote><h4 id="25-｜-页面性能：如何系统地优化页面？"><a href="#25-｜-页面性能：如何系统地优化页面？" class="headerlink" title="25 ｜ 页面性能：如何系统地优化页面？"></a>25 ｜ 页面性能：如何系统地优化页面？</h4><hr><blockquote><p>本节所谈论的页面优化，其实就是让页面更快的显示和响应。<br>通常一个页面有三个阶段：加载阶段、交互阶段和关闭阶段。    </p><ul><li>加载阶段，是指从发出请求到渲染出完整页面的过程，影响到这个阶段的主要因素有网络和 JavaScript 脚本。  </li><li>交互阶段，主要是从页面加载完成到用户交互的整合过程，影响到这个阶段的主要因素是 JavaScript 脚本。    </li><li>关闭阶段，主要是用户发出关闭指令后页面所做的一些清理操作。<br>这里我们需要重点关注加载阶段和交互阶段，因为影响到我们体验的因素主要都在这两个阶段.</li></ul></blockquote><h5 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h5><blockquote><p>并非所有的资源都会阻塞页面的首次绘制，比如图片、音频、视频等文件就不会阻塞页面的首次渲染。而JavaScript、首次请求的HTML资源文件、CSS文件是会阻塞首次渲染的。把这些能阻塞页面渲染的称为关键资源。基于关键资源，细化出三个影响页面首次渲染的核心因素：   </p><ul><li>第一个是关键资源个数。  </li><li>第二个是关键资源大小。  </li><li>第三个是请求关键资源需要多少个RTT(Round Trip Time).[通常1个HTTP的数据包在14KB左右，所以0.1M的页面需要拆分成8个包来传输，也就是说需要8个RTT]。   </li></ul></blockquote><blockquote><p>然后针对核心因素，考虑优化方案：总的优化原则就是减少关键资源个数、降低关键资源大小、降低关键资源的RTT次数。</p></blockquote><h5 id="交互阶段"><a href="#交互阶段" class="headerlink" title="交互阶段"></a>交互阶段</h5><blockquote><p>交互阶段的优化，一个大的原则就是让单个帧的生成速度变快。  </p><ol><li>减少JavaScript脚本执行时间。</li><li>避免强制同步布局。【所谓强制同步布局，是指JavaScript强制将计算样式和布局操作提前到当前的任务中。】 </li><li>避免布局抖动。 </li><li>合理利用CSS合成动画。  </li><li>避免频繁的垃圾回收。   </li></ol></blockquote><h4 id="26-｜-虚拟DOM：虚拟DOM和实际的DOM有何不同？"><a href="#26-｜-虚拟DOM：虚拟DOM和实际的DOM有何不同？" class="headerlink" title="26 ｜ 虚拟DOM：虚拟DOM和实际的DOM有何不同？"></a>26 ｜ 虚拟DOM：虚拟DOM和实际的DOM有何不同？</h4><hr><blockquote><p>本节先聊一些DOM的缺陷，然后在此基础上介绍虚拟DOM如何解决这些缺陷，最后站在双缓存和MVC的视角来聊聊虚拟DOM。</p></blockquote><h5 id="DOM的缺陷"><a href="#DOM的缺陷" class="headerlink" title="DOM的缺陷"></a>DOM的缺陷</h5><blockquote><p>通过前面对DOM的学习，我们知道对于一些复杂的页面或者目前使用非常多的单页面应用来说，其DOM结构复杂，每次操作需要去不断修改DOM树，每次操作渲染引擎都需要进行重绘、重排或者合成操作，执行一次重排或者重绘操作是非常耗时的，这样就带来了性能问题。<br>所以就需要一直方式来减少JavaScript对DOM的操作，这时候虚拟DOM就上场了。    </p></blockquote><h5 id="什么是虚拟DOM"><a href="#什么是虚拟DOM" class="headerlink" title="什么是虚拟DOM"></a>什么是虚拟DOM</h5><blockquote><p>虚拟DOM要解决的事情：  </p><ul><li>将页面改变的内容应用到虚拟DOM上，而不是直接应用在DOM上。  </li><li>变化被应用到虚拟DOM上时，虚拟DOM并不急着去渲染页面，而仅仅是调整虚拟DOM的内部状态，这样操作虚拟DOM的代价就变得非常轻了。    </li><li>在虚拟DOM收集到足够的改变时，再把这些变化一次性应用到真实的DOM上。  </li></ul></blockquote><blockquote><p>接下来从双缓存和MVC模型这两个视角来聊聊虚拟DOM：  </p><ul><li><ol><li>双缓存<br>双换粗是一种经典的思路，应用哎很多场合，能解决页面无效刷新和闪屏的问题，虚拟DOM就是双缓存思想的一种实现。<br>使用双缓存，可以先将计算的中间结果存放到另一个缓冲区中，等全部的计算结束，该缓冲区已经存储了完整的图形，这样使得整个图像的输出非常稳定。  </li></ol></li></ul><ol start="2"><li>MVC模式<br>基于MVC的设计思想广泛地渗透到各种场合，且基于MVC又衍生出了很多其他模式(如MVP、MVVM)，不过万变不离其宗，它们的基础框架都是基于MVC而来。站在MVC视角来理解虚拟DOM能让你看到更为“广阔的世界”. </li></ol></blockquote><h4 id="27-渐进式网页应用-PWA-它究竟解决了Web应用的哪些问题？"><a href="#27-渐进式网页应用-PWA-它究竟解决了Web应用的哪些问题？" class="headerlink" title="27 | 渐进式网页应用(PWA):它究竟解决了Web应用的哪些问题？"></a>27 | 渐进式网页应用(PWA):它究竟解决了Web应用的哪些问题？</h4><hr><blockquote><p>PWA,全称是Progressive Web App，渐进式网页应用。   </p></blockquote><blockquote><p>渐进式：</p><ul><li>站在Web应用开发者来说，PWA提供了一个渐进式的过度方案，让普通站点逐步过度到Web应用。采取渐进式可以降低站点改造的代价，使得站点逐步支持各项新技术，而不是一步到位。   </li><li>站在技术角度来说，PWA技术也是一个渐进式的演化过程，在技术层面会一点点演进，比如逐渐提供更好的设备特性支持，不断优化更加流畅的动画效果，不断让页面的加载速度变得更快，不断实现本地应用的特性。<br>可以这么理解：PWA是一套理念，渐进式增强Web的优势，并通过技术手段渐进式缩短和本地应用或者小程序的距离。</li></ul></blockquote><h5 id="Web应用-VS-本地应用"><a href="#Web应用-VS-本地应用" class="headerlink" title="Web应用 VS 本地应用"></a>Web应用 VS 本地应用</h5><blockquote><p>相较于本地应用，Web应用缺陷：   </p><ul><li>首先，Web应用缺少离线使用能力，在离线或者弱网环境下基本上是无法使用的。 </li><li>其次，Web应用还缺少了消息推送的能力。   </li><li>最后，Web缺少一级入口。</li></ul></blockquote><blockquote><p>针对以上缺陷，PWA提出了两种解决方案：通过引入Service Worker来试着解决离线存储和消息推送的问题，通过引入manifest.json来解决一级入口的问题。</p></blockquote><h5 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h5><blockquote><p>在2014年的时候，标准委员会就提出来Service Worker的概念，主要思想是在页面和网络之间增加一个拦截器，主要功能就是用来缓存资源和拦截请求。</p></blockquote><blockquote><p>设计思路：<br>为避免JavaScript过多占用页面主线程时长的情况，浏览器实现了Web Worker的功能。Web Worker的目的是让JavaScript能够运行在页面主线程之外，且只能执行一些与DOM无关的JS脚本。在Chrome中，Web Worker其实就是在渲染进程中开启一个新线程，它的生命周期和页面关联。<br>“让其运行在主线程之外”就是Service Worker来自Web Worker的一个核心思想。但需要在Web Worker的基础上加上储存功能。且Service Worker还需要会为多个页面提供服务，所以还不能把Service Worker和单个页面绑定起来。<br>消息推送也是基于Service Worker来实现的。<br>最后，若要使站点支持Service Worker，首先必要的一步就是要将站点升级到HTTPS。</p></blockquote><h4 id="28-｜-WebComponent：像搭积木一样构建Web应用"><a href="#28-｜-WebComponent：像搭积木一样构建Web应用" class="headerlink" title="28 ｜ WebComponent：像搭积木一样构建Web应用"></a>28 ｜ WebComponent：像搭积木一样构建Web应用</h4><hr><blockquote><p>首先，本节介绍了组件化开发是程序员的刚需，所谓组件化就是功能模块要实现高内聚、低耦合的特性。<br>不过由于 DOM 和 CSSOM 都是全局的，所以它们是影响了前端组件化的主要元素。<br>基于这个原因，就出现 WebComponent，它包含自定义元素、影子 DOM 和 HTML 模板三种技术，使得开发者可以隔离 CSS 和 DOM。<br>在此基础上，还重点介绍了影子 DOM 到底是怎么实现的。<br>关于 WebComponent 的未来如何，这里我们不好预测和评判，但是有一点可以肯定，WebComponent 也会采用渐进式迭代的方式向前推进，未来依然有很多坑需要去填。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot;&gt;&lt;a href=&quot;#前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot; class=&quot;headerlink&quot; title=&quot;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot;&gt;&lt;/a&gt;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&lt;/h6&gt;&lt;h6 id=&quot;本篇是这个专栏的第五章：《No5-浏览器中的页面》。本章分为八节。&quot;&gt;&lt;a href=&quot;#本篇是这个专栏的第五章：《No5-浏览器中的页面》。本章分为八节。&quot; class=&quot;headerlink&quot; title=&quot;本篇是这个专栏的第五章：《No5.浏览器中的页面》。本章分为八节。&quot;&gt;&lt;/a&gt;本篇是这个专栏的第五章：《No5.浏览器中的页面》。本章分为八节。&lt;/h6&gt;
    
    </summary>
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>每周总结第二十一期</title>
    <link href="http://liugezhou.online/2019/11/30/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E6%9C%9F/"/>
    <id>http://liugezhou.online/2019/11/30/每周总结第二十一期/</id>
    <published>2019-11-30T14:08:00.000Z</published>
    <updated>2019-11-30T14:24:35.796Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这里记录过去一周，我的一些小总结。<br> <img src="http://img.liugezhou.online/20191130No21week.jpeg" alt="weekly-21"></p></blockquote><a id="more"></a><h4 id="Feeling"><a href="#Feeling" class="headerlink" title="Feeling"></a>Feeling</h4><blockquote><p>No Feeling。</p></blockquote><h4 id="携号转网"><a href="#携号转网" class="headerlink" title="携号转网"></a>携号转网</h4><blockquote><p>工信部11月27日(周三)召开携号转网启动仪式，27日起，携号转网正式在全国提供服务。用户号码保持不变，符合条件可自由选择移动、联通、电信等运营商。电信业务经营者不得干涉用户自主选择。</p><p>网上数据：<br>“携号转网”服务正式在全国范围内拓展。此前，天津、海南等五个前期试验省(市)已于9月19日正式提供服务。据工信部数据，截至11月26日，上述五个试验省份完成携号转网用户316万，从前期数据来看，携号转网的人员不到整体的2%。中国电信、中国移动、中国联通转出的用户数占全部转出用户的比例分别是16.3%、57.6%和26.1%，转入的占比是49.3%、28.1%和22.6%。（21世纪经济报道）    </p><p>这次携号转网终于可以让移动这种巨无霸企业有些许收敛。终于让一直存在的最低消费、营业点办理、流量瞎收费等等问题有了一些的缓和。<br>多年来我一直有个心愿，就是将我这半死不活还在用的移动号能有一个最低消费，多次客服无果。在这次浩浩荡荡的携号转网行动中，一个人工电话完成了我的心愿，甚感欣慰。</p></blockquote><h4 id="网易裁员的5点思考"><a href="#网易裁员的5点思考" class="headerlink" title="网易裁员的5点思考"></a><a href="https://mp.weixin.qq.com/s/_qFUhwAZwxJaiPD-EBtDVw" target="_blank" rel="noopener">网易裁员的5点思考</a></h4><blockquote><p>网易裁员、华为前员工被公司起诉敲诈(知乎已删除此相关话题回答)等事件让企业与员工关系推到了一个热度，其实大家心知肚明，这些事情在短期内虽然得到关注，但是这样的事件长期依然不会停止。<br>不管如何，对于职场人来说要做的、可控的首先是关注且做好自己的本职工作，其次当然要了解一些相关法律知识以保障自己权益。这篇文章作者针对此次事件总结了一些《劳动合同法》的基本知识。<br><a href="https://mp.weixin.qq.com/s/_qFUhwAZwxJaiPD-EBtDVw" target="_blank" rel="noopener">网易裁员事件引发的 5 点重要思考</a></p></blockquote><h4 id="欧洲IPv4地址用光"><a href="#欧洲IPv4地址用光" class="headerlink" title="欧洲IPv4地址用光"></a>欧洲IPv4地址用光</h4><blockquote><p>2019年11月25日(周一），欧洲 IP 地址注册机构 RIPE 宣布，欧洲的 IPv4 地址全部分配光了，一个也没剩下，从此没有新的 IP 地址可以分配。</p></blockquote><blockquote><ul><li>IP地址是分配给每个联网设备的一系列号码，每个IP地址都是独一无二的。IPv4地址用光大体意味着2^32-1个联网设备地址分配完了。  </li><li>当全球IPv4地址耗尽的这一刻，IPv6早就已经进入了我们的生活,在很多APP开屏的界面，会标注已经支持IPv6技术。  </li><li>IPv4地址长度是32，支持的物理地址是2^32-1个地址；IPv6地址的长度是128，支持的物理地址是2^128-1个地址。能够对地球上每平方米提供6×1023个网络地址，在可预见的将来是不会耗尽的。 </li><li>IPv4的回路地址为: 127.0.0.1，IPv6的回路地址为 : 000:0000:0000:0000:0000:0000:0000:0001 可以简写为 ::1。 </li><li>全球IPv4地址耗尽对普通用户影响不大，更多是网络技术、运营商，以及互联网应用开发者的事情.     </li></ul></blockquote><h4 id="OffScreen"><a href="#OffScreen" class="headerlink" title="OffScreen"></a>OffScreen</h4><blockquote><p>App store上的一款时间管理软件，它是系统“屏幕使用时间”的最佳伴侣，可以记录更多的信息，还可以提醒你，比如，OffScreen 会在你每次点亮屏幕的时候，用通知提醒，这是今天第几次拿起手机，以及平均查看时长，熬夜提醒，边走边看提醒，等等，帮助你戒除一些错误的生活习惯，如果你觉得有必要管理你的手机使用时长，这款软件可以很轻松的帮助你。</p></blockquote><h4 id="免费版权图片一键搜索"><a href="#免费版权图片一键搜索" class="headerlink" title="免费版权图片一键搜索!"></a><a href="https://www.logosc.cn/so/" target="_blank" rel="noopener">免费版权图片一键搜索!</a></h4><blockquote><p>一键搜索多家免版权图库，可以使用现有模板或者上传模板素材设计图片。    </p></blockquote><h4 id="再次安利vconsole"><a href="#再次安利vconsole" class="headerlink" title="再次安利vconsole"></a>再次安利vconsole</h4><blockquote><p>在开发手机网页应用，在手机真机调试过程中，如果想有类似小程序自带的调试工具，那么可以在你的网页中使用次插件：vconsole。<br>Github仓库搜索：vonsole，对照引入即可快速简单部署。</p></blockquote><h4 id="VSCode插件–import"><a href="#VSCode插件–import" class="headerlink" title="VSCode插件–import"></a>VSCode插件–import</h4><blockquote><p>作用：当你写了一个导入语句时，它会提醒你这个包的大小，如果你发现某个包太大时，就需要考虑一下你是否真的需要引入整个包。效果实例：<br><img src="http://img.liugezhou.online/20191130importcost.png" alt="import"></p></blockquote><h4 id="CSS-Grid网格布局教程"><a href="#CSS-Grid网格布局教程" class="headerlink" title="CSS Grid网格布局教程"></a><a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html" target="_blank" rel="noopener">CSS Grid网格布局教程</a></h4><blockquote><p>前端非常重要的两大布局分别是：Flex弹性布局和Grid网格布局。<br>Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是一维布局。<br>Grid 布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可以看作是二维布局。<br>Grid 布局远比 Flex 布局强大。<br><img src="https://www.wangbase.com/blogimg/asset/201903/1_bg2019032501.png" alt="Grid"></p></blockquote><h4 id="前端模块化"><a href="#前端模块化" class="headerlink" title="前端模块化"></a><a href="https://www.liugezhou.online/2019/11/27/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/" target="_blank" rel="noopener">前端模块化</a></h4><blockquote><p>最近项目在调试微信支付的前端SDK引入的时候，官网文档有一句：“JSSDk的引入，支持使用 AMD/CMD 标准模块加载方法加载”。<br>对CommonJS、AMD、CMD、ES6Module等概念与代码实例的理解甚是混淆，于是查阅资料、总结<a href="https://www.liugezhou.online/2019/11/27/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/" target="_blank" rel="noopener">此文</a>。</p></blockquote><h4 id="nginx简单的几个命令"><a href="#nginx简单的几个命令" class="headerlink" title="nginx简单的几个命令"></a>nginx简单的几个命令</h4><blockquote><ul><li>服务端安装nginx：<code>yum install nginx</code>，通过yum安装的程序默认在etc目录下。  </li><li>查看nginx安装路径：<code>which nginx</code>或者<code>whereis nginx</code>.    </li><li>nginx启动：<code>service start nginx</code>,nginx停止：<code>service stop nginx</code>.   </li><li>查看nginx的运行状况：<code>ps -ef | grep nginx</code>. </li><li>nginx的配置主要查看<code>conf</code>文件，包括一些包含配置、域名解析、文件路径、监听端口、转发端口等。    </li></ul></blockquote><h4 id="浏览器中的页面循环系统"><a href="#浏览器中的页面循环系统" class="headerlink" title="浏览器中的页面循环系统"></a><a href="https://www.liugezhou.online/2019/11/25/No4.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E9%A1%B5%E9%9D%A2%E5%BE%AA%E7%8E%AF%E7%B3%BB%E7%BB%9F/" target="_blank" rel="noopener">浏览器中的页面循环系统</a></h4><blockquote><p>前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。<br>本篇是这个专栏的第四章：<a href="https://www.liugezhou.online/2019/11/25/No4.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E9%A1%B5%E9%9D%A2%E5%BE%AA%E7%8E%AF%E7%B3%BB%E7%BB%9F/" target="_blank" rel="noopener">浏览器中的页面循环系统</a>。本章分为六讲。   </p></blockquote><blockquote><p><a href="https://liugezhou.gitbook.io/liugezhou/hong-guan-shi-jiao-xia-de-liu-lan-qi/no4.-liu-lan-qi-zhong-de-ye-mian-xun-huan-xi-tong" target="_blank" rel="noopener">Gitbook在线阅读</a></p></blockquote><blockquote><ul><li>本章通过分析线程处理任务的不同方式介绍了事件循环系统、消息队列以及IPC等知识引出微任务的作用。</li><li>介绍了setTimeout和XMLHttpRequest两个WebAPI的实现方式. </li><li>由浅入深讲解微任务：包括微任务的实现原理以及微任务的应用：Promise。   </li><li>最后讲解了比Promise更容易阅读的async/await的原理及用法。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这里记录过去一周，我的一些小总结。&lt;br&gt; &lt;img src=&quot;http://img.liugezhou.online/20191130No21week.jpeg&quot; alt=&quot;weekly-21&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="每周分享" scheme="http://liugezhou.online/categories/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="每周分享" scheme="http://liugezhou.online/tags/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>前端模块化</title>
    <link href="http://liugezhou.online/2019/11/27/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>http://liugezhou.online/2019/11/27/前端模块化/</id>
    <published>2019-11-27T12:00:00.000Z</published>
    <updated>2019-11-29T03:11:13.682Z</updated>
    
    <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><blockquote><p>最近在梳理前端的公众号支付流程，从前端流程微信JSSDK的引入开始查阅文档。<br>在引入JS文件一小段中，文档中备注：“支持使用 AMD/CMD 标准模块加载方法加载”。<br>于是，想到对CommonJS、AMD、CMD、ES6Module等概念与代码实例的理解甚是混淆，于是学习、总结此文。  </p></blockquote><a id="more"></a><h4 id="前端模块化"><a href="#前端模块化" class="headerlink" title="前端模块化"></a>前端模块化</h4><hr><blockquote><p>2009年，美国程序员Ryan Dahl创造了node.js项目，将javascript语言用于服务器端编程。这标志”Javascript模块化编程”正式诞生。<br>因为老实说，在浏览器环境下，没有模块也不是特别大的问题，毕竟网页程序的复杂性有限；但是在服务器端，一定要有模块，与操作系统和其他应用程序互动，否则根本没法编程。NodeJS是CommonJS规范的实现，webpack 也是以CommonJS的形式来书写。</p></blockquote><blockquote><p>为了提高代码的复用率，方便代码进行管理，我也不知先后(应该CommonJS最早吧)的出现了一系列的模块化的规范：CommonJS、AMD、CMD以及（ES6Module）。</p></blockquote><blockquote><p>通常来讲：一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。</p></blockquote><blockquote><p>这三个规范都是为javascript模块化加载而生的，都是在用到或者预计要用到某些模块时候加载该模块，使得大量的系统巨大的庞杂的代码得以很好的组织和管理。模块化使得我们在使用和管理代码的时候不那么混乱，而且也方便了多人的合作。</p></blockquote><h4 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h4><hr><blockquote><ul><li>CommonJS是一个更偏向于服务端的规范。Node.js就是CommonJS规范的主要实践者。 </li><li>CommonJS不适用浏览器是因为：此规范是同步加载模块，对于服务器端来说，所有的模块都是在本地磁盘，等待模块时间就是硬盘读取文件时间，很小，但对浏览器而言，设计到网速、代理更原因，同步加载会造成阻塞，浏览器处于“假死”状态，所以浏览器端出现了AMD规范。</li></ul></blockquote><blockquote><p>代码实现拓展：<a href="http://javascript.ruanyifeng.com/nodejs/module.html" target="_blank" rel="noopener">CommonJS规范</a></p></blockquote><h4 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h4><blockquote><ul><li>AMD是<code>Asynchronous Module Definition</code>的缩写，即“异步模块定义”，它采用异步方式加载模块(模块的加载不影响它后面语句的运行),且会提前加载。</li><li>AMD同CommonJS一样也是使用require加载模块，但不同的是，AMD要求两个参数：require([module],callback).  </li></ul></blockquote><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> // 定义一个模块--math.js</span><br><span class="line">    define(function() &#123;</span><br><span class="line">    var add = function(x, y) &#123;</span><br><span class="line">        return x + y;</span><br><span class="line">    &#125;</span><br><span class="line">    return  &#123;</span><br><span class="line">        add: add</span><br><span class="line">    &#125;</span><br><span class="line">//加载方法如下</span><br><span class="line">require([&apos;math&apos;], function(math) &#123;</span><br><span class="line">  alert(math.add(1, 1));</span><br><span class="line">&#125;)</span><br><span class="line">//如果math模块还依赖其他模块，写法如下：</span><br><span class="line">define([&apos;dependenceModule&apos;], function(dependenceModule) &#123;</span><br><span class="line">    // todo</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><ul><li>当require()函数加载math模块的时候，就会先加载dependenceModule模块。当有多个依赖时，就将所有的依赖都写在define()函数第一个参数数组中，所以说AMD是依赖前置的。这不同于CMD规范，它是依赖就近的。</li></ul></blockquote><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><hr><blockquote><p>CMD与AMD最大的不同就是：CMD推崇依赖就近，延迟执行。可以在代码的任意一行写入依赖：<br><code>define(factory)</code><br>当factory为函数时，表示是模块的构造方法。<br>执行该构造方法，可以得到模块向外提供的接口。<br>factory 方法在执行时，默认会传入三个参数：require、exports 和 module.</p></blockquote><blockquote><p>AMD与CMD代码对比：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// CMD</span><br><span class="line">   define(function(require, exports, module) &#123;</span><br><span class="line">   var a = require(&apos;./a&apos;);</span><br><span class="line">   a.doSomething();</span><br><span class="line">   var b = require(&apos;./b&apos;);</span><br><span class="line">   b.doSomething();</span><br><span class="line">   &#125;)</span><br><span class="line">   // AMDdefine([&apos;a&apos;, &apos;b&apos;], function(a, b) &#123;</span><br><span class="line">   a.doSomething();</span><br><span class="line">   b.doSomething();</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure><h4 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h4><hr><blockquote><p>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：export和import.<br>export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。<br>ES6还提供了export default命令，为模块指定默认输出，对应的import语句不需要使用大括号.</p></blockquote><h4 id="ES6模块与CommonJS模块差异"><a href="#ES6模块与CommonJS模块差异" class="headerlink" title="ES6模块与CommonJS模块差异"></a>ES6模块与CommonJS模块差异</h4><hr><blockquote><ul><li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。  </li><li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;最近在梳理前端的公众号支付流程，从前端流程微信JSSDK的引入开始查阅文档。&lt;br&gt;在引入JS文件一小段中，文档中备注：“支持使用 AMD/CMD 标准模块加载方法加载”。&lt;br&gt;于是，想到对CommonJS、AMD、CMD、ES6Module等概念与代码实例的理解甚是混淆，于是学习、总结此文。  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="web前端" scheme="http://liugezhou.online/categories/web%E5%89%8D%E7%AB%AF/"/>
    
      <category term="js" scheme="http://liugezhou.online/categories/web%E5%89%8D%E7%AB%AF/js/"/>
    
    
      <category term="js" scheme="http://liugezhou.online/tags/js/"/>
    
      <category term="jsonp" scheme="http://liugezhou.online/tags/jsonp/"/>
    
  </entry>
  
  <entry>
    <title>No4.浏览器中的页面循环系统</title>
    <link href="http://liugezhou.online/2019/11/25/No4.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E9%A1%B5%E9%9D%A2%E5%BE%AA%E7%8E%AF%E7%B3%BB%E7%BB%9F/"/>
    <id>http://liugezhou.online/2019/11/25/No4.浏览器中的页面循环系统/</id>
    <published>2019-11-25T12:40:00.000Z</published>
    <updated>2019-11-30T03:11:31.014Z</updated>
    
    <content type="html"><![CDATA[<h6 id="前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。"><a href="#前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。" class="headerlink" title="前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。"></a>前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。</h6><h6 id="本篇是这个专栏的第四章：《浏览器中的页面循环系统》。本章分为六节。"><a href="#本篇是这个专栏的第四章：《浏览器中的页面循环系统》。本章分为六节。" class="headerlink" title="本篇是这个专栏的第四章：《浏览器中的页面循环系统》。本章分为六节。"></a>本篇是这个专栏的第四章：《浏览器中的页面循环系统》。本章分为六节。</h6><a id="more"></a><h4 id="15｜消息队列和事件循环：页面是怎么“活”起来的？"><a href="#15｜消息队列和事件循环：页面是怎么“活”起来的？" class="headerlink" title="15｜消息队列和事件循环：页面是怎么“活”起来的？"></a>15｜消息队列和事件循环：页面是怎么“活”起来的？</h4><hr><blockquote><p>本节主要专门介绍页面的事件循环系统，希望通过几段总结能对页面的事件循环系统有一个整体上的理解。    </p></blockquote><h5 id="使用单线程处理安排好的任务"><a href="#使用单线程处理安排好的任务" class="headerlink" title="使用单线程处理安排好的任务"></a>使用单线程处理安排好的任务</h5><blockquote><p>单线程处理的流程就是把所有任务代码按照顺序写进主线程里，等线程运行时，这些任务按照顺序在线程中执行，等所有任务执行完成，线程自动退出。        </p></blockquote><h5 id="在线程运行过程中处理任务"><a href="#在线程运行过程中处理任务" class="headerlink" title="在线程运行过程中处理任务"></a>在线程运行过程中处理任务</h5><blockquote><p>当然并非所有任务都可以使用单线程处理，有时我们需要在线程运行的过程中处理任务。<br>那么要想在线程运行过程中，能接受并执行新的任务，就需要采用事件循环机制。<br>相较与单线程处理任务，此线程做了两点改进：  </p><ul><li>引入了循环机制。(比如一个实现方式是添加for循环。线程一直循环执行)。 </li><li>引入了事件。</li></ul></blockquote><h5 id="处理其他线程发送过来的任务"><a href="#处理其他线程发送过来的任务" class="headerlink" title="处理其他线程发送过来的任务"></a>处理其他线程发送过来的任务</h5><blockquote><p>如何设计好一个线程模型，能让其能够接受其他线程发送的消息呢？<br>一个通用的模式是消息队列：「消息队列是一种数据结构、可以存放要执行的任务。它符合队列“先进先出”的特点。」<br>有了队列之后继续改进步骤如下：    </p><ul><li>添加一个消息队列。  </li><li>IO线程中产生的新任务添加进消息队列尾部。    </li><li>渲染主进程会循环地从消息队列头部中读取任务，执行任务。  </li></ul></blockquote><h5 id="处理其他进程发送过来的任务"><a href="#处理其他进程发送过来的任务" class="headerlink" title="处理其他进程发送过来的任务"></a>处理其他进程发送过来的任务</h5><blockquote><p>渲染进程专门有一个 IO 线程用来接收其他进程传进来的消息，接收到消息之后，会将这些消息组装成任务发送给渲染主线程，后续的步骤就和前面的“处理其他线程发送的任务”一样。    </p></blockquote><h5 id="消息队列中的任务类型"><a href="#消息队列中的任务类型" class="headerlink" title="消息队列中的任务类型"></a>消息队列中的任务类型</h5><blockquote><p>消息队列中的任务都有哪些呢？<br>输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器等等。除此之外，消息队列中还包含了很多与页面相关的事件，如 JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画等。    </p></blockquote><h5 id="页面使用单线程的缺点"><a href="#页面使用单线程的缺点" class="headerlink" title="页面使用单线程的缺点"></a>页面使用单线程的缺点</h5><blockquote><ul><li>第一个问题是如何处理高优先级的任务。<br>由于优先级的问题使得微任务应用而生，微任务是如何权衡效率和实时性的呢?<br>通常我们把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题.等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为 DOM 变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题   </li><li>第二个是如何解决单个任务执行时长过久的问题.<br>针对这种情况，JavaScript 可以通过回调功能来规避这种问题，也就是让要执行的 JavaScript 任务滞后执行。  </li></ul></blockquote><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><blockquote><p>如果有一些确定好的任务，可以使用一个单线程来按照顺序处理这些任务，这是第一版线程模型。<br>要在线程执行过程中接收并处理新的任务，就需要引入循环语句和事件系统，这是第二版线程模型。<br>如果要接收其他线程发送过来的任务，就需要引入消息队列，这是第三版线程模型。<br>如果其他进程想要发送任务给页面主线程，那么先通过 IPC 把任务发送给渲染进程的 IO 线程，IO 线程再把任务发送给页面主线程。<br>消息队列机制并不是太灵活，为了适应效率和实时性，引入了微任务。</p></blockquote><h4 id="16-｜-WebAPI-setTimeout是如何实现的"><a href="#16-｜-WebAPI-setTimeout是如何实现的" class="headerlink" title="16 ｜ WebAPI : setTimeout是如何实现的"></a>16 ｜ WebAPI : setTimeout是如何实现的</h4><hr><h5 id="浏览器怎么实现setTimeout"><a href="#浏览器怎么实现setTimeout" class="headerlink" title="浏览器怎么实现setTimeout"></a>浏览器怎么实现setTimeout</h5><blockquote><p>通过上一小节的学习，我们知道：对于一些事件执行的过程是：这些事件先被添加到消息队列，然后事件循环系统就会按照消息队列中的顺序来执行事件。也就是说，执行一段异步任务，需要先将任务添加到消息队列中。<br>不过通过定时器设置回调函数有点特别，它们需要在指定的时间间隔内被调用，但消息队列中的任务是按照顺序执行的，所以为了保证回调函数能在指定时间内执行，你不能将定时器的回调函数直接添加到消息队列中。<br>从Chromium队列的部分源码中我们知道，在Chrome中除了正常使用的消息队列外，还有另外一个消息队列，这个队列中维护了<code>需要延迟执行的任务列表</code>，包括了定时器和Chromium内部一些需要延迟执行的任务。<br>由于消息队列排队和一些系统级别的限制，通过setTimeout设置的回调任务并非总是可以实时的执行，这样就不能满足一些实时性要求较高的需求。    </p></blockquote><h5 id="使用setTimeout的一些注意事项"><a href="#使用setTimeout的一些注意事项" class="headerlink" title="使用setTimeout的一些注意事项"></a>使用setTimeout的一些注意事项</h5><blockquote><ul><li>如果当前任务执行时间过久，会影响延迟到期定时器任务的执行。  </li><li>如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒。 </li><li>未激活的页面，setTimeout 执行最小间隔是 1000 毫秒.  </li><li>延时执行时间有最大值:大约 24.8 天   </li><li>使用 setTimeout 设置的回调函数中的 this 不符合直觉. </li></ul></blockquote><h4 id="17-WebAPI：XMLHttpRequest是怎么实现的"><a href="#17-WebAPI：XMLHttpRequest是怎么实现的" class="headerlink" title="17 | WebAPI：XMLHttpRequest是怎么实现的?"></a>17 | WebAPI：XMLHttpRequest是怎么实现的?</h4><hr><blockquote><p>在深入讲解 XMLHttpRequest 之前，我们得先介绍下<code>同步回调</code>和<code>异步回调</code>这两个概念.   </p></blockquote><h5 id="回调函数-VS-系统调用栈"><a href="#回调函数-VS-系统调用栈" class="headerlink" title="回调函数 VS 系统调用栈"></a>回调函数 VS 系统调用栈</h5><blockquote><p><code>回调函数</code>：将一个函数作为参数传递给另外一个函数，那作为参数的这个函数就是回调函数。</p></blockquote><blockquote><p>同步回调函数代码：  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let callback = function()&#123;</span><br><span class="line">    console.log(&apos;i am do homework&apos;)</span><br><span class="line">&#125;</span><br><span class="line">function doWork(cb) &#123;</span><br><span class="line">    console.log(&apos;start do work&apos;)</span><br><span class="line">    cb()</span><br><span class="line">    console.log(&apos;end do work&apos;)</span><br><span class="line">&#125;</span><br><span class="line">doWork(callback)</span><br><span class="line">//start do work</span><br><span class="line">//i am do homework</span><br><span class="line">//end do work</span><br></pre></td></tr></table></figure><blockquote><p>异步回调函数代码：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let callback = function()&#123;</span><br><span class="line">    console.log(&apos;i am do homework&apos;)</span><br><span class="line">&#125;</span><br><span class="line">function doWork(cb) &#123;</span><br><span class="line">    console.log(&apos;start do work&apos;)</span><br><span class="line">    setTimeout(cb,1000)   </span><br><span class="line">    console.log(&apos;end do work&apos;)</span><br><span class="line">&#125;</span><br><span class="line">doWork(callback)</span><br></pre></td></tr></table></figure><h5 id="XMLHttpRequest运作机制"><a href="#XMLHttpRequest运作机制" class="headerlink" title="XMLHttpRequest运作机制"></a>XMLHttpRequest运作机制</h5><blockquote><p>对回调函数有了一个认知后，那么接着我们来分析下从发起请求到接收数据的完整流程：    </p></blockquote><blockquote><p>首先从XMLHttpRequest的用法开始：</p><ul><li>第一步：创建XMLHttpRequest对象。  </li><li>第二步：为xhr对象注册回调函数。</li><li>第三步：配置基础的请求信息。    </li><li>第四步：发起请求。  </li></ul></blockquote><h5 id="XMLRequest使用过程中的“坑”"><a href="#XMLRequest使用过程中的“坑”" class="headerlink" title="XMLRequest使用过程中的“坑”"></a>XMLRequest使用过程中的“坑”</h5><blockquote><ul><li>跨域问题    </li><li>HTTPS混合内容的问题：这是指HTTPS页面中包含了不符合HTTPS安全要求的内容，比如包含了HTTP资源。</li></ul></blockquote><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><blockquote><p>setTimeout 是直接将延迟任务添加到延迟队列中，而 XMLHttpRequest 发起请求，是由浏览器的其他进程或者线程去执行，然后再将执行结果利用 IPC 的方式通知渲染进程，之后渲染进程再将对应的消息添加到消息队列中。    </p></blockquote><h4 id="18-宏任务和微任务：不是所有的任务都是一个待遇"><a href="#18-宏任务和微任务：不是所有的任务都是一个待遇" class="headerlink" title="18 | 宏任务和微任务：不是所有的任务都是一个待遇"></a>18 | 宏任务和微任务：不是所有的任务都是一个待遇</h4><hr><blockquote><p>前面我们已经知道微任务可以在实时性和效率之间做一个有效的权衡。微任务已被广泛应用，比如Promise以及以Promise为基础开发出来的很多其他的技术。<br>宏任务与微任务的区别：    </p></blockquote><h5 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h5><blockquote><p>页面中的大部分任务都是在主线程上执行的。如渲染事件、用户交互事件、JavaScript脚本执行事件、网络请求等等。这些在消息队列中的任务称为宏任务。<br>虽然宏任务可以满足我们大部门的日常需求，但是有时对时间精度要求较高的需求，宏任务就难以胜任了。</p></blockquote><h5 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h5><blockquote><p>微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。<br>产生微任务的两种方式：    </p><ul><li>第一种方式是使用 MutationObserver 监控某个 DOM 节点，然后再通过 JavaScript 来修改这个节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。   </li><li>第二种方式是使用 Promise，当调用 Promise.resolve() 或者 Promise.reject() 的时候，也会产生微任务。<br>通过微任务的工作流程，我们可以得出如下结论：  </li><li>微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。    </li><li>微任务的执行时长会影响到当然宏任务的执行时长，因此写代码的时候一定要注意微任务的执行时长。  </li><li>在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务早于宏任务执行。</li></ul></blockquote><h5 id="监听DOM变化演变"><a href="#监听DOM变化演变" class="headerlink" title="监听DOM变化演变"></a>监听DOM变化演变</h5><blockquote><p>微任务应用在了<code>MutationObserver</code>中，<code>MutationObserver</code>是用来监听DOM变化的一套方法。 监听DOM变化一直是前端工程师一项非常核心的需求。<br>下面是监听DOM变化演变的简单总结:  </p><ul><li>早起观测DOM变化就是轮询检测。比如使用 setTimeout 或者 setInterval 来定时检测 DOM 是否有改变。无疑这种方式实时性不好，效率还低效。   </li><li>2000年的时候引入了Mutation Event，Mutation Event采用了观察者的设计模式，当DOM有变动时立即出发相应的事件。此方式属于同步回调。虽然这种方式解决了实时性问题，但是因为会产生较大性能开销、导致页面性能出现问题，被反对使用并逐步从web标准事件中删除。  </li><li>MutationObserver替代MutationEvent，相较于Event方式，Observer采用了一次触发异步回调。且采用微任务的处理，使得实时性与性能功能都得到有效提高。</li></ul></blockquote><h4 id="19-｜-Promise：使用Promise，告别回调函数"><a href="#19-｜-Promise：使用Promise，告别回调函数" class="headerlink" title="19 ｜ Promise：使用Promise，告别回调函数"></a>19 ｜ Promise：使用Promise，告别回调函数</h4><blockquote><p>微任务的另一个应用：Promise。<br>本节简单介绍JavaScript引入Promise的动机，以及解决问题的几个核心关键点。<br>讲到动机，也就是说Promise解决了什么问题。众所周知，他解决的是异步编码风格的问题。 </p></blockquote><blockquote><p>页面编程的一大特点就是：异步编程，下面分析异步编程的代码风格进化。    </p><ul><li>之前的代码编码风格，一段代码可能会出现五次回调，这种回调导致代码逻辑不连贯、不连线，不符合人的直觉。  </li><li>然后开发人员们通过封装异步代码，让处理流程变得线性，但是这种处理方式如果嵌套了太多的回调函数就容易陷入回调地狱。</li><li>陷入回调地狱的后代码看上去很乱主要是两点：嵌套调用和任务不确定性(成功或者失败)。于是Promise出现，解决了这两个问题。</li></ul></blockquote><h5 id="Promise：消灭嵌套调用和多次错误处理"><a href="#Promise：消灭嵌套调用和多次错误处理" class="headerlink" title="Promise：消灭嵌套调用和多次错误处理"></a>Promise：消灭嵌套调用和多次错误处理</h5><blockquote><p>Promise通过两步解决嵌套回调问题：</p><ul><li>首先，Promise实现了回调函数的延时绑定（.then）  </li><li>其次，将回调函数返回值穿透到最外层。</li></ul></blockquote><blockquote><p>Promise处理异常：<br>通过最后一个catch，将所有对象合并到一个函数来处理之前的所有异常。</p></blockquote><h5 id="Promise与微任务"><a href="#Promise与微任务" class="headerlink" title="Promise与微任务"></a>Promise与微任务</h5><blockquote><p> Promise 之所以要使用微任务是由 Promise 回调函数延迟绑定技术导致的。</p></blockquote><h4 id="20-｜-async-await：使用同步的方式去写异步代码"><a href="#20-｜-async-await：使用同步的方式去写异步代码" class="headerlink" title="20 ｜ async/await：使用同步的方式去写异步代码"></a>20 ｜ async/await：使用同步的方式去写异步代码</h4><blockquote><p>当Promise解决回调地狱代码风格的同时，我们发现写很多的then函数，还是有些不太容易阅读。<br>基于这个原因，ES7引入了async/await，这是JavaScript异步编程的一个重大改进，提供了在不阻塞主线程的情况下使用同步代码实现异步访问资源的能力。并且使得代码逻辑更加清晰。</p></blockquote><blockquote><p>本节首先介绍生成器(Generator)是如何工作的，接着介绍了Generator的底层实现机制–协程。<br>这是因为async/await使用了Generator和Promise两种技术。所以紧接着通过Generator和Promise来分析async/await到底是如何通过以同步方式来编写异步代码的。  </p></blockquote><h5 id="生成器-VS-协程"><a href="#生成器-VS-协程" class="headerlink" title="生成器 VS 协程"></a>生成器 VS 协程</h5><blockquote><p>生成器函数：生成器函数是一个带星号函数，而且是可以暂停执行和恢复执行的。<br>具体使用方式就是：在生成器函数内部执行一段代码，若遇到yiled关键字，那JS引擎将返回该关键字后面的内容且暂停该函数执行，外部函数通过next方法恢复函数的执行。<br>那么JavaScript引擎V8是如何实现一个函数的暂停和恢复的？    </p></blockquote><blockquote><p>搞懂它的暂停和恢复，需要首先了解协程的概念。协程是一种比线程更加轻量级的存在。可以把协程看作是跑在线程上的任务，一个线程可以存在多个协程。但在线程上同时只能执行一个协程。<br>在JS中，生成器就是协程的一种实现方式。</p></blockquote><h5 id="asnyc-await"><a href="#asnyc-await" class="headerlink" title="asnyc/await"></a>asnyc/await</h5><blockquote><p>为了更近一步改进生成器代码，ES7引入了async/awit，实现了更加直观简洁的代码。<br>async/aswit技术背后的实现就是Promise和生成器应用。往底层说就是微服务和协程应用。</p></blockquote><blockquote><p>async: 是一个通过异步执行并隐式返回Promise作为结果的函数。<br>await: 我们知道了 async 函数返回的是一个 Promise 对象，那下面我们再结合文中这段代码来看看 await 到底是什么。   </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async function foo() &#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">    let a = await 100</span><br><span class="line">    console.log(a)</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;</span><br><span class="line">console.log(0)</span><br><span class="line">foo()</span><br><span class="line">console.log(3)</span><br><span class="line">//输出结果：0 3 100 2</span><br></pre></td></tr></table></figure><blockquote><p>async/await 无疑是异步编程领域非常大的一个革新，也是未来的一个主流的编程风格。其实，除了 JavaScript，Python、Dart、C# 等语言也都引入了 async/await，使用它不仅能让代码更加整洁美观，而且还能确保该函数始终都能返回 Promise。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot;&gt;&lt;a href=&quot;#前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot; class=&quot;headerlink&quot; title=&quot;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot;&gt;&lt;/a&gt;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&lt;/h6&gt;&lt;h6 id=&quot;本篇是这个专栏的第四章：《浏览器中的页面循环系统》。本章分为六节。&quot;&gt;&lt;a href=&quot;#本篇是这个专栏的第四章：《浏览器中的页面循环系统》。本章分为六节。&quot; class=&quot;headerlink&quot; title=&quot;本篇是这个专栏的第四章：《浏览器中的页面循环系统》。本章分为六节。&quot;&gt;&lt;/a&gt;本篇是这个专栏的第四章：《浏览器中的页面循环系统》。本章分为六节。&lt;/h6&gt;
    
    </summary>
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>每周总结第二十期</title>
    <link href="http://liugezhou.online/2019/11/24/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93%E7%AC%AC%E4%BA%8C%E5%8D%81%E6%9C%9F/"/>
    <id>http://liugezhou.online/2019/11/24/每周总结第二十期/</id>
    <published>2019-11-24T08:50:00.000Z</published>
    <updated>2019-11-25T02:15:31.390Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这里记录过去一周，我的一些小总结。</p></blockquote><a id="more"></a><h4 id="Feeling"><a href="#Feeling" class="headerlink" title="Feeling"></a>Feeling</h4><blockquote><p>本周并没有总结什么。<br>只是最近几周有个感觉，更是事实，那些写技术文章的公号里充满了软文宣传、推广。<br>技术公号的文章凡是过千的便是一个有些影响力的传播媒介了。连阮一峰这种大牛级别的公众号文章的阅读量也不过万。<br>对于商业卖课者来说，公众号的每一个阅读量都代表了那些实打实的目标群体客户都接受到了广告的洗礼，<br>群体性的技术公号集体沦陷开始卖课，这应该就是那种说程序员技术变现的广泛实例。<br>我只是很好奇这种一篇推广文，会给开发者多少广告费用。 </p></blockquote><h4 id="琅琊榜图谱"><a href="#琅琊榜图谱" class="headerlink" title="琅琊榜图谱"></a>琅琊榜图谱</h4><blockquote><p>周末倍速在家刷了一遍琅琊榜，理不清谁的谁是谁的谁：</p><p>梅长苏的爸爸是林燮(xie)。<br>林燮的妹妹是宸妃.<br>宸妃的儿子是祁王–&gt; 祁王的儿子是庭生。<br>宸妃的老公是粱王。</p><p>梅长苏的妈妈是晋阳长公主。<br>晋阳长公主的哥哥是粱王。</p><p>晋阳长公主的妹妹是莅阳长公主.<br>莅阳长公主的丈夫是谢玉。</p><p>莅阳长公主的情人是南楚晟王宇文霖。<br>宇文霖的亲生儿子是萧景睿。</p><p>粱王还有个老婆是静妃，静妃的儿子是靖王。<br>粱王还有个老婆是越贵妃，越贵妃的儿子是太子。<br>粱王还有个老婆是言皇后，言皇后的养子是誉王。 </p><p>梅长苏赤焰军旧部里面有个叫聂峰。<br>聂峰的老婆是夏冬。<br>夏冬的师哥是夏秋。<br>夏冬的师傅是夏江。</p><p>……</p></blockquote><h4 id="网传网易让保安将绝症员工赶出公司"><a href="#网传网易让保安将绝症员工赶出公司" class="headerlink" title="网传网易让保安将绝症员工赶出公司"></a>网传网易让保安将绝症员工赶出公司</h4><blockquote><p>我们大家都知道不应该因为一个员工事件来骂网易云音乐或者任何的网易应用。<br>只是大家需要一个有个官方账号的回应。<br>大家维护的不仅仅是这一起人血馒头事件。<br>更加维护的是自己的生存社会环境。<br>【每个人对于他所处的社会都负有责任，这个社会的弊病需要每一个人去维护】。</p></blockquote><h4 id="曾文正公全集"><a href="#曾文正公全集" class="headerlink" title="曾文正公全集"></a>曾文正公全集</h4><blockquote><p>盖士人读书，第一要有志，第二要有识，第三要有恒。有志则不甘为下流；有识则知学问无尽，不敢以一得自足，如河伯之观海，如井蛙之窥天，皆无识者也；有恒则断无不成之事。此三者缺一不可。诸弟此时惟有识不可以骤几；至于有志，有恒，则诸弟勉之而已。<br>中心思想：要学会读书。<br><cite>引自《曾文正公全集》</cite></p></blockquote><h4 id="CSS定位详解"><a href="#CSS定位详解" class="headerlink" title="CSS定位详解"></a><a href="http://www.ruanyifeng.com/blog/2019/11/css-position.html" target="_blank" rel="noopener">CSS定位详解</a></h4><blockquote><p>CSS 有两个最重要的基本属性，前端开发必须掌握：display 和 position。<br>display属性指定网页的布局。两个重要的布局，弹性布局<code>flex</code>和网格布局<code>grid</code>。<br>本文介绍非常有用的position属性。作者希望通过10分钟的阅读，帮助大家轻松掌握网页定位，说清楚浏览器如何计算网页元素的位置，尤其是新引进的<code>sticky</code>定位.   </p></blockquote><h4 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h4><blockquote><p>iOS APP FOR BETA 版本已经预约两个星期了，还是没有下文，真是让人焦灼。 </p></blockquote><h4 id="No3-V8工作原理"><a href="#No3-V8工作原理" class="headerlink" title="No3.V8工作原理"></a><a href="https://www.liugezhou.online/2019/11/21/No3.V8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">No3.V8工作原理</a></h4><blockquote><p>前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。<br>本篇是这个专栏的第三章：<a href="https://www.liugezhou.online/2019/11/21/No3.V8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">No3.V8工作原理</a>。本章分为三讲。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这里记录过去一周，我的一些小总结。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="每周分享" scheme="http://liugezhou.online/categories/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="每周分享" scheme="http://liugezhou.online/tags/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>No3.V8工作原理</title>
    <link href="http://liugezhou.online/2019/11/21/No3.V8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://liugezhou.online/2019/11/21/No3.V8工作原理/</id>
    <published>2019-11-21T13:40:00.000Z</published>
    <updated>2019-11-21T01:56:53.220Z</updated>
    
    <content type="html"><![CDATA[<h6 id="前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。"><a href="#前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。" class="headerlink" title="前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。"></a>前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。</h6><h6 id="本篇是这个专栏的第三章：《V8工作原理》。本章分为三节。"><a href="#本篇是这个专栏的第三章：《V8工作原理》。本章分为三节。" class="headerlink" title="本篇是这个专栏的第三章：《V8工作原理》。本章分为三节。"></a>本篇是这个专栏的第三章：《V8工作原理》。本章分为三节。</h6><a id="more"></a><h4 id="12｜栈空间和堆空间：数据是如何存储的？"><a href="#12｜栈空间和堆空间：数据是如何存储的？" class="headerlink" title="12｜栈空间和堆空间：数据是如何存储的？"></a>12｜栈空间和堆空间：数据是如何存储的？</h4><hr><h5 id="JavaScript是什么类型的语言"><a href="#JavaScript是什么类型的语言" class="headerlink" title="JavaScript是什么类型的语言"></a>JavaScript是什么类型的语言</h5><blockquote><p>在使用之前就需要确认其变量数据类型的语言称为<code>静态语言</code>，相反地，我们把运行过程中需要检查数据类型的语言称为<code>动态语言</code>。<br>我们把变量直接可以偷偷进行转换的操作称为隐式类型转换，支持隐式类型的语言称为<code>弱类型语言</code>，不支持隐式类型转换的语言称为<code>强类型语言</code>。      </p></blockquote><blockquote><p>显然，JavaScript是动态弱类型语言。    </p></blockquote><h5 id="JavaScript的数据类型"><a href="#JavaScript的数据类型" class="headerlink" title="JavaScript的数据类型"></a>JavaScript的数据类型</h5><blockquote><p>JavaScript的数据类型一共有八种：<br>基本数据类型：Boolean、Undefined、Null、String、Number、Bigint、Symbol<br>引用数据类型：Object  </p></blockquote><h5 id="内存空间"><a href="#内存空间" class="headerlink" title="内存空间"></a>内存空间</h5><blockquote><p>在JavaScript的执行过程中，主要有三种类型内存空间：代码空间、栈空间、堆空间。<br>原始类型的数据值都是直接保存在栈中的，引用类型的值都是保存在堆空间中的。<br>通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。堆空间很大，能存放很多大的数据。<br>原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。    </p></blockquote><h5 id="产生闭包的核心"><a href="#产生闭包的核心" class="headerlink" title="产生闭包的核心"></a>产生闭包的核心</h5><blockquote><p>第一步是需要预扫描内部函数。<br>第二步是把内部函数引用的外部变量保存到堆中。  </p></blockquote><h4 id="13-｜-垃圾回收：垃圾数据是如何自动回收的？"><a href="#13-｜-垃圾回收：垃圾数据是如何自动回收的？" class="headerlink" title="13 ｜ 垃圾回收：垃圾数据是如何自动回收的？"></a>13 ｜ 垃圾回收：垃圾数据是如何自动回收的？</h4><hr><blockquote><p>对一些不需要的数据，我们称之为垃圾数据，由于内存是有限的，为了释放内存，我们需要对这么垃圾数据进行回收。  </p></blockquote><h5 id="不同语言的垃圾回收策略"><a href="#不同语言的垃圾回收策略" class="headerlink" title="不同语言的垃圾回收策略"></a>不同语言的垃圾回收策略</h5><blockquote><p>通常情况，垃圾回收分为手动回收到自动回收两种策略。<br>如C/C++C++使用的是手动回收策略，何时分配内存、何时销毁内存都是由代码控制的。<br>如JavaScript、Java、Python等语言使用的是自动回收策略，产生的垃圾数据是由垃圾回收器来释放的。  </p></blockquote><h5 id="调用栈中的数据是如何回收的"><a href="#调用栈中的数据是如何回收的" class="headerlink" title="调用栈中的数据是如何回收的"></a>调用栈中的数据是如何回收的</h5><blockquote><p>栈中的垃圾回收相对比较简单：JavaScript引擎会通过向下移动ESP来销毁该函数保存在栈中的执行上下文。<br>ESP：记录当前执行状态的指针。</p></blockquote><h5 id="堆中的数据是如何回收的"><a href="#堆中的数据是如何回收的" class="headerlink" title="堆中的数据是如何回收的"></a>堆中的数据是如何回收的</h5><blockquote><p>要回收堆中的数据，需要用到JavaScript中的垃圾回收器。</p></blockquote><blockquote><p>在介绍V8如何实现回收之前，首先要了解下<code>代际假说</code>内容。这是垃圾回收领域一个重要的术语，代际假说有两个特点：    </p><ul><li>第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问.  </li><li>第二个是不死的对象，会活得更久.<br>这两个特点不仅仅适用于JavaScript，同样适应于大多数动态语言，如Java、Python等。    </li></ul></blockquote><blockquote><p>在V8中会把堆分为新生代(支持1-8M容量)和老生代(容量大很多)两个区域，新生代中存放的是生存时间短的对象，老生代中存放的是生存时间久的对象。  </p><ul><li>副垃圾回收器，主要负责新生代的垃圾回收。    </li><li>主垃圾回收器，主要负责老生代的垃圾回收。   </li></ul></blockquote><h5 id="垃圾回收器的工作流程"><a href="#垃圾回收器的工作流程" class="headerlink" title="垃圾回收器的工作流程"></a>垃圾回收器的工作流程</h5><blockquote><p>不论是主垃圾回收器还是副垃圾回收器，它们都有一套共同的执行流程。  </p><ul><li>第一步为标记活动对象与非活动对象。活动对象为还在使用的对象，非活动对象为要准备进行垃圾回收的对象。  </li><li>第二步是回收非活动对象所占用的内存。既在标记后统一清理被标记为可回收的对象的内存。    </li><li>第三步是内存整理。这是因为在频繁回收对象后，内存中会存在不连续空间，把这些不连续空间称为内存碎片。因此需要整理这些碎片，这是为了当那些较大连续内存出现时可以方便分配。【这步是可选的，副垃圾回收器不会产生内存碎片】。<br>然后按照上述流程来分析新生代垃圾回收器（副垃圾回收器）和老生代垃圾回收器（主垃圾回收器）是如何处理垃圾回收的。    </li></ul></blockquote><h5 id="副垃圾回收器"><a href="#副垃圾回收器" class="headerlink" title="副垃圾回收器"></a>副垃圾回收器</h5><blockquote><p>副垃圾回收器主要负责新生代区的垃圾回收，虽然老生代区域不大，但是垃圾回收比较频繁。<br>新生代中用Scavenge算法来处理。【Scavenge算法：把新生代空间对半划分为两个区域，一个是对象区域，一个是空闲区域。】<br>过程大概就是：新加入对象放入都对象区域，快写满时进行垃圾清理操作，副垃圾回收器把这些对象复制到空闲区域，复制后的空闲区域没有内存碎片。完成复制后，对象区域与空闲区域角色翻转。角色翻转的操作能让新生代中的两块区域无限重复使用下去。<br>因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。</p></blockquote><h5 id="主垃圾回收器"><a href="#主垃圾回收器" class="headerlink" title="主垃圾回收器"></a>主垃圾回收器</h5><blockquote><p>主垃圾回收器主要负责老生区中的垃圾回收.<br>老生区中对象的两个特点：一是存活时间长，二是对象占用空间大。<br>由特点我们知道采用副垃圾回收器的Scavenge算法显然不满足需求，因此，主垃圾回收器采用的是<code>标记-清除（Mark-Sweep）</code>算法进行垃圾回收。碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——<code>标记 - 整理（Mark-Compact）</code> .</p></blockquote><h4 id="14-编译器和解释器：V8是如何执行一段JavaScript代码的"><a href="#14-编译器和解释器：V8是如何执行一段JavaScript代码的" class="headerlink" title="14 | 编译器和解释器：V8是如何执行一段JavaScript代码的"></a>14 | 编译器和解释器：V8是如何执行一段JavaScript代码的</h4><hr><blockquote><p>深入了解V8的工作原理，我们需要弄清除一些概念和原理，比如本节要学习的：<code>编译器(Compiler)</code>、<code>解释器(Interpreter)</code>、<code>抽象语法树(AST)</code>、<code>字节码(Bytecode)</code>、<code>即时编译器(JIT)</code>等概念。 </p></blockquote><h5 id="编译器和解释器"><a href="#编译器和解释器" class="headerlink" title="编译器和解释器"></a>编译器和解释器</h5><blockquote><p>编译器和解释器“翻译”代码的流程大致可阐述如下：    </p><ol><li>在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功。    </li><li>在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。    </li></ol></blockquote><h5 id="V8是如何执行一段JavaScript代码的"><a href="#V8是如何执行一段JavaScript代码的" class="headerlink" title="V8是如何执行一段JavaScript代码的"></a>V8是如何执行一段JavaScript代码的</h5><blockquote><p>V8在执行过程中既有解释器，又有编译器。分解其执行流程如下：    </p></blockquote><h6 id="1-生成抽象语法树-AST-和执行上下文"><a href="#1-生成抽象语法树-AST-和执行上下文" class="headerlink" title="1.生成抽象语法树(AST)和执行上下文"></a>1.生成抽象语法树(AST)和执行上下文</h6><blockquote><p>那么这个抽象语法树AST是什么呢？<br>首先我们知道高级语言只是开发者可以理解的语言，但是让编译器或者解释器来理解就非常困难了。对于编译器或者解释器来说，他可以理解的是AST，所以无论是解释性语言还是编译型语言，在编译过程中，都会生成一个AST。<br>一段代码经过javascript-ast站点处理后，AST的结构和代码结构非常之相似，具体结构就不展示了，类似于DOM树。AST的生成需要经过两个阶段： </p><ul><li>第一阶段是<code>分词</code>，又称为<code>词法分析</code>。其作用是将一行行的源码拆解成一个个 token。所谓 token，指的是语法上不可能再分的、最小的单个字符或字符串。  </li><li>第二阶段是<code>解析</code>,又称为<code>语法分析</code>。其作用是将上一步生成的 token 数据，根据语法规则转为 AST。    </li></ul></blockquote><h6 id="2-生成字节码"><a href="#2-生成字节码" class="headerlink" title="2.生成字节码"></a>2.生成字节码</h6><blockquote><p>有了 AST 和执行上下文后，那接下来的第二步，解释器 Ignition 就登场了，它会根据 AST 生成字节码，并解释执行字节码。<br>字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行.之所以出现字节码，是Chrome团队为了解决内存占用问题而引入的。    </p></blockquote><h6 id="3-执行代码"><a href="#3-执行代码" class="headerlink" title="3.执行代码"></a>3.执行代码</h6><blockquote><p>生成字节码之后，接下来就进入了执行阶段。<br>在执行阶段，通常解释器逐条执行字节码，如果发现有热点代码(一段代码被重复执行多次)，那后台编译器会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了。这种字节码配合解释器和编译器的技术就称为<code>即时编译(JIT)</code>.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot;&gt;&lt;a href=&quot;#前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot; class=&quot;headerlink&quot; title=&quot;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot;&gt;&lt;/a&gt;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&lt;/h6&gt;&lt;h6 id=&quot;本篇是这个专栏的第三章：《V8工作原理》。本章分为三节。&quot;&gt;&lt;a href=&quot;#本篇是这个专栏的第三章：《V8工作原理》。本章分为三节。&quot; class=&quot;headerlink&quot; title=&quot;本篇是这个专栏的第三章：《V8工作原理》。本章分为三节。&quot;&gt;&lt;/a&gt;本篇是这个专栏的第三章：《V8工作原理》。本章分为三节。&lt;/h6&gt;
    
    </summary>
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>每周总结第十九期</title>
    <link href="http://liugezhou.online/2019/11/17/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93%E7%AC%AC%E5%8D%81%E4%B9%9D%E6%9C%9F/"/>
    <id>http://liugezhou.online/2019/11/17/每周总结第十九期/</id>
    <published>2019-11-17T09:45:00.000Z</published>
    <updated>2019-11-17T09:49:24.318Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这里记录过去一周，我的一些小总结。</p></blockquote><a id="more"></a>。<p><img src="http://img.liugezhou.online/weekly19" alt="weekly-19"></p><h4 id="Feeling"><a href="#Feeling" class="headerlink" title="Feeling"></a>Feeling</h4><blockquote><p>由于自己的职业关系，比较关注一些技术、软件、工具、科技等方面的讯息。<br>这些讯息的爆炸、扩散，让我一次又一次在潜意识里提醒自己：淡定下来，无论窗外之事多么热闹，都不要影响自己的心态，按着自己的节奏去学习、吸收、渗透。</p></blockquote><h4 id="Idea永久激活"><a href="#Idea永久激活" class="headerlink" title="Idea永久激活"></a><a href="https://mp.weixin.qq.com/s/1VBxhZNC4kq2KckT6Jqwfw" target="_blank" rel="noopener">Idea永久激活</a></h4><blockquote><p>Idea工具30天体验结束，找了一些网上的激活方法，大多方法都失效了，最终在这篇文章的指引下，成功激活，推荐推荐。<br>激活传送门：<a href="https://mp.weixin.qq.com/s/1VBxhZNC4kq2KckT6Jqwfw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/1VBxhZNC4kq2KckT6Jqwfw</a></p></blockquote><h4 id="GitLens"><a href="#GitLens" class="headerlink" title="GitLens"></a>GitLens</h4><blockquote><p>它是 VSCode 中非常令人推荐的一个插件，简直是Git神器，码农必备。 每一行代码旁边都有日志，代码是谁提交的一目了然。   </p></blockquote><h4 id="Gitbook"><a href="#Gitbook" class="headerlink" title="Gitbook"></a>Gitbook</h4><blockquote><p>Gitbook编写在线文档，可以非常方便快速的将自己的md、html、zip、docx等文件倒入，实现快速部署。<br>不需域名、不需其他的任何配置，即可快速实现在线浏览。<br>但是需要<code>过墙</code>。<br>我花了十分钟导入两篇文章后的效果：<a href="https://mingzhou.gitbook.io/liugezhou/" target="_blank" rel="noopener">https://mingzhou.gitbook.io/liugezhou/</a></p></blockquote><h4 id="诺基亚老照片"><a href="#诺基亚老照片" class="headerlink" title="诺基亚老照片"></a>诺基亚老照片</h4><blockquote><p>这个工具可以生成老式诺基亚手机的短信图片。<br>网页版：<a href="https://zzkia.noddl.me:8020" target="_blank" rel="noopener">https://zzkia.noddl.me:8020</a><br>微信小程序：【次元蜜蜂】。  </p></blockquote><h4 id="Github-for-mobile-iOS-beta"><a href="#Github-for-mobile-iOS-beta" class="headerlink" title="Github for mobile iOS beta"></a><a href="https://github.com/mobile" target="_blank" rel="noopener">Github for mobile iOS beta</a></h4><blockquote><p>11 月 13 日，GitHub 年度开发者大会—GitHub Universe 2019 在美国旧金山举行。<br>为改善用户体验，GitHub 在本次大会上宣布推出移动端，即 GitHub App 。<br>目前，官方已经上线 iOS 版，不过，却是 beta（公测版），因此用户暂时无法通过 App Store 下载，可以通过官方渠道下载尝鲜。<br>但是，我等</p></blockquote><h4 id="Bytespider"><a href="#Bytespider" class="headerlink" title="Bytespider"></a>Bytespider</h4><blockquote><p>[很多社区用户纷纷反馈，一种名为 Bytespider 的爬虫爬取他们的网站信息的频率太高，直接把网站搞瘫痪了。大家顺着爬虫的 IP 地址查了一下，发现 Bytespider 应该就是今日头条的搜索爬虫。]<sup><a href="https://mp.weixin.qq.com/s/KXg8xAf_TOAROMhqJVQQBQ" target="_blank" rel="noopener">来源</a></sup>  </p></blockquote><blockquote><p>robots.txt 协议:<br>也称为爬虫协议、爬虫规则、机器人协议等。robots.txt文件是存储在网站根目录下的 txt 文本文档。这是网站和蜘蛛之间的协议。该网站告诉搜索引擎哪些页面可以被抓取，哪些页面不想通过机器人协议被抓取。</p></blockquote><h4 id="浏览器中的JavaScript执行机制"><a href="#浏览器中的JavaScript执行机制" class="headerlink" title="浏览器中的JavaScript执行机制"></a><a href="https://www.liugezhou.online/2019/11/11/No2.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JavaScript%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">浏览器中的JavaScript执行机制</a></h4><blockquote><p>前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。<br>本篇是这个专栏的第二章：<a href="https://www.liugezhou.online/2019/11/11/No2.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JavaScript%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">浏览器中的JavaScript执行机制</a>。本章分为五讲。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这里记录过去一周，我的一些小总结。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="每周分享" scheme="http://liugezhou.online/categories/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="每周分享" scheme="http://liugezhou.online/tags/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>No2.浏览器中的JavaScript执行机制</title>
    <link href="http://liugezhou.online/2019/11/11/No2.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JavaScript%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <id>http://liugezhou.online/2019/11/11/No2.浏览器中的JavaScript执行机制/</id>
    <published>2019-11-11T13:40:00.000Z</published>
    <updated>2019-11-15T03:24:38.142Z</updated>
    
    <content type="html"><![CDATA[<h6 id="前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。"><a href="#前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。" class="headerlink" title="前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。"></a>前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。</h6><h6 id="本篇是这个专栏的第二章：《浏览器中的JavaScript执行机制》。本章分为五节。"><a href="#本篇是这个专栏的第二章：《浏览器中的JavaScript执行机制》。本章分为五节。" class="headerlink" title="本篇是这个专栏的第二章：《浏览器中的JavaScript执行机制》。本章分为五节。"></a>本篇是这个专栏的第二章：《浏览器中的JavaScript执行机制》。本章分为五节。</h6><a id="more"></a><h4 id="07｜变量提升：JavaScript代码是按顺序执行的吗？"><a href="#07｜变量提升：JavaScript代码是按顺序执行的吗？" class="headerlink" title="07｜变量提升：JavaScript代码是按顺序执行的吗？"></a>07｜变量提升：JavaScript代码是按顺序执行的吗？</h4><hr><blockquote><p>本节主要讲解<code>执行上下文</code>相关的内容。</p></blockquote><blockquote><p>通过一些代码的执行顺序与经验我们知道：    </p><ul><li>在执行过程中，若使用了未声明的变量，那么 JavaScript 执行会报错。    </li><li>在一个变量定义之前使用它，不会出错，但是该变量的值会为 undefined，而不是定义时的值。    </li><li>在一个函数定义之前使用它，不会出错，且函数能正确执行。</li></ul></blockquote><h5 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h5><blockquote><p>所谓的变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined.<br>之所以会发生变量提升，是因为一段JavaScript代码在执行之前，需要被JavaScript引擎编译，编译完成之后，才会进入执行阶段。也就是说在编译阶段，变量和函数的声明提升到了开头。    </p></blockquote><h4 id="08-｜调用栈：为什么JavaScript代码会出现栈溢出？"><a href="#08-｜调用栈：为什么JavaScript代码会出现栈溢出？" class="headerlink" title="08 ｜调用栈：为什么JavaScript代码会出现栈溢出？"></a>08 ｜调用栈：为什么JavaScript代码会出现栈溢出？</h4><hr><blockquote><p>一般有三种情况，当一段代码执行的时候JS引擎对其进行编译并创建执行上下文：</p><ol><li>当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份.  </li><li>当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。   </li><li>当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。</li></ol></blockquote><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><blockquote><ul><li>每调用一个函数，JavaScript 引擎会为其创建执行上下文，并把该执行上下文压入调用栈，然后 JavaScript 引擎开始执行函数代码。 </li><li>如果在一个函数 A 中调用了另外一个函数 B，那么 JavaScript 引擎会为 B 函数创建执行上下文，并将 B 函数的执行上下文压入栈顶。   </li><li>当前函数执行完毕后，JavaScript 引擎会将该函数的执行上下文弹出栈。   </li><li>当分配的调用栈空间被占满时，会引发“堆栈溢出”问题。</li></ul></blockquote><h4 id="09-块级作用域：var缺陷以及为什么要引入let和const"><a href="#09-块级作用域：var缺陷以及为什么要引入let和const" class="headerlink" title="09 | 块级作用域：var缺陷以及为什么要引入let和const"></a>09 | 块级作用域：var缺陷以及为什么要引入let和const</h4><hr><h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><blockquote><p>作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。<br>ES6出现之前，JS的作用域只有两种：<code>全局作用域</code>和<code>函数作用域</code>。 ES6出现，引入了<code>块级作用域</code>。</p></blockquote><h5 id="在同一段代码中，ES6-是如何做到既要支持变量提升的特性，又要支持块级作用域的呢？"><a href="#在同一段代码中，ES6-是如何做到既要支持变量提升的特性，又要支持块级作用域的呢？" class="headerlink" title="在同一段代码中，ES6 是如何做到既要支持变量提升的特性，又要支持块级作用域的呢？"></a>在同一段代码中，ES6 是如何做到既要支持变量提升的特性，又要支持块级作用域的呢？</h5><blockquote><p>当一段代码里面既有var声明的变量也有let声明的变量的时候：  </p><ul><li>函数内部通过var声明的变量，在编译阶段全都被存放到<code>变量环境</code>里面.  </li><li>通过let声明的变量，在编译阶段会被存放到<code>词法环境</code>中。 </li><li>在函数作用域内部，通过let声明的变量并没有被存放到词法环境中。<br>也就是说：通过理解词法环境的结构和工作机制，块级作用域是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现的，通过两者的结合，JavaScript引擎也就同时支持了变量 提升和块级作用域了。</li></ul></blockquote><h4 id="10-｜-作用域和闭包：代码中出现相同的变量，JavaScript引擎是如何选择的"><a href="#10-｜-作用域和闭包：代码中出现相同的变量，JavaScript引擎是如何选择的" class="headerlink" title="10 ｜ 作用域和闭包：代码中出现相同的变量，JavaScript引擎是如何选择的"></a>10 ｜ 作用域和闭包：代码中出现相同的变量，JavaScript引擎是如何选择的</h4><hr><h5 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h5><blockquote><p>理解作用域链是理解闭包的基础，而闭包在JavaScript中无处不在，同时作用域和作用域链还是作用语言的基础，所以我们先来学习一下<code>作用域链</code>。<br>理解了调用栈、执行上下文、词法环境、变量环境等概念，那么你理解起来作用域链也会很容易,看下面一段代码：</p><pre><code>function bar() {   console.log(myName)}function foo() {   var myName = &quot;局部变量&quot;   bar()}var myName = &quot;全局变量&quot;foo()</code></pre><p>通过上面的代码，我们知道最终打印出来的结果是：”全局变量“。<br>这是因为，当一段代码使用了一个变量后，JavaScript引擎会首先在“当前的执行上下文”中去查找该变量。若没有找到，由于每个执行上下文都包含一个外部引用指向外部执行上下文，所以bar函数中的变量会去全局上下文中区域查找。我们把这个查找的链条就称为作用域链。</p></blockquote><h5 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h5><blockquote><p>foo 函数调用的 bar 函数，那为什么 bar 函数的外部引用是全局执行上下文，而不是 foo 函数的执行上下文？了解这个问题我们继续来学习词法作用域：<br>词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。<br>然后，根据词法作用域，foo 和 bar 的上级作用域都是全局作用域，所以如果 foo 或者 bar 函数使用了一个它们没有定义的变量，那么它们会到全局作用域去查找。也就是说，词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系。</p></blockquote><h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><blockquote><p>在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。<br>在使用闭包的时候，要尽量注意一个原则：如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。</p></blockquote><h4 id="11-｜-this：从JavaScript执行上下文的视角讲清楚this"><a href="#11-｜-this：从JavaScript执行上下文的视角讲清楚this" class="headerlink" title="11 ｜ this：从JavaScript执行上下文的视角讲清楚this"></a>11 ｜ this：从JavaScript执行上下文的视角讲清楚this</h4><hr><blockquote><p>首先我们要知道，在对象内部的方法中使用对象内部的属性是一个非常普遍的需求，但是JavaScript作用域机制并不支持这一点，基于这个需求，JavaScript搞出了一套this机制。    </p></blockquote><blockquote><p>在前几节中，我们提到执行上下文中包含了：<code>变量环境</code>、<code>词法环境</code>、<code>外部环境</code>、还有一个没有提及的<code>this</code>,this是和执行上下文绑定的，每个执行上下文都有一个this。<br>在08节我们总结了执行上下文主要分三种：全局执行上下文、函数执行上下文和eval执行上下文。<br>对应的this也只有这三种：全局执行上下文中的this、函数执行上下中的this和eval中的this(不做讨论)。    </p><ul><li>全局执行上下文中的this：全局执行上下文中的this指向window对象。  </li><li>函数执行上下文中的this：<ol><li>默认情况下调用一个函数，其执行上下文中的 this 也是指向 window 对象的.  </li><li>通过函数的call方法设置其this指向其他对象（还可以使用bind和apply方法来设置函数执行上下文中的this）。   </li><li>通过对象调用方法设置。（使用对象来调用其内部的一个方法，该方法的 this 是指向对象本身的。在全局环境中调用一个函数，函数内部的this指向的是全局变量window）。   </li><li>通过构造函数中设置。   </li></ol></li></ul></blockquote><h5 id="this的设计缺陷以及应对方案"><a href="#this的设计缺陷以及应对方案" class="headerlink" title="this的设计缺陷以及应对方案"></a>this的设计缺陷以及应对方案</h5><blockquote><ol><li>嵌套函数的this不会从外层函数中继承。==&gt;  1⃣️、将this保存一个self变量，利用变量作用域机制传递给嵌套函数。2⃣️、将乔套函数改为箭头函数。   </li><li>普通函数中的this默认指向全局对象window。==&gt;可以通过设置JavaScript的“严格模式”来解决。</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot;&gt;&lt;a href=&quot;#前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot; class=&quot;headerlink&quot; title=&quot;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot;&gt;&lt;/a&gt;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&lt;/h6&gt;&lt;h6 id=&quot;本篇是这个专栏的第二章：《浏览器中的JavaScript执行机制》。本章分为五节。&quot;&gt;&lt;a href=&quot;#本篇是这个专栏的第二章：《浏览器中的JavaScript执行机制》。本章分为五节。&quot; class=&quot;headerlink&quot; title=&quot;本篇是这个专栏的第二章：《浏览器中的JavaScript执行机制》。本章分为五节。&quot;&gt;&lt;/a&gt;本篇是这个专栏的第二章：《浏览器中的JavaScript执行机制》。本章分为五节。&lt;/h6&gt;
    
    </summary>
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>每周总结第十八期</title>
    <link href="http://liugezhou.online/2019/11/10/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93%E7%AC%AC%E5%8D%81%E5%85%AB%E6%9C%9F/"/>
    <id>http://liugezhou.online/2019/11/10/每周总结第十八期/</id>
    <published>2019-11-10T09:35:00.000Z</published>
    <updated>2019-11-10T12:55:38.915Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这里记录过去一周，我的一些小总结。</p></blockquote><a id="more"></a><h4 id="Feeling"><a href="#Feeling" class="headerlink" title="Feeling"></a>Feeling</h4><blockquote><p>大部分人不表达是因为没什么可表达的，只是脑子里没货，而不是不愿意表达。<br>人们说自己无法坚持做一件事，其实既缺乏坚持的能力，也缺少做事的能力。<br>非不为也，实不能也。 –From <a href="https://twitter.com/sagacity/status/1193346629287366656" target="_blank" rel="noopener">Twitter</a></p></blockquote><h4 id="碾压苹果！全球最赚钱的公司要上市了"><a href="#碾压苹果！全球最赚钱的公司要上市了" class="headerlink" title="碾压苹果！全球最赚钱的公司要上市了"></a><a href="http://global.eastmoney.com/a/201911051281700917.html" target="_blank" rel="noopener">碾压苹果！全球最赚钱的公司要上市了</a></h4><blockquote><p>沙特的阿美石油公司（Aramco）是全球最赚钱公司，决定进行 IPO。它的石油产量占全球的10％，去年净利润为1110亿美元，比苹果+谷歌+埃克森美孚还要多。该公司的总市值可能会到2万亿美元，目前世界市值最大的公司也只有1万亿美元。 </p></blockquote><h4 id="GitLab-公开拒收中国员工，你怎么看？！"><a href="#GitLab-公开拒收中国员工，你怎么看？！" class="headerlink" title="GitLab 公开拒收中国员工，你怎么看？！"></a><a href="https://www.oschina.net/news/111073/gitlab-reject-chinese-programmers" target="_blank" rel="noopener">GitLab 公开拒收中国员工，你怎么看？！</a></h4><blockquote><p>本周争论话题。<br>在GitLab.com的官方issue里，出现这样一条：我们决定对有权访问客户数据的团队成员启用“工作国家/地区封锁（job family country block）”，而封锁名单上只有两个国家——中国和俄罗斯。<br>根据GitLab的解释，意味着：</p><ul><li>GitLab不会给中国/俄罗斯公民提供Offer；</li><li>那些有权限访问客户数据的员工，现在也不能移居到中国或俄罗斯。</li></ul></blockquote><h4 id="utools"><a href="#utools" class="headerlink" title="utools"></a><a href="https://u.tools/" target="_blank" rel="noopener">utools</a></h4><blockquote><p>「uTools是一个极简、插件化、跨平台的现代桌面软件。通过自由选配丰富的插件，打造你得心应手的工具集合。<br>当你熟悉它后，能够为你节约大量时间，让你可以更加专注地改变世界。」</p></blockquote><blockquote><ul><li>通过快捷键（默认alt+space）就可以快速呼出搜索框.搜索框相当聪明。    </li><li>优秀的插件化设计，自取所需，随用随走。</li><li>只需会JavaScript、CSS、HTML就可以从零开始创造一个utools插件。</li><li>非常推荐，初上手感觉比浏览器插件好用好多。</li></ul></blockquote><h4 id="electronjs"><a href="#electronjs" class="headerlink" title="electronjs"></a><a href="https://electronjs.org/" target="_blank" rel="noopener">electronjs</a></h4><blockquote><p>如果你可以建一个网站，你就可以建一个桌面应用程序。 Electron 是一个使用 JavaScript, HTML 和 CSS 等 Web 技术创建原生程序的框架，它负责比较难搞的部分，你只需把精力放在你的应用的核心上即可。</p><ul><li>Web 技术: Electron 基于 Chromium 和 Node.js, 让你可以使用 HTML, CSS 和 JavaScript 构建应用。 </li><li>开源: Electron 是一个由 GitHub 及众多贡献者组成的活跃社区共同维护的开源项目。    </li><li>跨平台: Electron 兼容 Mac、Windows 和 Linux，可以构建出三个平台的应用程序。 </li></ul></blockquote><blockquote><p>尝试：npm install 过程中竟然第一次遇到了墙，即使开着vpn也于是无补。查找资料：<a href="https://www.jianshu.com/p/f134878af30f" target="_blank" rel="noopener">electron快速入门笔记</a>，更换淘宝镜像，启动成功。<br><img src="http://img.liugezhou.online/electron_lgz.png" alt="效果展示"></p></blockquote><h4 id="宏观视角下的浏览器"><a href="#宏观视角下的浏览器" class="headerlink" title="宏观视角下的浏览器"></a><a href="https://www.liugezhou.online/2019/11/03/%E5%AE%8F%E8%A7%82%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8/" target="_blank" rel="noopener">宏观视角下的浏览器</a></h4><blockquote><p>前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。<br>本篇是这个专栏的第一章：<a href="https://www.liugezhou.online/2019/11/03/" target="_blank" rel="noopener">宏观视角下的浏览器</a>。本章分为六讲。</p></blockquote><h4 id="Top-languages-over-time"><a href="#Top-languages-over-time" class="headerlink" title="Top languages over time"></a><a href="https://octoverse.github.com/#top-languages-over-time" target="_blank" rel="noopener">Top languages over time</a></h4><blockquote><p>This year, C# and  shell climbed the list,And for the first time ,Python outranked Java as the second most popular language on Github by repository contributors.</p></blockquote><h4 id="如何比较-Java-的字符串？"><a href="#如何比较-Java-的字符串？" class="headerlink" title="如何比较 Java 的字符串？"></a><a href="https://mp.weixin.qq.com/s/WyrRCUlelzOxyfVBrxAGUg" target="_blank" rel="noopener">如何比较 Java 的字符串？</a></h4><blockquote><p>Stack Overflow上一个访问370万+的问题：如何比较Java的字符串。<br>也就是说<code>==</code>操作符与<code>.equals()</code>方法之间有什么区别呢？ </p></blockquote><blockquote><p><code>结论</code></p><ul><li>当比较两个字符串对象的内容是否相等时，请使用 <code>.equals()</code> 方法。   </li><li>当比较两个字符串对象是否相等时，请使用<code>==</code>操作符。</li></ul></blockquote><h4 id="TypeScript入门教程"><a href="#TypeScript入门教程" class="headerlink" title="TypeScript入门教程"></a><a href="https://ts.xcatliu.com/" target="_blank" rel="noopener">TypeScript入门教程</a></h4><blockquote><p>本书是作者在学习 <a href="http://www.typescriptlang.org/" target="_blank" rel="noopener">TypeScript</a> 后整理的学习笔记。</p></blockquote><h4 id="15种CSS居中的方式，你都用过哪几种"><a href="#15种CSS居中的方式，你都用过哪几种" class="headerlink" title="15种CSS居中的方式，你都用过哪几种"></a><a href="https://cloud.tencent.com/developer/article/1115615" target="_blank" rel="noopener">15种CSS居中的方式，你都用过哪几种</a></h4><blockquote><p>CSS居中是前端工程师经常要面对的问题，也是基本技能之一。今天有时间把CSS居中的方案汇编整理了一下，目前包括水平居中，垂直居中及水平垂直居中方案共15种。如有漏掉的，还会陆续的补充进来，算做是一个备忘录吧。<br>本文作者的博客：<a href="http://42du.cn/" target="_blank" rel="noopener">http://42du.cn/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这里记录过去一周，我的一些小总结。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="每周分享" scheme="http://liugezhou.online/categories/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="每周分享" scheme="http://liugezhou.online/tags/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>No1.宏观视角下的浏览器</title>
    <link href="http://liugezhou.online/2019/11/03/No1.%E5%AE%8F%E8%A7%82%E8%A7%86%E8%A7%92%E4%B8%8B%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    <id>http://liugezhou.online/2019/11/03/No1.宏观视角下的浏览器/</id>
    <published>2019-11-03T15:20:00.000Z</published>
    <updated>2019-11-13T06:01:20.570Z</updated>
    
    <content type="html"><![CDATA[<h6 id="前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。"><a href="#前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。" class="headerlink" title="前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。"></a>前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。</h6><h6 id="本篇是这个专栏的第一章：《宏观视角下的浏览器》。本章分为六讲。"><a href="#本篇是这个专栏的第一章：《宏观视角下的浏览器》。本章分为六讲。" class="headerlink" title="本篇是这个专栏的第一章：《宏观视角下的浏览器》。本章分为六讲。"></a>本篇是这个专栏的第一章：《宏观视角下的浏览器》。本章分为六讲。</h6><a id="more"></a><h4 id="01-Chrome架构：仅仅打开一个页面，为什么有四个进程"><a href="#01-Chrome架构：仅仅打开一个页面，为什么有四个进程" class="headerlink" title="01.Chrome架构：仅仅打开一个页面，为什么有四个进程"></a>01.Chrome架构：仅仅打开一个页面，为什么有四个进程</h4><hr><blockquote><p>在谷歌浏览器随便打开一个页面，点击“选项”菜单，选择“更多工具”，点击“任务管理器”，这将打开Chrome的任务管理器的窗口，你会发现一个页面上有四个以上的进程。为什么会有四个进程呢？<br>本章通过分析浏览器的进化史而展开探讨这个问题。<br>开始之前，我们必须得了解一下这个<code>进程</code>与<code>线程</code>的概念。  </p></blockquote><h5 id="线程-VS-进程"><a href="#线程-VS-进程" class="headerlink" title="线程 VS 进程"></a>线程 VS 进程</h5><blockquote><p><code>线程这个东西它是不能单独存在的，它是由进程来启动和管理的。</code> </p><p><code>一个进程就是一个程序的运行实例</code>。</p><p><code>线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率</code>。  </p><p>总结，线程与进程之间的关系有以下四个特点：</p><ol><li>进程中任一线程执行出错，都会导致整个进程崩溃。 </li><li>线程之间共享进程的数据。   </li><li>当一个进程关闭之后，操作系统会回收进程所占用的内存。   </li><li>进程之间的内容都互相隔离。(如果进程之间需要进行数据的通信，这时候需要使用用于进程间通讯(IPC)机制了)。</li></ol></blockquote><h5 id="单进程浏览器时代"><a href="#单进程浏览器时代" class="headerlink" title="单进程浏览器时代"></a>单进程浏览器时代</h5><blockquote><p>早在07年之前，市面上的浏览器都是单进程的。单进程，顾名思义是指：浏览器的所有功能模块都运行在同一个进程里。<br>如此多的功能模块运行在一个进程里，导致单进程浏览器<code>不稳定</code>、<code>不流畅</code>、<code>不安全</code>。<br>具体的表现就不说了，总之体验非常差，于是进入了“多线程浏览器”时代。    </p></blockquote><h5 id="多进程浏览器时代"><a href="#多进程浏览器时代" class="headerlink" title="多进程浏览器时代"></a>多进程浏览器时代</h5><blockquote><ul><li>多进程浏览器由于进程相互隔离，所以当一个页面或者插件崩溃的时候，影响的仅仅是当前的页面进程或者插件过程。这就完美解决了页面或者插件崩溃而导致的整个浏览器崩溃问题。JS的渲染若出现问题，影响的同样是当前的渲染页面，没有响应的仅对当前页面。而且在多进程浏览器时代，当关闭一个页面的时候，整个渲染进程会被关闭，该进程占用的内存都会被系统回收，这样也就轻松解决了浏览器页面的内存泄露问题。    </li><li>此外有关安全方面的问题：使用多线程架构可以使用<code>安全沙箱</code>。  </li></ul><p>可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在硬盘上写入任何数据，也不能在敏感位置读取任何数据(例如文档和桌面)，Chrome把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。</p></blockquote><h5 id="目前多进程架构"><a href="#目前多进程架构" class="headerlink" title="目前多进程架构"></a>目前多进程架构</h5><blockquote><p>最新的Chrome进程架构：Chrome浏览器包括：<code>1个浏览器(Brower)主进程，1个GPU进程、一个网络(NetWork)进程、多个渲染进程和多个插件进程</code>。<br>虽然多进程模型提升了浏览器的稳定性、流畅性、安全性，但是同样也会不可避免带来一些问题：  </p><ul><li><code>更高的资源占用</code> ：因为每个进程都会包含公共基础结构的副本（如JavaScript运行环境），这意味着浏览器会消耗更多的资源。  </li><li><code>更复杂的体系架构</code>：浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求。 </li></ul></blockquote><h5 id="未来面向服务的架构-SOP"><a href="#未来面向服务的架构-SOP" class="headerlink" title="未来面向服务的架构(SOP)"></a>未来面向服务的架构(SOP)</h5><blockquote><p>为了解决这些问题，2016年，Chrome团队使用“面向服务的架构“（SOP）思想设计了新的Chrome架构，这也是现阶段Chrome团队的一个主要任务。</p></blockquote><h4 id="02｜TCP协议：如何保证页面文件能被完整的送达浏览器"><a href="#02｜TCP协议：如何保证页面文件能被完整的送达浏览器" class="headerlink" title="02｜TCP协议：如何保证页面文件能被完整的送达浏览器"></a>02｜TCP协议：如何保证页面文件能被完整的送达浏览器</h4><hr><blockquote><p>在衡量Web页面性能的时候有一个重要的指标叫”FP(First Paint)”,是指从页面加载到首次开始绘制的时长。其中影响FP的一个重要因素就是<code>网络加载速度</code>。 </p><p>要优化网络加载速度，需要对网络有充分的了解，这一节重点介绍<code>在Web世界中的TCP/IP是如何工作的</code>。 </p><p>在网络中，一个文件通常会被拆分为很多数据包来进行传输，而数据包在传输过程中有很大概览丢失或者出错，那么如何保证页面文件能被完整地送达浏览器？</p></blockquote><h5 id="一个数据包的“旅程”"><a href="#一个数据包的“旅程”" class="headerlink" title="一个数据包的“旅程”"></a>一个数据包的“旅程”</h5><blockquote><ol><li><p>IP:把数据包送达目的主机<br>计算机的地址称为IP地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。<br>当从主机A向主机B发送数据(即发送数据包)，传输前，数据包会被附加上主机A和主机B的IP地址信息，这些信息会被封到一个叫做IP头的数据结构里，在这个IP头中包含IP数据包开头的信息(IP版本、源IP地址、目标地址、生存时间等信息)，于是数据包从主机A发送到主机B。  </p></li><li><p>UDP:把数据包送达应用程序<br>IP通过IP地址信息把数据包发送给指定的电脑，而UDP通过端口号把数据包发给正确的程序。<br>UDP发送数据，有各种因素会导致数据包出错，虽然UDP可以校验数据是否正确，但是<code>UDP不提供重发机制</code>，只是丢弃当前的包，且UDP在发送之后无法知道能否到达目的地。<br><code>UDP不能保证数据可靠性，但是传输速度却非常快</code>，因此UDP应用在一些关注速度但不那么严格要求数据完整性的领域，例如：在线视频、互动游戏等。  </p></li><li><p>TCP:把数据完整的送达应用程序<br>TCP(Transmission Control Protocol,传输控制协议)：他是一种面向连接的、可靠的、基于字节流的传输层通信协议。相对于UDP而言：  </p></li></ol><ul><li>对于数据包丢失情况，提供重传机制。  </li><li>TCP引入数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。 </li></ul></blockquote><h5 id="完整的TCP连接过程"><a href="#完整的TCP连接过程" class="headerlink" title="完整的TCP连接过程"></a>完整的TCP连接过程</h5><blockquote><p>我们现在已经知道TCP单个数据包的传输流程和UDP流程差不多，不同在于，通过TCP头信息可以保证一块大的数据传输的完整性。<br>一个完整的TCP连接过程，其生命周期包括了“建立连接“、”数据传输“、”断开连接“三个阶段。</p><ul><li>建立连接阶段：这个阶段通过“三次握手”来建立客户端和服务器之间的连接。  </li><li>数据传输阶段：在该阶段，接收端需要对每个数据包进行确认操作。接收端应该在接收数据后要发送确认数据包给发送端，若发送端没有接收到这个确认，则判断数据包丢失，并触发发送端的重发机制。  </li><li>断开连接阶段：数据传输完毕，终止连接，通过最后一个阶段“四次挥手”来保证双方都能断开连接。</li></ul></blockquote><h4 id="03｜HTTP请求流程：为什么很多站点第二次打开速度会很快？"><a href="#03｜HTTP请求流程：为什么很多站点第二次打开速度会很快？" class="headerlink" title="03｜HTTP请求流程：为什么很多站点第二次打开速度会很快？"></a>03｜HTTP请求流程：为什么很多站点第二次打开速度会很快？</h4><hr><blockquote><p>首先的首先我们知道：HTTP协议建立在TCP连接基础之上的。<code>HTTP是一种允许浏览器向服务器获取资源的协议，是Web的基础。HTTP是浏览器使用最广的协议</code>。</p><p>简单说说HTTP和TCP的关系：浏览器使用HTTP协议作为<code>应用层协议</code>，用来封装请求的文本信息，并使用TCP/IP作为<code>传输层协议</code>将它发到网路上,所以HTTP工作前，需要通过TCP与服务器建立连接，也就是说：<code>HTTP的内容是通过TCP的传输数据阶段来实现的</code>。</p></blockquote><h5 id="浏览器端发起HTTP请求流程"><a href="#浏览器端发起HTTP请求流程" class="headerlink" title="浏览器端发起HTTP请求流程"></a>浏览器端发起HTTP请求流程</h5><blockquote><p>如果在浏览器地址栏里输入：<a href="https://www.liugezhou.online" target="_blank" rel="noopener">https://www.liugezhou.online</a> 这个网址后,浏览器这个庞然大物，它的背后都做些什么呢？</p></blockquote><ul><li>构建请求<blockquote><p>首先浏览器构建请求行信息，构建好之后，浏览器准备发起网路请求。</p></blockquote></li><li>查找缓存<blockquote><p>在准备发起网路请求阶段，浏览器偷偷的在它的缓存中查询是否有要请求的资源。<br>若有：拦截请求，返回资源副本，直接结束请求。<br>若缓存查找失败：继续下一步。  </p></blockquote></li><li>准备IP地址和端口号<blockquote><p>这个IP地址和端口号的获取，肯定是通过域名与其映射，即“域名系统”，也就是我们熟知的DNS。<br>于是，浏览器第一步会请求DNS返回域名对应的IP，如果没有特别指明端口号，则默认为80。<br>(浏览器提供了DNS数据缓存服务，若缓存过也就不会去请求，直接解析。从而减少一次网络请求)</p></blockquote></li><li>等待TCP队列<blockquote><p>拿到IP地址与端口号后，还需要在TCP队列中排队才能建立TCP连接。<br>这是因为：Chrome有个机制，同一个域名同时最多只能建立6个TCP连接，若此刻同时有10个请求发生。则四个会进入TCP队列进行排队。<br>当然，若当前请求数量少于6个，则会直接进入下一步。 </p></blockquote></li><li>建立TCP连接 <blockquote><p>建立TCP连接，上一节我们已经知道，一个完整的TCP连接过程包括“建立连接”、“数据传输”、“断开连接“三个阶段。  </p></blockquote></li><li>发送HTTP请求<blockquote><p>HTTP请求是在TCP连接的数据传输阶段工作的，这个时候浏览器向服务器发送请求行，它包括请求方法、请求URI、HTTP版本协议。，HTTP中的数据在这个通信过程中传输。</p></blockquote></li></ul><h5 id="服务器端处理HTTP请求流程"><a href="#服务器端处理HTTP请求流程" class="headerlink" title="服务器端处理HTTP请求流程"></a>服务器端处理HTTP请求流程</h5><blockquote><p>这里可以在命令行中输入<code>curl -i https://www.google.com</code>来查看返回请求数据。 (-i 返回响应行、响应头和响应体信息。 -I 不返回响应体。)<br>返回网站的HTTP协议、Connection、Location、Cache-Control等信息。 </p><p>通常情况，一旦服务器向客户端返回了请求数据，它就要关闭TCP连接，但是如果浏览器或者服务器设置了<code>Connection:keep-alive</code>，那么TCP连接在发送后将仍保持打开状态。<code>保持TCP连接可以省去下次请求时需要建立连接的时间，提升资源加载速度</code>。</p></blockquote><h5 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h5><ol><li>为什么很多站点第二次打开速度会很快？<blockquote><p>主要原因肯定是第一次加载页面的过程中，缓存了一些数据(从上面的过程分析，我们知道<code>DNS缓存</code>和<code>页面资源缓存</code>这两块数据是会被浏览器缓存起来的).<br>网站把很多资源都缓存到了本地，浏览器缓存直接使用本地副本来回应请求，而不会产生真实的网络请求，从而节省了时间。</p></blockquote></li><li>登录状态是如何保持的 <blockquote><p>简单地说，如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保持到本地。当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。</p></blockquote></li></ol><h4 id="04｜导航流程：从输入URl到页面展示，这中间发生了什么"><a href="#04｜导航流程：从输入URl到页面展示，这中间发生了什么" class="headerlink" title="04｜导航流程：从输入URl到页面展示，这中间发生了什么"></a>04｜导航流程：从输入URl到页面展示，这中间发生了什么</h4><hr><blockquote><p>流程开始前，回顾下浏览器进程、网络进程、渲染进程的各自主要职责：  </p><ul><li>浏览器进程：主要负责<code>用户交互</code>、<code>子进程管理</code>和<code>文件储存</code>等功能。  </li><li>网络进程：面向渲染进程或浏览器进程提供<code>网络资源下载</code>。  </li><li>渲染进程：将HTML、CSS、JS、图片等资源解析为可以显示和交互的页面。 </li></ul></blockquote><h5 id="过程大致描述"><a href="#过程大致描述" class="headerlink" title="过程大致描述"></a>过程大致描述</h5><blockquote><ul><li>首先，用户从浏览器进程中输入请求信息。  </li><li>然后，网络进程发起URL请求。 </li><li>服务器响应URL请求后，浏览器进程开始准备渲染进程。 </li><li>渲染进程准备好以后，需要先向渲染进程提交页面数据，这称之为文档提交阶段。  </li><li>渲染进程接收到文档信息之后，便开始解析页面和加载子资源，完成页面的渲染。<br>这其中，用户发出URL请求到页面开始解析的过程，就叫做导航。</li></ul></blockquote><h5 id="从输入URL到页面展示–过程细节"><a href="#从输入URL到页面展示–过程细节" class="headerlink" title="从输入URL到页面展示–过程细节"></a>从输入URL到页面展示–过程细节</h5><blockquote><ul><li>响应数据类型处理：根据服务端返回的<code>Content-Type</code>字段来决定如何显示响应体的内容。</li><li>同一站点下的多个页面会运行在一个渲染进程中。</li></ul></blockquote><h5 id="“从输入-URL-到页面展示，这中间发生了什么？”-留言总结"><a href="#“从输入-URL-到页面展示，这中间发生了什么？”-留言总结" class="headerlink" title="“从输入 URL 到页面展示，这中间发生了什么？”(留言总结)"></a>“从输入 URL 到页面展示，这中间发生了什么？”(留言总结)</h5><blockquote><ol><li>用户输入url并回车·</li><li>浏览器进程检查url，组装协议，构成完整的url</li><li>浏览器进程通过进程间通信（IPC）把url请求发送给网络进程</li><li>网络进程接收到url请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程</li><li>如果没有，网络进程向web服务器发起http请求（网络请求），请求流程如下：<br>5.1 进行DNS解析，获取服务器ip地址，端口<br>5.2 利用ip地址和服务器建立tcp连接<br>5.3 构建请求头信息<br>5.4 发送请求头信息<br>5.5 服务器响应后，网络进程接收响应头和响应信息，并解析响应内容</li><li>网络进程解析响应流程；<br>6.1 检查状态码，如果是301/302，则需要重定向，从Location自动中读取地址，重新进行第4步<br>6.2 200响应处理： <pre><code>检查响应类型Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行后续的渲染，如果是html则通知浏览器进程准备渲染进程准备进行渲染。</code></pre></li><li>准备渲染进程<br>7.1 浏览器进程检查当前url是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程</li><li>传输数据、更新状态<br>8.1 渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”<br>8.2 渲染进程接收完数据后，向浏览器发送“确认提交”<br>8.3 浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏url、前进后退的历史状态、更新web页面。</li></ol></blockquote><h4 id="05｜渲染流程-上-：HTML、CSS和JavaScript，是如何变成页面的"><a href="#05｜渲染流程-上-：HTML、CSS和JavaScript，是如何变成页面的" class="headerlink" title="05｜渲染流程(上)：HTML、CSS和JavaScript，是如何变成页面的"></a>05｜渲染流程(上)：HTML、CSS和JavaScript，是如何变成页面的</h4><hr><blockquote><p>按照渲染的时间顺序，渲染流水线可分为以下几个构建阶段：<br><code>构建DOM树</code>、<code>样式计算</code>、<code>布局阶段</code>、<code>分层</code>、<code>绘制</code>、<code>光栅化</code>、<code>合成</code>。<br>本节主要讨论前三个阶段。  </p></blockquote><h5 id="构建DOM树"><a href="#构建DOM树" class="headerlink" title="构建DOM树"></a>构建DOM树</h5><blockquote><p>因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。<br>DOM树和HTML内容几乎一样，但和HTML不同的是：DOM是保存在内存中的树结构。  </p></blockquote><h5 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h5><blockquote><ol><li>把CSS转换为浏览器能够理解的结构。</li><li>转换样式表中的属性值，使其标准化。<br>「例如rem -&gt; px, red -&gt; rgb(255,0,0),bold -&gt; 700」  </li><li>计算出DOM树中每个节点的具体样式。<br>「CSS继承：每个DOM节点都包含有父节点的样式」<br>「CSS层叠：它在 CSS 处于核心地位，定义了如何合并来自多个源的属性值的算法」<br>「样式来源：如果一个元素不提供任何样式，默认使用的是UserAgent样式—浏览器提供的一组默认样式」。</li></ol></blockquote><h5 id="布局阶段"><a href="#布局阶段" class="headerlink" title="布局阶段"></a>布局阶段</h5><blockquote><p>内容： 布局阶段是根据DOM树和样式计算出元素的几何位置。 </p><ol><li>创建布局树「构建一颗只包含可见元素的布局树」  </li><li>布局计算 </li></ol></blockquote><blockquote><p>「在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 <code>LayoutNG</code>，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。」</p></blockquote><h4 id="06-渲染流程-下-：HTML、CSS和JavaScript，是如何变成页面的"><a href="#06-渲染流程-下-：HTML、CSS和JavaScript，是如何变成页面的" class="headerlink" title="06|渲染流程(下)：HTML、CSS和JavaScript，是如何变成页面的"></a>06|渲染流程(下)：HTML、CSS和JavaScript，是如何变成页面的</h4><hr><h5 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h5><blockquote><p>为了生成一些复杂效果(3D变换、页面滚动、z轴排序等)，渲染引擎还需要为特定的节点生成专用的图层，生成一颗对应的图层树.</p><ul><li>并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层.   </li><li>素有了层叠上下文的属性或者需要被剪裁，满足这任意一点，就会被提升成为单独一层。  </li></ul></blockquote><h5 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h5><blockquote><p>一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个<code>待绘制列表</code>。「可在浏览器开发者工具的Layers中查看。」</p></blockquote><h5 id="栅格化操作"><a href="#栅格化操作" class="headerlink" title="栅格化操作"></a>栅格化操作</h5><blockquote><p>所谓栅格化，是指将图块转换为位图。<br>栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中. </p></blockquote><h5 id="合成和显示"><a href="#合成和显示" class="headerlink" title="合成和显示"></a>合成和显示</h5><blockquote><p>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。经过浏览器就会显示出页面。  </p></blockquote><blockquote><p>一个完整的渲染流程大致可总结为如下：  </p><ul><li>渲染进程将 HTML 内容转换为能够读懂的 DOM 树结构。 </li><li>渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。  </li><li>创建布局树，并计算元素的布局信息。对布局树进行分层，并生成分层树。  </li><li>为每个图层生成绘制列表，并将其提交到合成线程。  </li><li>合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。  </li><li>合成线程发送绘制图块命令 DrawQuad 给浏览器进程。浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。</li></ul></blockquote><h5 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h5><h6 id="重排-更新了元素的几何属性"><a href="#重排-更新了元素的几何属性" class="headerlink" title="重排(更新了元素的几何属性)"></a>重排(更新了元素的几何属性)</h6><blockquote><p>使用CSS或者JS使元素的几何位置发生了改变，例如改变元素的宽度、高度等，这会使得浏览器触发重新布局、解析之后的一系列子阶段，这个过程就是重排。无疑，重排需要更新完整的渲染流水线，所以开销是最大的。 </p></blockquote><h6 id="重绘-更新元素的绘制属性"><a href="#重绘-更新元素的绘制属性" class="headerlink" title="重绘(更新元素的绘制属性)"></a>重绘(更新元素的绘制属性)</h6><blockquote><p>比如改变了元素的背景色，这会触发浏览器进行重绘之后的操作。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。  </p></blockquote><h6 id="直接合成阶段"><a href="#直接合成阶段" class="headerlink" title="直接合成阶段"></a>直接合成阶段</h6><blockquote><p>那如果你更改一个既不要布局也不要绘制的属性，会发生什么变化呢？渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成.<br>例如CSS的transform实现的动画效果，可以避开重排和重绘阶段，相对于重绘和重排，合成能大大提升绘制效率。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot;&gt;&lt;a href=&quot;#前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot; class=&quot;headerlink&quot; title=&quot;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot;&gt;&lt;/a&gt;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&lt;/h6&gt;&lt;h6 id=&quot;本篇是这个专栏的第一章：《宏观视角下的浏览器》。本章分为六讲。&quot;&gt;&lt;a href=&quot;#本篇是这个专栏的第一章：《宏观视角下的浏览器》。本章分为六讲。&quot; class=&quot;headerlink&quot; title=&quot;本篇是这个专栏的第一章：《宏观视角下的浏览器》。本章分为六讲。&quot;&gt;&lt;/a&gt;本篇是这个专栏的第一章：《宏观视角下的浏览器》。本章分为六讲。&lt;/h6&gt;
    
    </summary>
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>每周总结第十七期</title>
    <link href="http://liugezhou.online/2019/11/03/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93%E7%AC%AC%E5%8D%81%E4%B8%83%E6%9C%9F/"/>
    <id>http://liugezhou.online/2019/11/03/每周总结第十七期/</id>
    <published>2019-11-03T15:00:00.000Z</published>
    <updated>2019-11-03T15:03:31.694Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这里记录过去一周，我的一些小总结。</p></blockquote><a id="more"></a><h4 id="Feeling"><a href="#Feeling" class="headerlink" title="Feeling"></a>Feeling</h4><blockquote><p>想想自己从小到大一直在做的事，除了抽烟就是喝酒。<br>二十多年来，不止一次的想要去坚持做一件事，但是往往三天结束，高考那会也未曾幸免，可能以后也不会幸免。<br>但我还是比较觉得“常立志”，比“立长志”要来的热血一些。因为时不时的兴奋一把，会让我在这活不明白的世上多去感受一些东西。<br>之前是受阮一峰，阮老师的周五公号文章推送影响，后来是看到很多人在坚持做的一些事，让我也感觉作为一个个体而言，一定要尝试去坚持做一件事。做什么事可能不重要，做的对不对可能也不重要，做的好不好或许也不重要，重要的是不停寻找，找到了这么一件想坚持做下去的事。如果这件事还带给了极大的乐趣与自我满足，那么便是极好的。<br>就像找另一半一样，如果当作人生的目标去寻找，那肯定会找到的，然后接下来就是油盐酱醋茶，如何平淡而不失乐趣的经营下去。</p></blockquote><h4 id="小丑-Joker"><a href="#小丑-Joker" class="headerlink" title="小丑(Joker)"></a>小丑(Joker)</h4><blockquote><p>《小丑》这部电影与今年10月4日在美国上映，「本片的故事独立于DCEU（DC[正义联盟]系列）之外，故事背景设置在20世纪80年代，讲述了一位生活陷入困境的脱口秀喜剧演员渐渐走向精神的崩溃，在哥谭市开始了疯狂的犯罪生涯，最终成为了蝙蝠侠的宿敌“小丑”的故事。」   </p></blockquote><blockquote><p>「他是美国DC漫画旗下的超级反派，常年稳居美媒票选的TOP100漫画反派角色第一名的位置，IGN评选的史上最伟大漫画反派角色中，小丑排名第一。」 </p><p>看这部电影的来源是：<a href="https://movie.douban.com/review/10454598/" target="_blank" rel="noopener">《小丑》超万字终极解析，一个精神病患者从受害者到恶魔的自白</a> </p><p>看完这部电影最大的感受是：思想能够上上下下、完完全全改变一个人的所有。</p><p>当然这个角色被多数人熟知是在《蝙蝠侠～黑暗骑士》中，在这部电影中，这个小丑「向观众展现了没有逻辑的恶」，小丑饰演者「希斯·莱杰」，「2008年1月22日，被人发现死于纽约的公寓内，时年28岁。很多人猜测他是因为受到了小丑这一角色的不良影响而自杀」。 </p></blockquote><h4 id="人人网"><a href="#人人网" class="headerlink" title="人人网"></a>人人网</h4><blockquote><p>「人人网曾是中国领先的实名制社交网络平台。」<br>「2015年1月30日，人人网发消息称将下线站内信功能。」<br>「2018年11月14日，人人公司宣布以2000万美元代价把人人社交网络全部资产出售予北京多牛互动传媒股份有限公司 。」<br>「2019年10月，“人人”APP在苹果商店上架。」</p></blockquote><blockquote><p>目前人人网之前的账号仍可登录，明星大V们的信息记录都清空了，而作者本人未删除的消息都还在，然后我看了一下之前转发的一些文章，链接到的地址七七八八的被删的差不多。<br>由小看大，这很有可能说明在网络的世界里，人类的文明、言语、艺术、文化等一些人们真正关注的东西，可能不被历史铭记。各种网站、巨头公司当不存在商业运作的动力时，业务不再继续，信息记录会永远丢在某个硬盘里。人们的言论、关注也在一次次嘈杂之中被淹没。<br>然而我之前一直认为现在的历史不可能会发生“焚书坑儒”之事，然而，有可能发生的事就一定会发生的。</p></blockquote><h4 id="三种JS方法重定向到另一个网页的方法"><a href="#三种JS方法重定向到另一个网页的方法" class="headerlink" title="三种JS方法重定向到另一个网页的方法"></a>三种JS方法重定向到另一个网页的方法</h4><blockquote><ul><li>location.href </li><li>location.replace </li><li>location.assign<br>所有方法的输出都相同，但location.replace()方法从文档历史记录中删除当前文档的url。因此，如果希望选项导航回原始文档，最好使用location.assign()方法。</li></ul></blockquote><h4 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h4><h6 id="Vue源码"><a href="#Vue源码" class="headerlink" title="Vue源码"></a>Vue源码</h6><blockquote><p>「Vue.js 3.x 想全面替代 Vue.js 2.x 需要有相当长的路要走，未来相当长一段时间 Vue.js 2.x 仍然是主流，Vue.js 2.x 的源码学习并没有过时，如果你是一个 Vue.js 2.x 的使用者，就应该去学习 Vue.js 2.x 的源码。」</p></blockquote><h6 id="Vue组件通信有哪几种方式"><a href="#Vue组件通信有哪几种方式" class="headerlink" title="Vue组件通信有哪几种方式"></a>Vue组件通信有哪几种方式</h6><blockquote><ul><li>父子组件通信 : <code>props/$emit</code> </li><li>父子组件通信: <code>ref与$parent/$children</code> </li><li>父子、隔代、兄弟组件通信:<code>EventBus($emit/$on)</code> </li><li>隔代组件通信:<code>$attrs/$listeners</code>    </li><li>隔代组件通信:<code>provide/inject</code>    </li><li>Vuex适用于父子、隔代、兄弟组件通信。主要包括的模块为：State、getter、Mutation、Action、Module</li></ul></blockquote><h6 id="在Vue2-x中，是如何实现数据双向绑定的"><a href="#在Vue2-x中，是如何实现数据双向绑定的" class="headerlink" title="在Vue2.x中，是如何实现数据双向绑定的"></a>在Vue2.x中，是如何实现数据双向绑定的</h6><blockquote><p>一句话总结：Vue内部通过Object.defineProperty方法属性拦截的方式，把data对象里的每个数据的读写转换成getter/setter，当数据变化时视图发生更新。 </p><p>但是Object.defineProperty方法只能对属性进行数据劫持，不能对整个对象进行劫持，同理无法对数组进行劫持，但是，我们在使用Vue框架的时候都知道，Vue能检测到对象和数组（部分方法的操作）的变化，那么它是怎么实现的呢？   </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Observe a list of Array items.</span><br><span class="line"> */</span><br><span class="line">observeArray (items: Array&lt;any&gt;) &#123;</span><br><span class="line">  for (let i = 0, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">    observe(items[i])  // observe 功能为监测数据的变化</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 对属性进行递归遍历</span><br><span class="line"> */</span><br><span class="line">let childOb = !shallow &amp;&amp; observe(val) // observe 功能为监测数据的变化</span><br></pre></td></tr></table></figure><blockquote><p>通过以上 Vue 源码部分查看，我们就能知道 Vue 框架是通过遍历数组 和递归遍历对象，从而达到利用 Object.defineProperty() 也能对对象和数组（部分方法的操作）进行监听。</p></blockquote><h6 id="Proxy与Object-definePropertyObject-defineProperty优劣对比"><a href="#Proxy与Object-definePropertyObject-defineProperty优劣对比" class="headerlink" title="Proxy与Object.definePropertyObject.defineProperty优劣对比"></a>Proxy与Object.definePropertyObject.defineProperty优劣对比</h6><blockquote><p>Proxy优势：</p><ul><li>Proxy可以直接监听对象而非属性</li><li>Proxy可以直接监听数组的变化 </li><li>Proxy有多达13中拦截方法，不限于apply、ownKeys、deleteProperty、has等等是Object.defineProperty不具备的。 </li><li>Proxy返回的是一个新对象，我们可以只操作新的对象达到目的，而Object.defineProperty只能遍历对象属性直接修改。 </li><li>Proxy作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利。<br>而Object.defineProperty兼容性好，支持IE9，Proxy存在浏览器兼容性问题，无法用polyfill磨平。</li></ul></blockquote><h5 id="30-道-Vue-面试题，内含详细讲解"><a href="#30-道-Vue-面试题，内含详细讲解" class="headerlink" title="30 道 Vue 面试题，内含详细讲解"></a><a href="https://juejin.im/post/5d59f2a451882549be53b170#heading-18" target="_blank" rel="noopener">30 道 Vue 面试题，内含详细讲解</a></h5>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这里记录过去一周，我的一些小总结。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="每周分享" scheme="http://liugezhou.online/categories/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="每周分享" scheme="http://liugezhou.online/tags/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>每周分享第十六期</title>
    <link href="http://liugezhou.online/2019/10/27/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC%E5%8D%81%E5%85%AD%E6%9C%9F/"/>
    <id>http://liugezhou.online/2019/10/27/每周分享第十六期/</id>
    <published>2019-10-27T13:06:00.000Z</published>
    <updated>2019-10-27T13:05:54.147Z</updated>
    
    <content type="html"><![CDATA[<h2 id="每周分享第十六期"><a href="#每周分享第十六期" class="headerlink" title="每周分享第十六期"></a>每周分享第十六期</h2><blockquote><p>这里记录我的周末，我的关注以及值得记录的东西。</p></blockquote><a id="more"></a><h4 id="刊首语"><a href="#刊首语" class="headerlink" title="刊首语"></a>刊首语</h4><blockquote><p>我们在这个世界上辛苦劳作，来回奔波是为了什么？<br>所有这些贪婪和欲望，所有这些对财富、权利和名声的追求，其目的到底何在？<br>归根结底，是为了得到他人的爱和认同。<br><cite>亚当·斯密《道德情操论》</cite></p></blockquote><h4 id="拼多多百亿补贴"><a href="#拼多多百亿补贴" class="headerlink" title="拼多多百亿补贴"></a>拼多多百亿补贴</h4><blockquote><p>双十一就来了，我是一个不怎么在购物网站混战的小年轻，特别是近几年看到的各种打折券、更是眼花缭乱，因此买东西一般只买那种不搞价、官方统一价的物品。<br>然后这几天看到了PDD的百亿补贴活动，MacBookPro双十一补贴到手价不到一万七，比我买的时候整整便宜了三千块，血亏啊。<br>貌似是在本周五纳斯达克收盘价时，拼多多股价上涨12.5%，其市值超越京东，成为中国第四大互联网公司，一个成长仅四年的公司发展这么迅速，真是挺牛皮的。<br>因此双十一要买东西的话，可以在拼多多上看一下，货比三家瞅一瞅。</p></blockquote><h4 id="Github可视化大数据平台"><a href="#Github可视化大数据平台" class="headerlink" title="Github可视化大数据平台"></a>Github可视化大数据平台</h4><blockquote><p>现在做政府项目的大数据可视化平台挺火，很多政府机构都喜欢打造各个行业的大数据可视化平台。<br>Github上有个开源项目，基于Vue构建一个Github的可视化大数据平台，这个开源项目是：<a href="https://github.com/HongqingCao/GitDataV" target="_blank" rel="noopener">GitDataV</a>.<br>Github主页的生成效果图：<br><img src="http://img.liugezhou.online/GitDataV.png" alt="GitDataV"></p></blockquote><h4 id="nodebestpractices"><a href="#nodebestpractices" class="headerlink" title="nodebestpractices"></a><a href="https://github.com/goldbergyoni/nodebestpractices" target="_blank" rel="noopener">nodebestpractices</a></h4><blockquote><p>一本在线书籍–Node.js最佳实践。是对Node.js最佳实践中排名最高的内容的总结和分享。 Star：35.1k.</p></blockquote><h4 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a><a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">leetcode</a></h4><blockquote><p>leetcode题解，记录自己的leetcode解题之路。</p></blockquote><h4 id="这个网站的确很酷"><a href="#这个网站的确很酷" class="headerlink" title="这个网站的确很酷"></a><a href="https://bruno-simon.com/" target="_blank" rel="noopener">这个网站的确很酷</a></h4><blockquote><p>阮老师Twitter文：<br>“这是很久以来，我见过的最酷主页，整个页面需要3D导航。<a href="https://bruno-simon.com" target="_blank" rel="noopener">https://bruno-simon.com</a><br>页面源码是开源的。<a href="https://github.com/brunosimon/folio-2019”" target="_blank" rel="noopener">https://github.com/brunosimon/folio-2019”</a></p></blockquote><blockquote><p>Made with #thressJS and # canonJS</p></blockquote><h4 id="Vue-js3-x源码解析先导"><a href="#Vue-js3-x源码解析先导" class="headerlink" title="Vue.js3.x源码解析先导"></a><a href="https://mp.weixin.qq.com/s/q8PVgF7_sL0XhcBfP1WDPA" target="_blank" rel="noopener">Vue.js3.x源码解析先导</a></h4><blockquote><p>黄老师的一篇对于3.0源码的介绍。</p></blockquote><h4 id="是学不动还是不想学"><a href="#是学不动还是不想学" class="headerlink" title="是学不动还是不想学"></a>是学不动还是不想学</h4><blockquote><p>各种技术文章、各种公众号推送、各种人工智能培训班广告、各种知识付费APP，充斥眼球与大脑.<br>我们都知道技术是学不完的，但还是有看到什么新的课程慌的一批的感觉，什么TS、Vue3源码、WebGL、NodeJS等等等等，我知道应该去动身学习，但是总是会出现学不下去的情况，造成这种情况的原因是现在各种分散注意力的消息过于庞杂，一会东、一会西，太容易找不到方向。<br>这种情况下，得收心，管他弱水三千，只取一瓢。<br>并不是学不动，是不想学罢了。  </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;每周分享第十六期&quot;&gt;&lt;a href=&quot;#每周分享第十六期&quot; class=&quot;headerlink&quot; title=&quot;每周分享第十六期&quot;&gt;&lt;/a&gt;每周分享第十六期&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;这里记录我的周末，我的关注以及值得记录的东西。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="每周分享" scheme="http://liugezhou.online/categories/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="每周分享" scheme="http://liugezhou.online/tags/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>每周分享第十五期</title>
    <link href="http://liugezhou.online/2019/10/20/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB%E7%AC%AC%E5%8D%81%E4%BA%94%E6%9C%9F/"/>
    <id>http://liugezhou.online/2019/10/20/每周分享第十五期/</id>
    <published>2019-10-20T10:20:00.000Z</published>
    <updated>2019-10-20T10:21:30.758Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这里记录我的周末，我的关注以及值得记录的东西。</p></blockquote><a id="more"></a><h5 id="刊首语"><a href="#刊首语" class="headerlink" title="刊首语"></a>刊首语</h5><blockquote><p>不同肤色、不同文化、不同国籍的生活在这个星球上的人，大都觉得是按自己的生活方式在度此生。<br>我也会这么认为，但事实可能大相径庭。<br>很多时候，我会觉得自己是悲哀的：没有文化、没有信仰、没有追求、没有修养、不了解历史、不敢关心政治。<br>总结为一句话就是：没有过意识形态的形成。 </p><p>不知是对世界百花齐放思想散播的招架不住，还是由于人类本质劣性的残留，亦或者是社会发展带来的人心躁动，我竟记不起上次在何时感动，我竟再未关注社会生活那些人性与善良，进入眼帘的的只有动乱与不幸。<br>我不再抱有一颗怜悯之心、有些厌倦社会生活的伪装，我想是因为还不能聚焦自己，未能再作出一件有成就的事、也再未能给人带来些快乐与微笑。<br>这是我个人的悲哀，可能也是社会的一个缩影·。<br><cite>看动漫《赌博默示录》、《赌博破戒录》而感</cite></p></blockquote><h4 id="马拉松"><a href="#马拉松" class="headerlink" title="马拉松"></a>马拉松</h4><blockquote><p><code>肯尼亚</code>的世界纪录保持者<code>埃留德·基普乔格</code>（Eliud Kipchoge）10月12日在维也纳以<code>1:59:40</code>的成绩，成为第一个马拉松进入两小时以内的人！  </p><p>这相当于，100米的平均速度为17秒，然后不间断跑422个这样的100米。</p><p>不过，由于这是一次专门为他破记录举办的挑战赛，为了创造记录，有41个人配合他跑，为他挡风和配速，所以国际田联不会承认这个纪录.</p></blockquote><h4 id="英雄联盟"><a href="#英雄联盟" class="headerlink" title="英雄联盟"></a>英雄联盟</h4><blockquote><p>英雄联盟手游预约开启，新一轮的手游狂潮要到来了，吗？  </p></blockquote><h4 id="世界互联网大会"><a href="#世界互联网大会" class="headerlink" title="世界互联网大会"></a>世界互联网大会</h4><blockquote><p>第六届世界互联网大会，将于10月20日-22日在浙江乌镇召开。本次大会以“智能互联 开放合作——携手共建网络空间命运共同体”为主题。</p></blockquote><h4 id="VSCode–mock数据"><a href="#VSCode–mock数据" class="headerlink" title="VSCode–mock数据"></a>VSCode–mock数据</h4><blockquote><p>掘金沸点上看到一个VSCode插件：<code>Mock_Myself</code>，为日常开发提供mock数据，在后端接口还未完善下，可以先自己模拟一些数据进行页面展示数据的代码开发。</p></blockquote><h4 id="javascript-questions"><a href="#javascript-questions" class="headerlink" title="javascript-questions"></a><a href="https://github.com/lydiahallie/javascript-questions/blob/master/zh-CN/README-zh_CN.md" target="_blank" rel="noopener">javascript-questions</a></h4><blockquote><p>JavaScript 进阶问题列表。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;我在我的 Instagram 上每天都会发布 JavaScript 的多选问题，并且同时也会在这个仓库中发布。  </span><br><span class="line">从基础到进阶，测试你有多了解 JavaScript，刷新你的知识，或者帮助你的 coding 面试！ 💪 🚀 我每周都会在这个仓库下更新新的问题。  </span><br><span class="line">答案在问题下方的折叠部分，点击即可展开问题。祝你好运 ❤️&quot;</span><br></pre></td></tr></table></figure></blockquote><h4 id="奶牛快传"><a href="#奶牛快传" class="headerlink" title="奶牛快传"></a><a href="https://cowtransfer.com/" target="_blank" rel="noopener">奶牛快传</a></h4><blockquote><p>平时我们用微信发送文件大小会限制在20M，不怎么方便，这是一个在线快传文件网站，上传文件速度特别快，不用注册就可以在线传输本地的文件，传输完毕后只需要将下载链接发送给对方在线下载即可，不需要使用U盘等拷贝文件，非常方便。<br>可能会有风险，管理员会看得到，如若担心推荐此网站的楼主建议压缩文件的时候设置密码上传。  </p></blockquote><h4 id="IPhone使用小技巧"><a href="#IPhone使用小技巧" class="headerlink" title="IPhone使用小技巧"></a>IPhone使用小技巧</h4><blockquote><p>IPhone在文本框输入文字或者网站的时候，会出现这样一个问题：直接用手指点击刚输入内容到某处时，极不方便。<br>这个时候，你可以长按默认输入法的空格键，然后指针便可以拖动了。  </p></blockquote><h4 id="当然我在扯淡"><a href="#当然我在扯淡" class="headerlink" title="当然我在扯淡"></a><a href="http://yinwang.org" target="_blank" rel="noopener">当然我在扯淡</a></h4><blockquote><p>个人博客：<a href="http://yinwang.org" target="_blank" rel="noopener">当然我在扯淡</a>。<br>王垠[yín]，四川大学97级本科毕业，保送到清华大学计算机系直博。期间曾在清华大学计算机系软件工程专业就读，主要进行集成电路布线算法的研究。在此期间，他因《完全用GNU/Linux工作》一文和对TeX的推广等“非研究成果的业余东西”而出名。 在只剩一年就要博士毕业的时候，他申请退学，并将1万7千余字的“退学申请书”（题为清华梦的粉碎）公布在网上，引起舆论界一时对教育体制、理想主义等的热议。</p></blockquote><h4 id="idea激活码"><a href="#idea激活码" class="headerlink" title="idea激活码"></a>idea激活码</h4><blockquote><p>一大批idea激活码失效，window系统下激活码地址：<a href="https://www.lanzous.com/i5clxlc" target="_blank" rel="noopener">https://www.lanzous.com/i5clxlc</a>  </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这里记录我的周末，我的关注以及值得记录的东西。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="每周分享" scheme="http://liugezhou.online/categories/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="每周分享" scheme="http://liugezhou.online/tags/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
</feed>
