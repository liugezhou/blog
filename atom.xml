<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>六个周</title>
  
  <subtitle>liugezhou</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liugezhou.online/"/>
  <updated>2020-02-09T11:55:23.203Z</updated>
  <id>http://liugezhou.online/</id>
  
  <author>
    <name>liugezhou</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>每周总结第二十九期</title>
    <link href="http://liugezhou.online/2020/02/08/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B9%9D%E6%9C%9F/"/>
    <id>http://liugezhou.online/2020/02/08/每周总结第二十九期/</id>
    <published>2020-02-08T15:34:00.000Z</published>
    <updated>2020-02-09T11:55:23.203Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本周是2020年的第六个周末。<br>这里记录过去一周，我的一些总结。<br><img src="http://img.liugezhou.online/weekly29.png" alt="weekly-29"></p></blockquote><a id="more"></a><h3 id="Feeling"><a href="#Feeling" class="headerlink" title="Feeling"></a>Feeling</h3><blockquote><p>整个新年笼罩在新冠肺炎的乌云下，且尚未出现停止的迹象。<br>期间的突发公共事件让在家安然度过的我们即感动又可恨，即悲伤又愤慨。</p><p>千千万万医务者、奋而往前的共产党官员、奔波在路上的外卖大哥等等等等。<br>这些依然奉献在一线岗位的工作者们令人可敬可佩。</p><p>愿这个病毒尽早被扼杀，愿中华大地早日回归平静，中华民族伟大复兴的口号不仅只是喊响亮，还要一往无前的走下去。    </p></blockquote><h3 id="疫情进展的时间线"><a href="#疫情进展的时间线" class="headerlink" title="疫情进展的时间线"></a><a href="https://github.com/Pratitya/wuhan2020-timeline" target="_blank" rel="noopener">疫情进展的时间线</a></h3><blockquote><p>该项目记录了自2019年12月1日开始，每一天发生的疫情大事记。</p></blockquote><h3 id="新冠肺炎记忆"><a href="#新冠肺炎记忆" class="headerlink" title="新冠肺炎记忆"></a><a href="https://github.com/2019ncovmemory/nCovMemory" target="_blank" rel="noopener">新冠肺炎记忆</a></h3><blockquote><p>报道、非虚构与个人叙述（持续更新）.<br>此处收集内地各类传媒和公众号发布（原创或转载）的有关新型冠状病毒感染的肺炎(2019-nCoV)的深度报道、非虚构作品及亲历者个人叙述.</p></blockquote><h3 id="新冠肺炎传播途径含气溶胶传播"><a href="#新冠肺炎传播途径含气溶胶传播" class="headerlink" title="新冠肺炎传播途径含气溶胶传播"></a>新冠肺炎传播途径含气溶胶传播</h3><blockquote><p>目前可以确定的新冠肺炎传播途径主要为直接传播、气溶胶传播和接触传播。<br>气溶胶传播是指飞沫混合在空气中，形成气溶胶，吸入后导致感染。<br>气溶胶传播是目前人类已知的最顶级的传播方式，尤其在封闭空间，堪称大杀器。  </p><p>随后<a href="https://mp.weixin.qq.com/s/0M0rXT2lYYIAJAKXSqE3Yg" target="_blank" rel="noopener">该文</a>被企鹅辟谣。</p></blockquote><h3 id="实时更新：你的定制防疫地图"><a href="#实时更新：你的定制防疫地图" class="headerlink" title="实时更新：你的定制防疫地图"></a><a href="https://z.cbndata.com/2019-nCoV/index.html?from=groupmessage&isappinstalled=0" target="_blank" rel="noopener">实时更新：你的定制防疫地图</a></h3><blockquote><p>输入地址查看周边疫情。</p></blockquote><h3 id="天通系统"><a href="#天通系统" class="headerlink" title="天通系统"></a><a href="https://toutiao.china.com/t_5Y2r5pif55S16K-dfOWkqemAmuezu-e7nw.html" target="_blank" rel="noopener">天通系统</a></h3><blockquote><p>2020年1月10日，由我国自主建设的第一个卫星移动通信系统——天通系统，正式面向全社会提供服务。<br>目前，天通卫星移动通信系统已经实现对我国领土、领海的全面覆盖，可广泛应用于海洋渔业、应急救援等多个场景。在服务区内，用户可以使用话音、短信、数据通信及位置服务。<br>该系统由中国电信独家运营，号段为1740.</p></blockquote><h3 id="从零开始学K线：新手入门、洞悉K线、股市获利之道-唐韩"><a href="#从零开始学K线：新手入门、洞悉K线、股市获利之道-唐韩" class="headerlink" title="从零开始学K线：新手入门、洞悉K线、股市获利之道(唐韩)"></a>从零开始学K线：新手入门、洞悉K线、股市获利之道(唐韩)</h3><blockquote><p>微信读书上一本关于K线入门的书籍。</p><p>以下是书中关于多方占优型给出的一些名词或口诀：<br>“阴后收阳，次日逞强”这一口诀是对好友反攻、曙光初现、旭日东升、阳吞阴这4种图形的归纳总结。<br>多方炮，架的高，股价只是半山腰。<br>红三兵、三个白武士、连续跳空三阳线。  </p></blockquote><h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3><blockquote><p> 如果尖锐的批评完全消失，温和的批评将会变得刺耳。如果温和的批评也不被允许，沉默将被认为居心叵测。如果沉默也不再允许，赞扬不够卖力将是一种罪行。如果只允许一种声音存在，那么，唯一存在的那个声音就是谎言。<br><cite>——柏拉图</cite> </p><p>真的猛士，敢于直面惨淡的人生，敢于正视淋漓的鲜血。这是怎样的哀痛者和幸福者？然而造化又常常为庸人设计，以时间的流逝，来洗涤旧迹，仅使留下淡红的血色和微漠的悲哀。在这淡红的血色和微漠的悲哀中，又给人暂得偷生，维持着这似人非人的世界。我不知道这样的世界何时是一个尽头！<br><cite>——纪念刘和珍君</cite> </p></blockquote><h3 id="undraw"><a href="#undraw" class="headerlink" title="undraw"></a><a href="https://undraw.co/illustrations" target="_blank" rel="noopener">undraw</a></h3><blockquote><p>一个免费的插图网站，可以在上面寻找合适的插图，用于商业用途</p></blockquote><h3 id="微信公号一家独大"><a href="#微信公号一家独大" class="headerlink" title="微信公号一家独大"></a>微信公号一家独大</h3><blockquote><p>实在想不明白到底是什么原因，上述文章在公众平台就发不出去，里面的内容究竟是什么不可言说的？没有反动，没有传播谣言，没有负能量，没有说那些不能说的，究竟是什么审查机制，让我纯纯的记录一下周总结都这么困难。</p></blockquote><blockquote><p>自六个周公号被封后，我深知不能谈论政治，不能写不让人关注的东西，基本上不写自己的想法。我着眼于小小的记录，也是为了每周给自己一个交代，可以每天去关注一些东西。</p></blockquote><blockquote><p>即使经常看到各种删文，也还在将心中的愤恨慢慢淡化，可是这种互联网环境真的是一次次的让人失望。</p></blockquote><blockquote><p>左耳朵耗子在他的一篇关于科学上网的博文中写的一段话，真是越来越深有感触：</p></blockquote><blockquote><p>是的，我的互联网不是——全是骗子的百度、充满广告的微信朋友圈、质量低下的公众号、娱乐至死的新浪微博、只有抖机灵和“怎么看XX”的知乎、毫无营养的今日头条…… 在这样的网络空间里，我真的无法生存…… 这根本不是互联网，不是为我服务的互联网，而是在消费我的互联网，是让我变傻变笨的互联网…… 我不能忍，因为它影响到了我的生存……</p></blockquote><blockquote><p> 删文与我而言并没有什么,仅仅是一篇记录发送不出去而已。</p></blockquote><blockquote><p>但对那些靠写作为生的人们，删文不仅仅是声誉的受损，也是对他们价值观、生活观的显性否定，一个人究竟有多恶毒或者给社会带来多么恶劣的影响，才会被封杀、删文。</p></blockquote><blockquote><p>进入21世纪，除了每天的经济高速发展，是否能给人们一点精神生活的安慰？再不见文学大家，再没有思想家。</p></blockquote><blockquote><p>李文亮医师的事情才刚刚发生，背后的映射是什么？网警们、网络审查官们、互联网封锁者，你们都不反思的吗？</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本周是2020年的第六个周末。&lt;br&gt;这里记录过去一周，我的一些总结。&lt;br&gt;&lt;img src=&quot;http://img.liugezhou.online/weekly29.png&quot; alt=&quot;weekly-29&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="每周分享" scheme="http://liugezhou.online/categories/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="每周分享" scheme="http://liugezhou.online/tags/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>每周总结第二十八期</title>
    <link href="http://liugezhou.online/2020/01/16/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AB%E6%9C%9F/"/>
    <id>http://liugezhou.online/2020/01/16/每周总结第二十八期/</id>
    <published>2020-01-16T05:15:00.000Z</published>
    <updated>2020-01-19T14:45:30.991Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这里记录过去一周，我的一些总结。<br><img src="http://img.liugezhou.online/weekly28.jpeg" alt="weekly-28"></p></blockquote><a id="more"></a><h3 id="Feeling"><a href="#Feeling" class="headerlink" title="Feeling"></a>Feeling</h3><blockquote><p>在追随心中mentor的脚步前，要先找到他。    </p></blockquote><h3 id="龙头白马股"><a href="#龙头白马股" class="headerlink" title="龙头白马股"></a>龙头白马股</h3><blockquote><p>一位财经大V准备了一份名单，筛选了12个龙头白马股，是白的不能再白的那种，业内公认的超级行业龙头，每一个股票，你一听名字，就知道它肯定是白马股，因为如雷贯耳。<br>按这位大V的介绍，这12个龙头白马股，稳定的如老狗，很适合定投，常年锁定不动。下面为这12支股票代码以及截止本周的数据：   </p><table><thead><tr><th align="left">股票名称、代码</th><th align="left">现价</th></tr></thead><tbody><tr><td align="left">贵州茅台(600519)</td><td align="left">1107.50</td></tr><tr><td align="left">五粮液(000858)</td><td align="left">138.55</td></tr><tr><td align="left">工商银行(601398)</td><td align="left">5.82</td></tr><tr><td align="left">中国平安(601318)</td><td align="left">86.25</td></tr><tr><td align="left">格力电器(000651)</td><td align="left">167.91</td></tr><tr><td align="left">美的集团(000333)</td><td align="left">60.31</td></tr><tr><td align="left">云南白药(000538)</td><td align="left">87.16</td></tr><tr><td align="left">片仔癀(6005436)</td><td align="left">123.38</td></tr><tr><td align="left">伊利股份(600887)</td><td align="left">32.88</td></tr><tr><td align="left">海螺水泥(600585)</td><td align="left">52.13</td></tr><tr><td align="left">海康威视(002415)</td><td align="left">35.67</td></tr><tr><td align="left">恒瑞医药(600276)</td><td align="left">90.66</td></tr></tbody></table></blockquote><h3 id="Think-Different"><a href="#Think-Different" class="headerlink" title="Think Different"></a>Think Different</h3><blockquote><p>Think Different（非同凡想）是广告公司TBWA\Chiat\Day纽约分支办公室于1997年后期为苹果公司创作的广告口号，曾用于知名的电视广告、数个广告印刷品以及数个苹果公司产品的电视广告与广告印刷品中。苹果公司在2002年的Switch广告活动开始后停止使用这个口号。 </p><iframe height="498" width="510" src="https://v.qq.com/x/page/g0183nh7j59.html" frameborder="0" allowfullscreen></iframe></blockquote><h3 id="我对中国科技行业的看法-译文"><a href="#我对中国科技行业的看法-译文" class="headerlink" title="我对中国科技行业的看法(译文)"></a><a href="http://www.ruanyifeng.com/blog/2020/01/china-technology-review.html" target="_blank" rel="noopener">我对中国科技行业的看法(译文)</a></h3><blockquote><p><a href="https://twitter.com/danwwang" target="_blank" rel="noopener">@danwwang</a> 是彭博社的一个技术分析师，写了一篇2019年回顾，详细谈了他对中国科技行业、中美贸易战的看法。<br>这篇文章总体比较客观，中国的劣势和优势都谈到了。这篇文章是阮一峰老师翻译的主要部分。</p></blockquote><h3 id="网站挂了吗"><a href="#网站挂了吗" class="headerlink" title="网站挂了吗"></a><a href="https://gualemang.com/" target="_blank" rel="noopener">网站挂了吗</a></h3><blockquote><p>该网站检测网站是否运正常。<br><img src="http://img.liugezhou.online/weekly28gualema.png" alt="gualema"></p></blockquote><h3 id="Shadowsocks"><a href="#Shadowsocks" class="headerlink" title="Shadowsocks"></a><a href="https://vc2tea.com/whats-shadowsocks/" target="_blank" rel="noopener">Shadowsocks</a></h3><blockquote><p>写给非专业人士看的 Shadowsocks 简介.</p></blockquote><h3 id="你真的会高效的在GitHub搜索开源项目吗"><a href="#你真的会高效的在GitHub搜索开源项目吗" class="headerlink" title="你真的会高效的在GitHub搜索开源项目吗?"></a><a href="https://mp.weixin.qq.com/s/YM4Zy-GJFsS_fgLogZdRfg" target="_blank" rel="noopener">你真的会高效的在GitHub搜索开源项目吗?</a></h3><blockquote><p>做为一个为万千工程师提供服务的网站,这篇文章介绍了如何高效在Github上搜索项目。 </p><ul><li>in:name liugezhou —- 查找仓库名称包含 liugezhou 的仓库. </li><li>in:descripton node —- 搜索项目描述包含node的内容。    </li><li>in:readme 关键词    </li><li>stars(fork):&gt;10000 Vue —- 搜索 star 数大于 10000 的 Vue仓库.    </li><li>size:&gt;=5000 node  </li><li>pushed:&gt;2020-01-15 Vue —- 指定更新时间在哪个时间前或后在提交的项目。<br>等等。</li></ul></blockquote><h3 id="Github粉丝排行榜"><a href="#Github粉丝排行榜" class="headerlink" title="Github粉丝排行榜"></a><a href="https://wangchujiang.com/github-rank/index.html" target="_blank" rel="noopener">Github粉丝排行榜</a></h3><blockquote><p>Github粉丝排行榜，目前来说，从全球来看，超过三千粉丝可以排名500位以内。</p></blockquote><h3 id="VS-Code-自带神器插件–替代Postman"><a href="#VS-Code-自带神器插件–替代Postman" class="headerlink" title="VS Code 自带神器插件–替代Postman"></a><a href="https://juejin.im/post/5e2067f7f265da3e405028fb?from=timeline&isappinstalled=0&scene=2&clicktime=1579229784&enterid=1579229784" target="_blank" rel="noopener">VS Code 自带神器插件–替代Postman</a></h3><blockquote><p>接口调试是每一个软件开发从业者必不可少的一项技能，一个项目的完成必然经过大量的接口测试，实际开发过程中，接口调试的时间不比实际开发所用的时间少。<br>作为前端开发人员，我们通常使用 Postman（或 PostWoman 等 ） 工具来进行REST API调用。<br><code>REST Client</code> 是一个 VS Code 扩展插件，它允许你发送 HTTP 请求并直接在 VS Code 上查看响应结果。    </p><p>这篇文章对比了Postman与该插件的优劣，并总结了一些使用方法。   </p></blockquote><h3 id="Node-js-colors包"><a href="#Node-js-colors包" class="headerlink" title="Node.js colors包"></a>Node.js colors包</h3><blockquote><p>语法高亮可帮助我们管理代码的复杂性。<br>colors包(npm install colors)为控制台输出带来了类似的好处，使得我们更容了解发生了什么。<br>它也是最常用的NPM包之一。<br>它向本地JavaScript字符串添加函数，以便可以执行诸如“some string”.red之类的操作。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这里记录过去一周，我的一些总结。&lt;br&gt;&lt;img src=&quot;http://img.liugezhou.online/weekly28.jpeg&quot; alt=&quot;weekly-28&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="每周分享" scheme="http://liugezhou.online/categories/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="每周分享" scheme="http://liugezhou.online/tags/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>browserslist</title>
    <link href="http://liugezhou.online/2020/01/13/browserslist/"/>
    <id>http://liugezhou.online/2020/01/13/browserslist/</id>
    <published>2020-01-13T07:29:00.000Z</published>
    <updated>2020-01-13T09:31:03.123Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本博文是翻译：<a href="https://github.com/browserslist/browserslist的内容。" target="_blank" rel="noopener">https://github.com/browserslist/browserslist的内容。</a></p><a id="more"></a></blockquote><h5 id="Vue-cli官方文档开发模块的浏览器兼容这一块，提到了browserslist，原文如下："><a href="#Vue-cli官方文档开发模块的浏览器兼容这一块，提到了browserslist，原文如下：" class="headerlink" title="Vue-cli官方文档开发模块的浏览器兼容这一块，提到了browserslist，原文如下："></a>Vue-cli官方文档开发模块的浏览器兼容这一块，提到了browserslist，原文如下：</h5><blockquote><p>你会发现有 <code>package.json</code> 文件里的 <code>browserslist</code> 字段 (或一个单独的 <code>.browserslistrc</code> 文件)，指定了项目的目标浏览器的范围。这个值会被 <a href="https://new.babeljs.io/docs/en/next/babel-preset-env.html" target="_blank" rel="noopener">@babel/preset-env</a> 和 <a href="https://github.com/postcss/autoprefixer" target="_blank" rel="noopener">Autoprefixer</a> 用来确定需要转译的 JavaScript 特性和需要添加的 CSS 浏览器前缀。</p><p>现在查阅<a href="https://github.com/ai/browserslist" target="_blank" rel="noopener">这里</a>了解如何指定浏览器范围。</p></blockquote><h6 id="下面是来自：https-github-com-ai-browserslist的官方文档翻译的内容："><a href="#下面是来自：https-github-com-ai-browserslist的官方文档翻译的内容：" class="headerlink" title="下面是来自：https://github.com/ai/browserslist的官方文档翻译的内容："></a>下面是来自：<a href="https://github.com/ai/browserslist的官方文档翻译的内容：" target="_blank" rel="noopener">https://github.com/ai/browserslist的官方文档翻译的内容：</a></h6><hr><h2 id="Browserslist"><a href="#Browserslist" class="headerlink" title="Browserslist"></a>Browserslist</h2><blockquote><p>在不同的前端工具之间共享目标浏览器和Node.js版本的配置。它用于:</p><ul><li><a href="https://github.com/postcss/autoprefixer" target="_blank" rel="noopener">Autoprefixer</a></li><li><a href="https://github.com/babel/babel/tree/master/packages/babel-preset-env" target="_blank" rel="noopener">Babel</a></li><li><a href="https://github.com/jonathantneal/postcss-preset-env" target="_blank" rel="noopener">postcss-preset-env</a></li><li><a href="https://github.com/amilajack/eslint-plugin-compat" target="_blank" rel="noopener">eslint-plugin-compat</a></li><li><a href="https://github.com/ismay/stylelint-no-unsupported-browser-features" target="_blank" rel="noopener">stylelint-no-unsupported-browser-features</a></li><li><a href="https://github.com/jonathantneal/postcss-normalize" target="_blank" rel="noopener">postcss-normalize</a></li><li><a href="https://github.com/ElemeFE/obsolete-webpack-plugin" target="_blank" rel="noopener">obsolete-webpack-plugin</a></li></ul></blockquote><blockquote><p>当您将以下内容添加到package.json文件中时，所有工具都会自动找到目标浏览器:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&quot;browserslist&quot;: [</span><br><span class="line">  &quot;defaults&quot;,</span><br><span class="line">  &quot;not IE 11&quot;,</span><br><span class="line">  &quot;not IE_Mob 11&quot;,</span><br><span class="line">  &quot;maintained node versions&quot;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>或者在 .browserslistrc 配置文件中配置：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Browsers that we support</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line">not IE 11</span><br><span class="line">not IE_Mob 11</span><br><span class="line">maintained node versions</span><br></pre></td></tr></table></figure><blockquote><p>开发人员在设置版本列表后，比如设置了<code>last 2 version</code>(最后2个版本)，可以避免手动更新版本.<br>Browserslist将从配置文件中去查找：browserslist配置文件，.browserslistrc配置文件，或者package.json文件中的browserslist字段，或者各种环境配置等。<br><a href="https://github.com/browserslist/browserslist-example" target="_blank" rel="noopener">Browserslist Example</a>这个仓库显示了各个工具如何使用Browserslist。</p></blockquote><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><blockquote><ol><li>工具   </li><li>最佳实践   </li><li>查询指令   </li><li>配置文件   </li><li>可共享的配置   </li><li>不同环境下的配置</li><li>自定义使用数据 </li><li>JS API</li><li>环境变量   </li><li>缓存  </li></ol></blockquote><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><blockquote><ul><li><a href="https://browserl.ist/" target="_blank" rel="noopener">browserl.ist</a> 是用于检查某些查询将选择哪些浏览器的在线工具.     </li><li><code>browserslist-ga</code> and <code>browserslist-ga-export</code> download your website browsers statistics to use it in &gt; 0.5% in my stats query. </li><li>browserslist-useragent-regexp将Browserslist查询编译到RegExp以测试浏览器useragent。  </li><li>browserslist-useragent-ruby是一个Ruby库，用于按用户代理字符串检查浏览器是否与Browserslist相匹配。   </li><li>browserslist-browserstack为Browserslist配置中的所有浏览器运行BrowserStack测试。 </li><li>caniuse-api返回支持某些特定功能的浏览器.<br>在项目目录中运行<code>npx browserslist</code>以查看项目的目标浏览器。 此CLI工具是内置的，可在具有Autoprefixer的任何项目中使用.</li></ul></blockquote><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><blockquote><ul><li>下面是一个默认查询，它为大多数用户提供了合理的配置：  </li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;browserslist&quot;:&#123;</span><br><span class="line">    defaults</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>如果要更改我们推荐的默认浏览器集，请将 <code>last 2 versions</code>、<code>not dead</code> 与使用编号（如 <code>&gt;0.2%</code>）合并。这是因为  <code>last n versions</code> 本身不会添加流行的旧版本，而只使用高于 0.2% 的百分比，从长远来看，会使流行的浏览器更受欢迎。就像我们使用Internet Explorer 6一样，我们可能会陷入垄断和停滞状态。请谨慎使用此设置。    </li><li>仅当您使用一个浏览器为信息资讯制作网络应用程序时，才直接选择浏览器（最近2个Chrome版本）。 市场上有很多浏览器。 如果您要制作通用的Web应用程序，则应尊重浏览器的多样性。  </li><li>不要因为不了解浏览器就删除它们。Opera Mini在非洲拥有1亿用户，在全球市场上比微软Edge更受欢迎。中国QQ浏览器的市场份额比Firefox和Safari加起来还要大。</li></ul></blockquote><h3 id="查询指令"><a href="#查询指令" class="headerlink" title="查询指令"></a>查询指令</h3><blockquote><p>Browserslist将使用来自以下来源之一的浏览器和Node.js版本查询:  </p><ul><li>当前目录或父目录中package.json文件中的<code>browserslist</code>字段配置。 我们建议采用这种方式。   </li><li>在<code>.browserslistrc</code>或者<code>browserslist</code>配置文件中配置。 </li><li>BROWSERSLIST环境变量中配置。    </li><li>如果以上方法未产生有效结果，则Browserslist将使用默认值:<code>&gt;0.5%,last 2 versions,Firefox ESR,not dead</code>.    </li></ul></blockquote><h3 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h3><blockquote><p>or组合器可以使用关键字<code>or</code>或者使用<code>,</code>,<code>last 1 version or &gt;1%</code>与<code>last 1 version , &gt;1%</code>的表示方式是一样的。<br><code>and</code>支持查询组合来执行前一个查询的交集:<code>last 1 version and &gt;1%</code><br>如下所示，有3种不同的方法来组合查询。首先，您从单个查询开始，然后我们将这些查询组合起来以得到最终的列表:<br>显然，您不能从<code>not</code>组合器开始，因为没有左侧查询可以将其与之合并。</p></blockquote><table><thead><tr><th align="left">查询组合器类型</th><th align="left">图表表示</th><th align="left">示例</th></tr></thead><tbody><tr><td align="left">or/, combiner (union)</td><td align="left">并集</td><td align="left">&gt; .5% or last 2 versions /  &gt; .5%, last 2 versions</td></tr><tr><td align="left">and combiner (intersection)</td><td align="left">交集</td><td align="left">&gt; .5% and last 2 versions</td></tr><tr><td align="left">not combiner (relative complement)</td><td align="left">not</td><td align="left">&gt; .5% and not last 2 versions /    .5% or not last 2 versions /   .5%, not last 2 versions</td></tr></tbody></table><blockquote><p>测试查询的一种快速方法是在终端中执行<code>npx browserslist &#39;&gt; 0.5%, not IE 11&#39;</code>。</p></blockquote><h4 id="全部列表"><a href="#全部列表" class="headerlink" title="全部列表"></a>全部列表</h4><blockquote><p>可以通过查询指定浏览器和Node.js版本(不区分大小写):    </p><ul><li>defaults: Browserslist’s default browsers (&gt; 0.5%, last 2 versions, Firefox ESR, not dead). </li><li><code>&gt;</code> 5%: browsers versions selected by global usage statistics. &gt;=, &lt; and &lt;= work too.</li></ul></blockquote><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><blockquote><p>在终端中运行<code>npx browserslist</code>命令，查看您的查询选择了哪些浏览器：    </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">and_chr 78</span><br><span class="line">and_ff 68</span><br><span class="line">and_qq 1.2</span><br><span class="line">and_uc 12.12</span><br><span class="line">android 76</span><br><span class="line">baidu 7.12</span><br><span class="line">chrome 79</span><br><span class="line">chrome 78</span><br><span class="line">chrome 77</span><br><span class="line">chrome 49</span><br><span class="line">edge 18</span><br><span class="line">edge 17</span><br><span class="line">firefox 71</span><br><span class="line">firefox 70</span><br><span class="line">firefox 68</span><br><span class="line">ie 11</span><br><span class="line">ie_mob 11</span><br><span class="line">ios_saf 13.3</span><br><span class="line">ios_saf 13.2</span><br><span class="line">ios_saf 13.0-13.1</span><br><span class="line">ios_saf 12.2-12.4</span><br><span class="line">kaios 2.5</span><br><span class="line">op_mini all</span><br><span class="line">op_mob 46</span><br><span class="line">opera 64</span><br><span class="line">opera 63</span><br><span class="line">safari 13</span><br><span class="line">safari 12.1</span><br><span class="line">safari 5.1</span><br><span class="line">samsung 10.1</span><br><span class="line">samsung 9.2</span><br></pre></td></tr></table></figure><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><blockquote><p>名称不区分大小写：    </p><ul><li>Android for Android WebView.</li><li>Baidu for Baidu Browser.</li><li>BlackBerry or bb for Blackberry browser.</li><li>Chrome for Google Chrome.</li><li>ChromeAndroid or and_chr for Chrome for Android</li><li>Edge for Microsoft Edge.</li><li>Electron for Electron framework. It will be converted to Chrome version.</li><li>Explorer or ie for Internet Explorer.</li><li>ExplorerMobile or ie_mob for Internet Explorer Mobile.</li><li>Firefox or ff for Mozilla Firefox.</li><li>FirefoxAndroid or and_ff for Firefox for Android.</li><li>iOS or ios_saf for iOS Safari.</li><li>Node for Node.js.</li><li>Opera for Opera.</li><li>OperaMini or op_mini for Opera Mini.</li><li>OperaMobile or op_mob for Opera Mobile.</li><li>QQAndroid or and_qq for QQ Browser for Android.</li><li>Safari for desktop Safari.</li><li>Samsung for Samsung Internet.</li><li>UCAndroid or and_uc for UC Browser for Android.</li><li>kaios for KaiOS Browser.</li></ul></blockquote><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><h5 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;autoprefixer&quot;: &quot;^6.5.4&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;browserslist&quot;: [</span><br><span class="line">    &quot;last 1 version&quot;,</span><br><span class="line">    &quot;&gt; 1%&quot;,</span><br><span class="line">    &quot;IE 10&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="browserslistrc"><a href="#browserslistrc" class="headerlink" title=".browserslistrc"></a>.browserslistrc</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Browsers that we support</span><br><span class="line"></span><br><span class="line">last 1 version</span><br><span class="line">&gt; 1%</span><br><span class="line">IE 10 # sorry</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本博文是翻译：&lt;a href=&quot;https://github.com/browserslist/browserslist的内容。&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/browserslist/browserslist的内容。&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="文档翻译" scheme="http://liugezhou.online/categories/%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="browserslist" scheme="http://liugezhou.online/tags/browserslist/"/>
    
  </entry>
  
  <entry>
    <title>每周总结第二十七期</title>
    <link href="http://liugezhou.online/2020/01/10/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%83%E6%9C%9F/"/>
    <id>http://liugezhou.online/2020/01/10/每周总结第二十七期/</id>
    <published>2020-01-10T12:41:00.000Z</published>
    <updated>2020-01-12T12:54:32.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本周是2020年的第二个周末。<br>这里记录过去一周，我的一些总结。  </p><p><img src="http://img.liugezhou.online/weekly27.jpeg" alt="weekly-27">       </p><center>小狗钱钱</center></blockquote><a id="more"></a><h3 id="Feeling"><a href="#Feeling" class="headerlink" title="Feeling"></a>Feeling</h3><blockquote><p>《小狗钱钱》是由四川少年儿童出版社出版的一本图书。<br>由王钟欣、余茜合译的一部来自德国作家博多～舍费尔(Bodo Schaffer)的作品。 </p><p>这是一部很有意思的理财启蒙书籍，短小精悍，很值得花几个小时一看。<br>我跟着书中的思路游走，发现了一件特别有意思的事：</p><p>开始小狗钱钱让我们的小女主人公列出十个愿望。<br>于是,我也随之去想我的十个愿望，想了很长时间，天马行空扯开的去做梦，最后也才想到八个。<br>这其中很有韵味、很有意思的一件事就是去想这十个愿望的过程。  </p><p>在每想一个愿望的历程中，都在无比的考验你对这个世界、对自己的一些认知，发散思维激发想象力。</p><p>书中讲到的愿望相册、成功日记、理财的一些小知识、一些鸡汤等等都非常的耐人寻味。    </p><p>推荐我的朋友们读一读。</p></blockquote><h3 id="vlog达人张子贺"><a href="#vlog达人张子贺" class="headerlink" title="vlog达人张子贺"></a><a href="https://space.bilibili.com/89944567?spm_id_from=333.788.b_765f7570696e666f.1" target="_blank" rel="noopener">vlog达人张子贺</a></h3><blockquote><p>「每30天学会一个新技能、新知识，并用文字和视频分享教程和指南。」   </p><p>本周看了这个vlog博主的几个视频，里面讲到Rap、冥想、谷歌面试、远离手机等等挑战以及他之前的一些分享。<br>获益匪浅，很是漂亮。期待下一个30天挑战。<br><cite>公众号《张子贺》</cite></p></blockquote><h3 id="北京公积金提取申请人可以网上办理"><a href="#北京公积金提取申请人可以网上办理" class="headerlink" title="北京公积金提取申请人可以网上办理"></a><a href="http://www.gov.cn/xinwen/2020-01/09/content_5467875.htm" target="_blank" rel="noopener">北京公积金提取申请人可以网上办理</a></h3><blockquote><p>2020年1月10日起，北京公积金提取申请人可以网上办理。<br>北京住房公积金网：<a href="http://gjj.beijing.gov.cn/" target="_blank" rel="noopener">http://gjj.beijing.gov.cn/</a>  </p><p><cite> <a href="http://gjj.beijing.gov.cn/web/zwgk/_300583/zxzysx/675803/index.html" target="_blank" rel="noopener">官网公告</a></cite></p></blockquote><h3 id="2020微信公开课PRO"><a href="#2020微信公开课PRO" class="headerlink" title="2020微信公开课PRO"></a><a href="https://baijiahao.baidu.com/s?id=1655219878385555103&wfr=spider&for=pc" target="_blank" rel="noopener">2020微信公开课PRO</a></h3><blockquote><p>1月9日，2020微信公开课PRO在广州举行。</p><ul><li>2020年1月9日，小程序框架正式开放，可支持小程序在硬件运行. </li><li>2020年1月10日，小程序“订阅消息”能力上线，</li></ul></blockquote><h3 id="深海网站"><a href="#深海网站" class="headerlink" title="深海网站"></a><a href="https://neal.fun/deep-sea/" target="_blank" rel="noopener">深海网站</a></h3><blockquote><p>这个网站可以不停往下拉，看看每个深度的海底都有些什么生物,可以一直拉到10000多一点米。<br>对于海洋、水下世界感兴趣的人儿来说，这真是一个不错的网站。      </p></blockquote><h3 id="isometric-Contributions"><a href="#isometric-Contributions" class="headerlink" title="isometric Contributions"></a>isometric Contributions</h3><blockquote><p>这个插件有点酷 ，Isometric Contributions：它可以让我们 Github 的贡献图变成 3D 效果：</p><p><img src="http://img.liugezhou.online/weekly27Github.png" alt="浏览器插件"></p></blockquote><h3 id="zsh-和-bash的区别-以及切换"><a href="#zsh-和-bash的区别-以及切换" class="headerlink" title="zsh 和 bash的区别 以及切换"></a>zsh 和 bash的区别 以及切换</h3><blockquote><p>从 macOS Catalina Beta 版开始，zsh (Z shell) 是所有新建用户帐户的默认 Shell。<br>zsh完美兼容bash，并且有比bash更强大的功能，用起来也比bash更优雅。</p><p>切换bash与zsh命令，在终端中输入：<code>chsh -s /bin/zsh</code>或者<code>chsh -s /bin/bash</code>。    </p><p>切换zsh后，shell由原来的bash变成了zsh，打开终端，发现终端中名字重复显示、或者其他异常显示情况，修改为： </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">touch ~/.zshrc</span><br><span class="line">echo &quot;export PS1=&apos;%n %c $&apos;&quot; &gt;&gt; ~/.zshrc</span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><blockquote><p>最后，如果你在bash命令行下的<code>.bash_profile</code>文件中有maven等的配置，需要添加至<code>.zshrc</code>中。</p></blockquote><h3 id="Mithril框架入门"><a href="#Mithril框架入门" class="headerlink" title="Mithril框架入门"></a><a href="https://mithril.js.org/" target="_blank" rel="noopener">Mithril框架入门</a></h3><blockquote><p>Mithril 是一个前端 JS 框架，只有 9.5KB，如果你感到 React 或 Vue 太重，应该看看这个框架。<br>Github Star数：11930.</p><p>周末在家花了一些时间，翻译了一下官方文档的介绍和安装使用模块，提交至:<a href="https://github.com/liugezhou/Mithril" target="_blank" rel="noopener">https://github.com/liugezhou/Mithril</a></p></blockquote><h3 id="npm-init-–yes"><a href="#npm-init-–yes" class="headerlink" title="npm init –yes"></a>npm init –yes</h3><blockquote><p>npm init 命令用来初始化一个简单的 package.json 文件。<br>而如果想要偷懒步免去一直按 enter，在命令后追加 –yes 参数即可，其作用与一路下一步相同。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init --yes</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本周是2020年的第二个周末。&lt;br&gt;这里记录过去一周，我的一些总结。  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img.liugezhou.online/weekly27.jpeg&quot; alt=&quot;weekly-27&quot;&gt;       &lt;/p&gt;
&lt;center&gt;小狗钱钱&lt;/center&gt;

&lt;/blockquote&gt;
    
    </summary>
    
      <category term="每周分享" scheme="http://liugezhou.online/categories/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="每周分享" scheme="http://liugezhou.online/tags/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>每周总结第二十六期</title>
    <link href="http://liugezhou.online/2020/01/05/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%85%AD%E6%9C%9F/"/>
    <id>http://liugezhou.online/2020/01/05/每周总结第二十六期/</id>
    <published>2020-01-05T04:41:00.000Z</published>
    <updated>2020-01-10T02:35:22.442Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这里记录过去一周，我的一些总结。<br><img src="http://img.liugezhou.online/weekly26.png" alt="weekly-26"></p></blockquote><a id="more"></a><h3 id="Feeling"><a href="#Feeling" class="headerlink" title="Feeling"></a>Feeling</h3><blockquote><p>2019年年初定了些目标，下面是一些可以量化的年初计划以及完成情况：</p><table><thead><tr><th align="left">19年年初目标</th><th align="center">完成情况</th><th align="center">完成占比</th></tr></thead><tbody><tr><td align="left">学完Vue.js开发音乐WebAPP</td><td align="center">粗略勉强学完</td><td align="center">70%</td></tr><tr><td align="left">简书粉丝达到300</td><td align="center">粉丝198</td><td align="center">66%</td></tr><tr><td align="left">简书获得2500个喜欢</td><td align="center">获得1212个喜欢</td><td align="center">49%</td></tr><tr><td align="left">简书文章目标200篇</td><td align="center">完成44篇</td><td align="center">22%</td></tr><tr><td align="left">读书清单</td><td align="center">乱七八糟</td><td align="center">10%</td></tr><tr><td align="left">学习Python,完成Python两个专题的文章</td><td align="center">未学习</td><td align="center">0%</td></tr><tr><td align="left">学完Vue.js源码</td><td align="center">未学习</td><td align="center">0%</td></tr><tr><td align="left">整理100个前端方面的知识</td><td align="center">未开始</td><td align="center">0%</td></tr></tbody></table><p>下面是2019年可以量化的额外收获：    </p><table><thead><tr><th align="left">内容</th><th align="center">量化</th></tr></thead><tbody><tr><td align="left">重新搭建 个人博客</td><td align="center">完成日志61篇</td></tr><tr><td align="left">英语百词斩背单词</td><td align="center">坚持天数187天</td></tr><tr><td align="left">【六个周】公众号被封，转战【Dangerous Wakaka】</td><td align="center">18篇周总结，与个人博客冲突</td></tr><tr><td align="left">Github代码提交天数</td><td align="center">231Day</td></tr></tbody></table><p>总结：2019年是初尝试的一年，不禁感觉时间飞快，年初稀里糊涂定的小目标早已遗忘，每天在坚持做的一些事情，也是缺少动力激情下在苟延残喘。但即使做的不好，也要继续坚持做下去，除了更加用心以外，也希望量变可以引起质变，下面是刚刚想到的2020年的一些小目标。    </p><table><thead><tr><th align="left">新年目标</th><th align="center">量化标准</th></tr></thead><tbody><tr><td align="left">Github代码提交全绿</td><td align="center">完成天数/总天数为完成比率</td></tr><tr><td align="left">英语百词斩每日背一会单词</td><td align="center">总天数/打卡天数</td></tr><tr><td align="left">每周总结</td><td align="center">总周数/完成周数</td></tr><tr><td align="left">优化博客</td><td align="center">博客的重新搭建或者继续构建</td></tr><tr><td align="left">Node.js技术栈</td><td align="center">有关node的技术文章、项目等数据</td></tr><tr><td align="left">Vue.js基础到源码再深入</td><td align="center">源码视频学习、英文文档学习</td></tr></tbody></table></blockquote><h3 id="曼德拉效应"><a href="#曼德拉效应" class="headerlink" title="曼德拉效应"></a>曼德拉效应</h3><blockquote><p>2010年，美国作家菲安娜·布梅（Fiona Broome）惊奇地发现，有“南非国父”之称的南非政治家纳尔逊·曼德拉（Nelson Mandela）竟然还存于人世。而她记得明明在上世纪八十年代，曼德拉就死于狱中。她问过身边的人，也有不少人记得曼德拉早已逝世。</p><p>当2013年12月5日曼德拉因肺部感染去世时，疑惑与惊异再次出现：他不是早就死了吗?<br>这种记忆与现实的割裂，由此得名“曼德拉效应”（Mandela Effect）。</p><p>简单说来，“曼德拉效应”是指集体性的记忆与事实不符的现象。</p><p><cite><a href="https://zhuanlan.zhihu.com/p/55874734" target="_blank" rel="noopener">相关阅读*曼德拉效应背后的时间重置——世界的真相还是伪科学？</a></cite></p></blockquote><h3 id="农村土地确权"><a href="#农村土地确权" class="headerlink" title="农村土地确权"></a>农村土地确权</h3><blockquote><p>土地所有权、土地使用权和他项权利的确认、确定，简称确权。是依照法律、政策的规定确定某一范围内的土地（或称一宗地）的所有权、使用权的隶属关系和他项权利的内容。<br>每宗地的土地权属要经过土地登记申请、地籍调查、核属审核、登记注册、颁发土地证书等土地登记程序，才能得到最后的确认和确定。2013年1月31日下发的中央一号文件提出，全面开展农村土地确权登记颁证工作。<br>2018年3月，我国正式启动农村房屋不动产登记发证试点工作。<br><cite><a href="https://mp.weixin.qq.com/s/9YTzzn1Se8Fzs76HGnlpHg" target="_blank" rel="noopener">相关阅读*武安老家有房的快瞧瞧吧！这6种宅基地将不再属于自己，也无法继承</a></cite></p></blockquote><h3 id="京张高铁2019年12月30日开通运营"><a href="#京张高铁2019年12月30日开通运营" class="headerlink" title="京张高铁2019年12月30日开通运营"></a><a href="http://www.beijing.gov.cn/fuwu/bmfw/jtcx/ggts/t1611464.htm" target="_blank" rel="noopener">京张高铁2019年12月30日开通运营</a></h3><blockquote><p>12月30日，北京至张家口高速铁路(京张高铁)开通运营，崇礼铁路同步建成投用。<br>京张高铁全长174公里，最高设计时速350公里，全线设北京北、清河、沙河(不办理客运)、昌平、八达岭长城、东花园北、怀来、下花园北、宣化北、张家口10座车站。崇礼铁路自京张高铁下花园北站引出，至崇礼区太子城奥运村，线路全长53公里，设计时速250公里。</p></blockquote><h3 id="特斯拉Model3"><a href="#特斯拉Model3" class="headerlink" title="特斯拉Model3"></a>特斯拉Model3</h3><blockquote><p>特斯拉宣布，即日起，特斯拉调整全系Model 3销售政策：中国制造Model 3基础车价从35.58万元下调至32.38万元（包含基础版辅助驾驶功能）。</p><p>同时，根据国家政策，全系Model 3可以享受免征购置税政策，以及2.475万元的新能源补贴金额，中国制造Model 3补贴后售价为29.905万元。</p><p>1月7日，中国制造Model 3将正式对外交付。</p></blockquote><h3 id="gitignore"><a href="#gitignore" class="headerlink" title=".gitignore"></a><a href="https://github.com/github/gitignore" target="_blank" rel="noopener">.gitignore</a></h3><blockquote><p>GitHub 有一个十分详细的针对数十种项目及语言的 .gitignore 文件列表，你可以在 <a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a> 找到它.</p></blockquote><h3 id="推荐一些-Mac-上比较好用的软件"><a href="#推荐一些-Mac-上比较好用的软件" class="headerlink" title="推荐一些 Mac 上比较好用的软件"></a><a href="https://mp.weixin.qq.com/s/Sgk1f_xgFXphQfGdNAlypw" target="_blank" rel="noopener">推荐一些 Mac 上比较好用的软件</a></h3><blockquote><p>一篇推荐Mac上比较好用的一些工具。</p></blockquote><h3 id="2019年前端大事件回顾：流年笑掷，未来可期"><a href="#2019年前端大事件回顾：流年笑掷，未来可期" class="headerlink" title="2019年前端大事件回顾：流年笑掷，未来可期"></a><a href="https://juejin.im/post/5def782ce51d4558181d27ce" target="_blank" rel="noopener">2019年前端大事件回顾：流年笑掷，未来可期</a></h3><blockquote><p>回顾2019年前端和Web开发的主要事件，新闻和趋势.</p></blockquote><h3 id="CODEOWNERS"><a href="#CODEOWNERS" class="headerlink" title="CODEOWNERS"></a>CODEOWNERS</h3><blockquote><p>提交Github文件时，如果你想让自己提交的每一个文件都有一个owner的标识，可以在项目根目录下添加 CODEOWNERS文件。</p></blockquote><h3 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h3><blockquote><p>2020 = 404 + 404 + 404 + 404+ 404<br>2020 = 1024 + 996</p></blockquote><h3 id="node-js入门"><a href="#node-js入门" class="headerlink" title="node.js入门"></a><a href="https://www.liugezhou.online/2020/01/03/node%E5%85%A5%E9%97%A8/" target="_blank" rel="noopener">node.js入门</a></h3><blockquote><p>最近有一个node服务的项目需要去接手，于是在阅读学习各种有关node的文章，零零总总的看了一些文章，感觉还是一团浆糊，遂整理总结出此文。<br>此文并未加入自己的理解，主要是从网上查阅资料看到的一些入门教程，将教程中的讲解进行重点知识的记录、梳理。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这里记录过去一周，我的一些总结。&lt;br&gt;&lt;img src=&quot;http://img.liugezhou.online/weekly26.png&quot; alt=&quot;weekly-26&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="每周分享" scheme="http://liugezhou.online/categories/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="每周分享" scheme="http://liugezhou.online/tags/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Node入门</title>
    <link href="http://liugezhou.online/2020/01/03/node%E5%85%A5%E9%97%A8/"/>
    <id>http://liugezhou.online/2020/01/03/node入门/</id>
    <published>2020-01-03T10:00:00.000Z</published>
    <updated>2020-01-10T06:27:21.056Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><hr><blockquote><p>最近有一个node服务的项目需要去接手，于是在阅读学习各种有关node的文章，零零总总的看了一些文章，感觉还是一团浆糊，遂整理总结出此文。<br>此文并未加入自己的理解，主要是从网上查阅资料看到的一些入门教程，将教程中的讲解进行重点知识的记录、梳理。</p></blockquote><a id="more"></a><h3 id="廖雪峰官网的Node-js"><a href="#廖雪峰官网的Node-js" class="headerlink" title="廖雪峰官网的Node.js"></a><a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023025235359040" target="_blank" rel="noopener">廖雪峰官网的Node.js</a></h3><h4 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h4><hr><blockquote><p>在2009年，Ryan正式推出了基于JavaScript语言和V8引擎的开源Web服务器项目，命名为Node.js。虽然名字很土，但是，Node第一次把JavaScript带入到后端服务器开发，加上世界上已经有无数的JavaScript开发人员，所以Node一下子就火了起来。    </p></blockquote><blockquote><p>由于一群开发者对Joyent公司的策略不满(Node幕后一直由Joyent公司资助)，于2014年从Node.js项目fork出了io.js项目，决定单独发展，但两者实际上是兼容的。  </p></blockquote><blockquote><p>“分久必合，合久必分”,Joyent公司表示要和解,io.js项目又决定回归Node.js。    </p></blockquote><blockquote><p>将来io.js将首先添加新的特性，如果大家测试用得爽，就把新特性加入Node.js。io.js是“尝鲜版”，而Node.js是线上稳定版，</p></blockquote><h4 id="安装node-js和npm"><a href="#安装node-js和npm" class="headerlink" title="安装node.js和npm"></a>安装node.js和npm</h4><hr><blockquote><p>首先，从Node.js官网下载对应平台的安装程序.<br>安装完成后，在终端中输出：<code>node -v</code>,显示版本号，说明安装成功。</p></blockquote><blockquote><p>npm是Node.js的包管理工具（package manager）。<br>npm已经在Node.js安装的时候顺带装好了。我们在命令提示符或者终端输入<code>npm -v</code>,显示版本号。</p></blockquote><h4 id="第一个Node程序"><a href="#第一个Node程序" class="headerlink" title="第一个Node程序"></a>第一个Node程序</h4><hr><blockquote><p>命令行模式下，输入<code>node</code>回车，进入Node交互式环境。<br>或者也可以直接<code>node hello.js</code>运行一个.js文件。</p></blockquote><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><hr><blockquote><p>在Node环境中，一个.js文件就称之为一个模块（module）。<br>使用模块可以避免函数名和变量名冲突。这是因为：JavaScript是一种<code>函数式编程语言</code>，它支持闭包。如果我们把一段JavaScript代码用一个函数包装起来，这段代码的所有“全局”变量就变成了函数内部的局部变量。而Node加载一个模块，其实就是对代码进行了一层包装。</p></blockquote><blockquote><p>要在模块中对外输出变量，用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module.exports = variable;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>输出的变量可以是任意对象、函数、数组等等。<br>要引入其他模块输出的对象，用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var foo = require(&apos;other_module&apos;);</span><br></pre></td></tr></table></figure></blockquote><blockquote><p> 引入的对象具体是什么，取决于引入模块输出的对象。</p></blockquote><blockquote><p>关于Node.js的模块原理：<br>JavaScript语言本身并没有一种模块机制来保证不同模块可以使用相同的变量名。而是因为由于JavaScript是一种函数式编程语言，它支持闭包，Node加载一个js文件，就相当于把代码包装了一下，原来代码中的全局变量变成了函数内部的局部变量，因此每个模块中定义的全局变量并不会相互干扰。</p></blockquote><h4 id="基本模块"><a href="#基本模块" class="headerlink" title="基本模块"></a>基本模块</h4><hr><blockquote><p>Node.js内置的常用模块是为了实现基本的服务器功能，这些模块在浏览器环境中是无法执行的，因为它们的底层代码是用C/C++在Node.js运行环境中实现的。   </p></blockquote><blockquote><ul><li>global:相当于浏览器环境中的window。<br>在终端中输入node进入node环境，然后输入：<code>for (var k of Object.keys(global)) { console.log(k);}</code>,可以查看输出的结果，以更好理解global。</li></ul></blockquote><blockquote><ul><li>process: 是Node.js提供的一个对象，它代表当前Node.js进程。<br>如果我们想要在下一次事件响应中执行代码，可以调用process.nextTick().</li></ul></blockquote><h4 id="fs"><a href="#fs" class="headerlink" title="fs"></a>fs</h4><hr><blockquote><p>Node.js内置的fs模块是文件系统模块，负责读写文件。<br>fs模块同时提供了异步和同步的方法。 </p></blockquote><h5 id="异步读取文件"><a href="#异步读取文件" class="headerlink" title="异步读取文件"></a>异步读取文件</h5><blockquote><p>异步读取一个文件的代码如下： <code>fs.readFile(&#39;sample.txt&#39;,&#39;utf-8&#39;,function(err, data){})</code><br>异步读取时，传入的回调函数接受两个参数，当正常读取时，err参数为null，data参数为读取到的string。当读取发生错误时，err参数代表一个错误对象，data为undefined。<br>这也是Node.js标准的回调函数：第一个参数代表错误信息，第二个参数代表结果。后面我们会经常用到这种回调函数。 </p></blockquote><blockquote><p>读取二进制文件时，<code>fs.readFile(&#39;demo.png&#39;,function(err, data){}</code><br>不传入文件编码时，回调函数的data返回的是一个Buffer对象。在Node中，Buffer对象就是一个包含零个或任意个字节数的数组(与Array不同)。<br>Buffer对象转换为String：<code>data.toString(&#39;utf-8&#39;)</code>;<br>String对象转换为Buffer：<code>Buffer.from(data,&#39;utf-8&#39;)</code>;  </p></blockquote><h5 id="同步读取文件"><a href="#同步读取文件" class="headerlink" title="同步读取文件"></a>同步读取文件</h5><blockquote><p><code>fs.readFileSync()</code>;</p></blockquote><h5 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h5><blockquote><p><code>fs.writeFile(&#39;output.txt&#39;,data, function(err){}</code>;<br>writeFile()的参数依次为文件名、数据和回调函数。<br>和readFileSync()类似，写入文件也有一个同步方法：writeFileSync();  </p></blockquote><h5 id="stat"><a href="#stat" class="headerlink" title="stat"></a>stat</h5><blockquote><p>如果我们要获取文件大小、创建时间等信息，可以使用fs.stat()方法，此方法返回一个stat对象，能告诉我们目录文件详细信息。<br>是否是文件：<code>stat.isFile()</code>;<br>是否是目录：<code>stat.isDirectory()</code>;<br>若是文件，文件大小： <code>stat.size</code>;<br>若是文件，文件创建时间：<code>stat.birthtime</code>;<br>若是文件，文件修改时间：<code>stat.mtime</code>; </p></blockquote><blockquote><p><code>stat()</code>也有一个对应的同步方法：<code>statSync()</code>;</p></blockquote><h4 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h4><hr><blockquote><p>stream是Node.js提供的又一个仅在服务端可用的模块，目的是支持“流”这种数据结构。<br>流分为：stain(标准输入流)、staout(标准输出流)。   </p></blockquote><blockquote><p>读取文件流的核心语法是： <code>fs.createReadStream()</code>,代码见：<a href="https://github.com/liugezhou/koa/blob/master/basic/steam/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%96%87%E6%9C%AC.js" target="_blank" rel="noopener">文件读取文本</a>  </p></blockquote><blockquote><p>以流的形式写入文件，只有不断调用write()方法，代码见：<a href="https://github.com/liugezhou/koa/blob/master/basic/steam/%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6.js" target="_blank" rel="noopener">文本写入文件</a></p></blockquote><blockquote><p>将Readable流和Writable流串起来，所有的数据从Readable流进入Writable流，这种操作叫做pipe。在Node.js中，Readable流有一个pipe()方法，就是用来干这件事的。代码见：<a href="https://github.com/liugezhou/koa/blob/master/basic/steam/pipe.js" target="_blank" rel="noopener">pipe</a></p></blockquote><h4 id="http"><a href="#http" class="headerlink" title="http"></a>http</h4><hr><blockquote><p>要开发HTTP服务器程序，从头处理TCP连接，解析HTTP是不现实的。这些工作实际上已经由Node.js自带的http模块完成了。应用程序并不直接和HTTP协议打交道，而是操作http模块提供的request和response对象。</p></blockquote><blockquote><p>request对象封装了HTTP请求，我们调用request对象的属性和方法就可以拿到所有HTTP请求的信息；</p></blockquote><blockquote><p>response对象封装了HTTP响应，我们操作response对象的方法，就可以把HTTP响应返回给浏览器。</p></blockquote><h4 id="crypto"><a href="#crypto" class="headerlink" title="crypto"></a>crypto</h4><hr><blockquote><p>crypto模块的目的是为了提供通用的加密和哈希算法。用纯JavaScript代码实现这些功能不是不可能，但速度会非常慢。Nodejs用C/C++实现这些算法后，通过crypto这个模块暴露为JavaScript接口，这样用起来方便，速度也快。 </p></blockquote><blockquote><ul><li>MD5和SHA1是常用的哈希算法，用于给任意数据一个“签名”，这个签名通常用一个十六进制的字符串表示。   </li><li>Hmac算法：也是一种哈希算法，不同的是，它还需要加一个密钥。  </li><li>AES算法：是一种常用的对称加密算法，加解密都用同一个密钥。   </li><li>Diffie-Hellman：DH算法是一种密钥交换协议。  </li><li>RAS：RAS算法是一种对称加密算法</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;最近有一个node服务的项目需要去接手，于是在阅读学习各种有关node的文章，零零总总的看了一些文章，感觉还是一团浆糊，遂整理总结出此文。&lt;br&gt;此文并未加入自己的理解，主要是从网上查阅资料看到的一些入门教程，将教程中的讲解进行重点知识的记录、梳理。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Node.js" scheme="http://liugezhou.online/categories/Node-js/"/>
    
    
      <category term="node" scheme="http://liugezhou.online/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>每周总结第二十五期</title>
    <link href="http://liugezhou.online/2019/12/29/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%94%E6%9C%9F/"/>
    <id>http://liugezhou.online/2019/12/29/每周总结第二十五期/</id>
    <published>2019-12-29T04:15:00.000Z</published>
    <updated>2019-12-29T04:15:49.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这里记录过去一周，我的一些小总结。<br> <img src="http://img.liugezhou.online/weekly25.jpeg" alt="weekly-25"></p></blockquote><a id="more"></a><h3 id="Feeling"><a href="#Feeling" class="headerlink" title="Feeling"></a>Feeling</h3><blockquote><p>何谓朋友？ </p><p>我曾以狭隘的思考巴拉巴拉的说道：</p><p>其实朋友这个词的出现，是因为身为有意识的个体在这个世界出现后.<br>多数时间的独处.<br>可能因为害怕孤单、可能因为享受快乐，也可能因为骄傲，等等的一些生活感受.<br>而使得想要有所依靠、分享、诉说，因而有了朋友。  </p><p>其实朋友这个名词不重要。<br>还在乎朋友是因为自己内心不够平静.<br>而且你没有发现，很多所谓朋友的交流:<br>在漫漫、而浮于表面—-没有内涵。<br>而且加上因为个体自我的期望没有实现，<br>因此才想要在社交中与他人的交流中去给予自我一些宽慰，这种心理的深处、<br>可能就是不自信、不充实。<br>而朋友出现了，一次次的缓解你这个感触，直到你没有这个感触。</p><p>aliya告诉我说： </p><p>因为你有我.<br>所以可能你会暂时天真的以为没有朋友也没事，<br>你也可以天真的这么突然自以为。<br>但是有的人不是啊，没对象没家庭，那怎么证明自己还活着？<br>就是朋友啊。<br>什么平静、自信、充实，也不过是活着的附加品。<br>朋友的存在就是证明着你还活着。<br>朋友的意义对于一些人来说，对于大多数还没找寻到人生的目标前，朋友是他们生命中一部分的意义。</p></blockquote><h3 id="重磅文件！中国户籍制度大变局"><a href="#重磅文件！中国户籍制度大变局" class="headerlink" title="重磅文件！中国户籍制度大变局"></a><a href="https://mp.weixin.qq.com/s/L4LLwv1Q5SLLqkuU66bLMA" target="_blank" rel="noopener">重磅文件！中国户籍制度大变局</a></h3><blockquote><p>2019年12月25日(本周三)，中共中央办公厅 国务院办公厅印发《关于促进劳动力和人才社会性流动体制机制改革的意见》，详见<a href="http://www.gov.cn/zhengce/2019-12/25/content_5463978.htm" target="_blank" rel="noopener">这里</a>.    </p><p>以下内容来自公众号《最爱大北京》的一些内容摘要，文章链接<a href="https://mp.weixin.qq.com/s/L4LLwv1Q5SLLqkuU66bLMA" target="_blank" rel="noopener">点击这里</a> </p><p><code>全面取消</code>城区常住人口300万以下的城市落户限制，<code>全面放宽</code>城区常住人口300万至500万的大城市落户条件。</p><p><code>完善</code>城区常住人口500万以上的超大特大城市<code>积分落户政策</code>，精简积分项目，确保社会保险缴纳年限和居住年限分数占主要比例。<br>以合肥、昆明、苏州、大连、南宁为代表的I型大城市将全面放宽落户条件，石家庄、南昌、无锡、珠海、常州等II型大城市，以及所有的三四线中小城市，都会<code>全面取消落户限制</code>。</p></blockquote><h3 id="一锤定音，70年产权到期后可续期，房产税要加速来了？"><a href="#一锤定音，70年产权到期后可续期，房产税要加速来了？" class="headerlink" title="一锤定音，70年产权到期后可续期，房产税要加速来了？"></a><a href="https://36kr.com/p/5152186?ktm_source=feed" target="_blank" rel="noopener">一锤定音，70年产权到期后可续期，房产税要加速来了？</a></h3><blockquote><p>70年产权的计算是从开发商拿地开始起计，不是从你买房或拿到房产证那一刻开始算的。<br>世界上其他国家的房产基本都是永久产权，为什么我们国家只有70年的产权呢？<br>产权到期了该怎么办？<br>房产税会怎么征收？</p><p>这是一篇来自2018年9月17日的一篇资讯。<a href="https://36kr.com/p/5152186?ktm_source=feed" target="_blank" rel="noopener">文章来源</a></p></blockquote><h3 id="问医生"><a href="#问医生" class="headerlink" title="问医生"></a>问医生</h3><blockquote><p>微信搜一搜上线健康搜索服务，其中，健康搜索服务中主要分为三方面：健康信息查询、在线问医生，和预约挂号。</p><p>在微信搜一搜中输入病的症状（“头疼”、“发烧”等），搜索结果将展示：病因、就医方法、治疗等说明和建议。</p><p>内容来源包含众多实名医生背书的权威医疗内容、和由权威医学专家团编写的常见疾病及药品百科词条的专业解读。</p></blockquote><h3 id="北京7号线双井站开通"><a href="#北京7号线双井站开通" class="headerlink" title="北京7号线双井站开通"></a><a href="http://www.bjnews.com.cn/news/2019/12/26/666505.html" target="_blank" rel="noopener">北京7号线双井站开通</a></h3><blockquote><p>昨日(周六)，北京7号线东延、八通线南延开通试运营。<br>7号线双井站开通使用，换乘通道将同步开通，不过工作日自首班车至上午10时，7号线和10号线双井站分别独立开放运营，其他时段可以在双井站换乘。</p></blockquote><h3 id="北京新能源指标申请数已超45万！新申请或等9年才有资购车"><a href="#北京新能源指标申请数已超45万！新申请或等9年才有资购车" class="headerlink" title="北京新能源指标申请数已超45万！新申请或等9年才有资购车"></a><a href="https://news.mydrivers.com/1/664/664083.htm" target="_blank" rel="noopener">北京新能源指标申请数已超45万！新申请或等9年才有资购车</a></h3><blockquote><p>12月25日，北京小客车指标办公发布了今年最后一期指标配置数据。新能源小客车指标申请个人共有458673个，单位共有11263家，本期申请人数增加1万人左右。<br>按照每年5.4万个新能源指标计算，且今年的指标已完全用尽。所以，如果按照现行规则不变，新能源指标新申请者或将等待9年，也就是2028年才能获得指标。<br><cite><a href="https://news.mydrivers.com/1/664/664083.htm" target="_blank" rel="noopener">文章来源</a></cite></p></blockquote><h3 id="牙医"><a href="#牙医" class="headerlink" title="牙医"></a>牙医</h3><blockquote><p>美国教育部公布官方数据，美国大学毕业生第一年收入最高的各校专业排名，前十名里面有九个是牙医专业.<br><cite>阮一峰的网络日志</cite></p></blockquote><h3 id="腾讯会议APP"><a href="#腾讯会议APP" class="headerlink" title="腾讯会议APP"></a>腾讯会议APP</h3><blockquote><p>腾讯推出的一块开会APP。<br>全平台运行，手机、电脑、平板、Web一键入会。小程序打开即用，不需要下载任何插件或客户端。支持手机录屏等功能。</p></blockquote><h3 id="圣诞节前成功断网！俄罗斯举行首次国家级断网演习引热议"><a href="#圣诞节前成功断网！俄罗斯举行首次国家级断网演习引热议" class="headerlink" title="圣诞节前成功断网！俄罗斯举行首次国家级断网演习引热议"></a><a href="https://mp.weixin.qq.com/s/XfJvYuMb-M3-kHpibPsOTg" target="_blank" rel="noopener">圣诞节前成功断网！俄罗斯举行首次国家级断网演习引热议</a></h3><blockquote><p>俄罗斯政府宣布，已完成一系列测试，成功地使该国脱离了全球互联网，从而使俄罗斯的RuNet成为全球最大的内部网。此举引发专家担忧和网友热议：这意味着人们将无法就本国正在发生的事情进行对话，而陷入自己的泡沫中。<br><cite><a href="https://mp.weixin.qq.com/s/XfJvYuMb-M3-kHpibPsOTg" target="_blank" rel="noopener">文章来源</a></cite></p></blockquote><h3 id="Tiobe"><a href="#Tiobe" class="headerlink" title="Tiobe"></a>Tiobe</h3><blockquote><p>TIOBE排行榜是根据互联网上有经验的程序员、<code>课程</code>和第三方厂商的数量，并使用搜索引擎（如Google、Bing、Yahoo!）以及Wikipedia、Amazon、YouTube统计出排名数据，只是反映某个编程语言的热门程度，并不能说明一门编程语言好不好，或者一门语言所编写的代码数量多少。<br>2019年12月编程语言排行榜,前十名依次为：<br>Java、C、Python、C++、c#、Visual Basic .NET、JavaScript、PHP、SQL、Swift。<br><cite><a href="https://hellogithub.com/report/tiobe/" target="_blank" rel="noopener">排名来源</a></cite></p></blockquote><h3 id="node入门"><a href="#node入门" class="headerlink" title="node入门"></a>node入门</h3><blockquote><p>这是一篇短小精悍的node入门教程。<br>为了更彻底、清楚的学习本教程，我在Github上整理了一个<a href="https://github.com/liugezhou/nodejs_getting_started" target="_blank" rel="noopener">仓库</a>。</p><p>这篇文章关于JavaScript的一点描述说道：<br>“尽管当想要增强页面的时候，使用jQuery总让你觉得很爽，但到最后，你顶多是个JavaScript用户，而非JavaScript开发者。”  </p><p>于是勉励自己，对JS的掌握，慢慢能成为其开发者，而不仅仅是其用户。</p></blockquote><h3 id="浏览器工作原理与实践"><a href="#浏览器工作原理与实践" class="headerlink" title="浏览器工作原理与实践"></a><a href="https://liugezhou.gitbook.io/liugezhou/" target="_blank" rel="noopener">浏览器工作原理与实践</a></h3><blockquote><p>历时两个月将《极客时间》上的一个专栏进行了通篇学习。并且整理自<a href="https://liugezhou.gitbook.io/liugezhou/" target="_blank" rel="noopener">Gitbook</a>.     </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这里记录过去一周，我的一些小总结。&lt;br&gt; &lt;img src=&quot;http://img.liugezhou.online/weekly25.jpeg&quot; alt=&quot;weekly-25&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="每周分享" scheme="http://liugezhou.online/categories/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="每周分享" scheme="http://liugezhou.online/tags/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>每周总结第二十四期</title>
    <link href="http://liugezhou.online/2019/12/22/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%9B%9B%E6%9C%9F/"/>
    <id>http://liugezhou.online/2019/12/22/每周总结第二十四期/</id>
    <published>2019-12-22T10:08:00.000Z</published>
    <updated>2019-12-23T01:34:54.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这里记录过去一周，我的一些小总结。<br> <img src="http://img.liugezhou.online/weekly24.jpeg" alt="weekly-24"></p></blockquote><a id="more"></a><h4 id="Feeling"><a href="#Feeling" class="headerlink" title="Feeling"></a>Feeling</h4><blockquote><p>最近几年喝酒好似没有了年轻时的浪荡不羁。<br>每次喝毕总有一些稀奇古怪的感受，第二天醒来一阵落幕感袭来。<br>就立个flag：以后不喝酒了，Quit Drinking。  </p></blockquote><h4 id="羞愧"><a href="#羞愧" class="headerlink" title="羞愧"></a>羞愧</h4><blockquote><p>当aliya问我什么是车厘子的时候，我说不知道。<br>她说：你应该问此而羞愧，我说的羞愧指的并不是你不知道这个东西 而是你知道你不知道后还不知道。   </p></blockquote><h4 id="关于侵害用户权益行为的APP（第一批）通报"><a href="#关于侵害用户权益行为的APP（第一批）通报" class="headerlink" title="关于侵害用户权益行为的APP（第一批）通报"></a><a href="http://www.miit.gov.cn/n1146290/n1146402/n1146440/c7575066/content.html?tsrrbdcdnht=" target="_blank" rel="noopener">关于侵害用户权益行为的APP（第一批）通报</a></h4><blockquote><p>工业和信息化部信息通信管理局关于侵害用户权益行为的APP通报。   </p></blockquote><h4 id="Maskbook"><a href="#Maskbook" class="headerlink" title="Maskbook"></a><a href="https://mp.weixin.qq.com/s/ZQSy8JdFdoAPug2rJ7ZmJg" target="_blank" rel="noopener">Maskbook</a></h4><blockquote><p>【 Maskbook 给了我一个最直观的感受。这款产品以浏览器插件的形式，把 Facebook 网站变成了一个无法监视的大广场。你依然使用以前的身份账号在这个广场上玩耍 —— 认识新的人、发布自己的动态、交新的朋友 —— 但不同的是，你所发布的数据将被加密成一串串乱码，只有你指定的好友能解读出其中正确的含义。】</p></blockquote><h4 id="图表制作可以很简单-图表魔方-ChartCube"><a href="#图表制作可以很简单-图表魔方-ChartCube" class="headerlink" title="图表制作可以很简单 - 图表魔方 ChartCube"></a><a href="https://chartcube.alipay.com/" target="_blank" rel="noopener">图表制作可以很简单 - 图表魔方 ChartCube</a></h4><blockquote><p>ChartCube 针对快速图表制作的场景，只要有浏览器就可以使用。<br>无论你是谁，都可以用它。你可以完全不懂如何处理数据，你可以没听说过任何图表类库，你也不需要写一行代码。通过最直观的交互，谁都能制作出所需的图表。<br>利用 ChartCube 制作图表，过程非常简单。通常你需要三步：选择图表、配置图表、导出图表。</p></blockquote><h4 id="教育部关于同意某大学章程部分条款修改的批复"><a href="#教育部关于同意某大学章程部分条款修改的批复" class="headerlink" title="教育部关于同意某大学章程部分条款修改的批复"></a><a href="http://www.moe.gov.cn/srcsite/A02/zfs_gdxxzc/201912/t20191216_412276.html" target="_blank" rel="noopener">教育部关于同意某大学章程部分条款修改的批复</a></h4><blockquote><p>以上为教育部网站原文链接。</p></blockquote><h4 id="和“内存杀手”-Chrome-说再见-新版-Edge-即将发布"><a href="#和“内存杀手”-Chrome-说再见-新版-Edge-即将发布" class="headerlink" title="和“内存杀手” Chrome 说再见? 新版 Edge 即将发布"></a><a href="https://mp.weixin.qq.com/s/g9WlXAjw0gPWzjfw0cgGPA" target="_blank" rel="noopener">和“内存杀手” Chrome 说再见? 新版 Edge 即将发布</a></h4><blockquote><p>近日，有不少外媒表示，微软计划于 2020 年 1 月 15 日正式发布基于 Chromium 的 Edge 浏览器，该浏览器支持 Windows 10、Windows 7、Windows 8 和 macOS 等操作系统。同时，更有网友通过对 Edge Chromium Beta 实测后，称新版 Edge 比 Chrome 更好用，比 Firefox 的功能更完善.<br>微软还为 Edge 引入新的 logo 和图<br><img src="https://mmbiz.qpic.cn/mmbiz_gif/Pn4Sm0RsAujIolbibsroulrun7rebicTT0mfUoWsWyQYZJ8j6IGjhhd3aqx5SC9ibDVQ2wN4NvCZajCjf25p5b5Dg/640?wx_fmt=gif&wxfrom=5&wx_lazy=1" alt="logo"></p></blockquote><h4 id="文言文编程语言，可谓年度最骚语言"><a href="#文言文编程语言，可谓年度最骚语言" class="headerlink" title="文言文编程语言，可谓年度最骚语言"></a><a href="https://github.com/LingDong-/wenyan-lang" target="_blank" rel="noopener">文言文编程语言，可谓年度最骚语言</a></h4><blockquote><p>Github上一周左右斩获一万多星的项目。<br>这是一位卡内基梅隆大学（CMU）的大四学生开发。利用 NLP 的一些技术，将文言文程序语法转换到 JavaScript 或 Python 运行，并不是简单的将程序中的英文字符换成了中文。</p></blockquote><h4 id="浏览器安全"><a href="#浏览器安全" class="headerlink" title="浏览器安全"></a><a href="https://www.liugezhou.online/2019/12/16/No7.%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8/" target="_blank" rel="noopener">浏览器安全</a></h4><blockquote><p>前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。<br>本篇是这个专栏的第七章，也是最后一章：<a href="https://www.liugezhou.online/2019/12/16/No7.%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8/" target="_blank" rel="noopener">浏览器安全</a>。本章分为六讲。    </p><p>本章主要从Web页面安全、浏览器系统安全、浏览器网络安全三块内容展开。   </p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这里记录过去一周，我的一些小总结。&lt;br&gt; &lt;img src=&quot;http://img.liugezhou.online/weekly24.jpeg&quot; alt=&quot;weekly-24&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="每周分享" scheme="http://liugezhou.online/categories/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="每周分享" scheme="http://liugezhou.online/tags/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>No7.浏览器安全</title>
    <link href="http://liugezhou.online/2019/12/16/No7.%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AE%89%E5%85%A8/"/>
    <id>http://liugezhou.online/2019/12/16/No7.浏览器安全/</id>
    <published>2019-12-16T12:40:00.000Z</published>
    <updated>2020-01-10T06:19:10.483Z</updated>
    
    <content type="html"><![CDATA[<h6 id="前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。"><a href="#前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。" class="headerlink" title="前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。"></a>前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。</h6><h6 id="本篇是这个专栏的最后一章：《浏览器安全》。本章分为六节。"><a href="#本篇是这个专栏的最后一章：《浏览器安全》。本章分为六节。" class="headerlink" title="本篇是这个专栏的最后一章：《浏览器安全》。本章分为六节。"></a>本篇是这个专栏的最后一章：《浏览器安全》。本章分为六节。</h6><a id="more"></a><h4 id="32-同源策略：为什么XMLHttpRequest不能跨域请求资源？"><a href="#32-同源策略：为什么XMLHttpRequest不能跨域请求资源？" class="headerlink" title="32 | 同源策略：为什么XMLHttpRequest不能跨域请求资源？"></a>32 | 同源策略：为什么XMLHttpRequest不能跨域请求资源？</h4><blockquote><p>浏览器安全可以分为三大块–Web页面安全、浏览器网络安全、浏览器系统安全。<br>本节来分析页面中的安全策略。  </p><p>在没有安全保障的 Web 世界中，我们是没有隐私的，因此需要安全策略来保障我们的隐私和数据的安全。这就引出了页面中最基础、最核心的安全策略：<code>同源策略（Same-origin policy）</code>。</p></blockquote><h5 id="什么是同源策略"><a href="#什么是同源策略" class="headerlink" title="什么是同源策略"></a>什么是同源策略</h5><blockquote><p>如果两个 URL 的协议、域名和端口都相同，我们就称这两个 URL 同源.<br>浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。两个不同的源之间若想要相互访问资源或者操作 DOM，那么会有一套基础的安全策略的制约，我们把这称为同源策略。<br>具体来讲，同源策略主要表现在 DOM、Web 数据和网络这三个层面。  </p><ul><li>第一个：DOM层面。同源策略限制了来自不同源的 JavaScript 脚本对当前 DOM 对象读和写的操作。    </li><li>第二个：数据层面。同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。   </li><li>第三个，网络层面。同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。</li></ul></blockquote><h5 id="安全和便利性的权衡"><a href="#安全和便利性的权衡" class="headerlink" title="安全和便利性的权衡"></a>安全和便利性的权衡</h5><blockquote><p>浏览器出让了同源策略的一些安全性。    </p></blockquote><h6 id="1-页面中可以嵌入第三方资源"><a href="#1-页面中可以嵌入第三方资源" class="headerlink" title="1. 页面中可以嵌入第三方资源"></a>1. 页面中可以嵌入第三方资源</h6><blockquote><p>页面中可以嵌入第三方资源，但是却有可能嵌入的是恶意代码，恶意读取Cookie等数据，于是浏览器中引入了内容安全策略，称为CSP。<br>CSP 的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码。</p></blockquote><h6 id="2-跨域资源共享和跨文档消息机制"><a href="#2-跨域资源共享和跨文档消息机制" class="headerlink" title="2. 跨域资源共享和跨文档消息机制"></a>2. 跨域资源共享和跨文档消息机制</h6><blockquote><p>为了解决不同源的资源不能共享问题，引入了<code>跨域资源共享(CORS)</code>，使用该机制可以进行跨域访问控制，从而使跨域数据传输得以安全进行。<br>在介绍同源策略时，我们说明了如果两个页面不是同源的，则无法相互操纵 DOM。不过在实际应用中，经常需要两个不同源的 DOM 之间进行通信，于是浏览器中又引入了跨文档消息机制，可以通过 window.postMessage 的 JavaScript 接口来和不同源的 DOM 进行通信。    </p></blockquote><h4 id="33-跨站脚本攻击-XSS-为什么Cookie中有HttpOnly属性？"><a href="#33-跨站脚本攻击-XSS-为什么Cookie中有HttpOnly属性？" class="headerlink" title="33 | 跨站脚本攻击(XSS):为什么Cookie中有HttpOnly属性？"></a>33 | 跨站脚本攻击(XSS):为什么Cookie中有HttpOnly属性？</h4><blockquote><p>通过上一节我们知道：同源策略可以隔离各个站点之间的 DOM 交互、页面数据和网络通信，虽然严格的同源策略会带来更多的安全，但是也束缚了 Web。这就需要在安全和自由之间找到一个平衡点，所以我们默认页面中可以引用任意第三方资源，然后又引入 CSP 策略来加以限制；默认 XMLHttpRequest 和 Fetch 不能跨站请求资源，然后又通过 CORS 策略来支持其跨域。不过支持页面中的第三方资源引用和 CORS 也带来了很多安全问题，其中最典型的就是 XSS 攻击。  </p></blockquote><h5 id="什么是XSS攻击"><a href="#什么是XSS攻击" class="headerlink" title="什么是XSS攻击"></a>什么是XSS攻击</h5><blockquote><p>XSS 全称是 Cross Site Scripting，为了与“CSS”区分开来，故简称 XSS，翻译过来就是“跨站脚本”。XSS 攻击是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。<br>恶意脚本可以做哪些事情呢？    </p><ul><li>可以获取Cookie消息。    </li><li>可以监听用户行为。  </li><li>可以通过修改DOM伪造假的登录窗口，用来欺骗用户输入用户名和密码等信息。   </li><li>还可以在页面内生成浮窗广告。    </li></ul></blockquote><h5 id="恶意脚本是怎么注入的"><a href="#恶意脚本是怎么注入的" class="headerlink" title="恶意脚本是怎么注入的"></a>恶意脚本是怎么注入的</h5><blockquote><p>常见的注入方式有：存储型XSS攻击、反射型XSS攻击、基于DOM的XSS攻击。    </p></blockquote><h5 id="如何阻止XSS攻击"><a href="#如何阻止XSS攻击" class="headerlink" title="如何阻止XSS攻击"></a>如何阻止XSS攻击</h5><blockquote><ol><li>服务器对输入脚本进行过滤或转码。   </li><li>充分利用CSP。  </li><li>使用 HttpOnly 属性。   </li></ol></blockquote><h4 id="34-CSRF攻击：陌生链接不要点"><a href="#34-CSRF攻击：陌生链接不要点" class="headerlink" title="34 | CSRF攻击：陌生链接不要点"></a>34 | CSRF攻击：陌生链接不要点</h4><blockquote><p>在上一节中我们简单了解了 XSS 攻击，XSS 的攻击方式是黑客往用户的页面中注入恶意脚本，然后再通过恶意脚本将用户页面的数据上传到黑客的服务器上，最后黑客再利用这些数据进行一些恶意操作。XSS 攻击能够带来很大的破坏性，不过另外一种类型的攻击也不容忽视，它就是 CSRF 攻击。 </p></blockquote><h5 id="什么是CSRF攻击"><a href="#什么是CSRF攻击" class="headerlink" title="什么是CSRF攻击"></a>什么是CSRF攻击</h5><blockquote><p>CSRF 英文全称是 Cross-site request forgery，所以又称为“跨站请求伪造”，是指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。简单来讲，CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事。     </p><p>黑客有三种方式实施CSRF攻击：  </p><ul><li>自动发起Get请求。   </li><li>自动发起POST请求。  </li><li>引诱用户点击链接。  </li></ul><p>和 XSS 不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。</p></blockquote><h5 id="如何防止CSRF攻击"><a href="#如何防止CSRF攻击" class="headerlink" title="如何防止CSRF攻击"></a>如何防止CSRF攻击</h5><blockquote><p>发起 CSRF 攻击的三个必要条件：    </p><ul><li>第一个，目标站点一定要有 CSRF 漏洞；    </li><li>第二个，用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态；    </li><li>第三个，需要用户打开一个第三方站点，可以是黑客的站点，也可以是一些论坛。    </li></ul><p>要让服务器避免遭受到 CSRF 攻击，通常有以下几种途径:   </p><ol><li>充分利用好Cookie的SameSite属性。SameSite选项通常有Strict、Lax、None三个值。    </li></ol><ul><li>Strict最为严格，举个例子，黑客从他的网站去去访问你网站的资源，如果你的网站的某些Cookie设置了SamteSite = Strict，那么在黑客网站上的Cookie是不会发送到你的网站上的，只有你从你的站点去请求你站点的资源，才会带上这些Cookie。  </li><li>Lax相对宽松，在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。但如果在第三方站点中使用 Post 方法，或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。 </li><li>而如果使用 None 的话，在任何情况下都会发送 Cookie 数据。</li></ul><ol start="2"><li><p>验证请求的来源站点<br>服务器可以禁止来自第三方站点的请求。那么该怎么判断请求是否来自第三方站点呢？这里介绍的是HTTP请求头中的Referer和Origin属性。<br><code>Referer</code>是HTTP请求头中的一个字段，记录了该HTTP请求的来源地址,会包含具体的 URL 路径。<br>虽然可以通过 Referer 告诉服务器 HTTP 请求的来源，但是有一些场景是不适合将来源 URL 暴露给服务器的，因此浏览器提供给开发者一个选项，可以不用上传 Referer 值，具体可参考 Referrer Policy。<br>但在服务器端验证请求头中的 Referer 并不是太可靠，因此标准委员会又制定了 <code>Origin</code>属性，在一些重要的场合，比如通过 XMLHttpRequest、Fecth 发起跨站请求或者通过 Post 方法发送请求时，都会带上 Origin 属性.<br>Origin 属性只包含了域名信息，并没有包含具体的 URL 路径.   </p></li><li><p>CSRF Token<br>第一步，在浏览器向服务器发起请求时，服务器生成一个 CSRF Token。CSRF Token 其实就是服务器生成的字符串，然后将该字符串植入到返回的页面中。<br>第二步，在浏览器端如果要发起转账的请求，那么需要带上页面中的 CSRF Token，然后服务器会验证该 Token 是否合法。如果是从第三方站点发出的请求，那么将无法获取到 CSRF Token 的值，所以即使发出了请求，服务器也会因为 CSRF Token 不正确而拒绝请求。  </p></li></ol></blockquote><h4 id="35-安全沙箱：页面和系统之间的隔离墙"><a href="#35-安全沙箱：页面和系统之间的隔离墙" class="headerlink" title="35 | 安全沙箱：页面和系统之间的隔离墙"></a>35 | 安全沙箱：页面和系统之间的隔离墙</h4><h5 id="安全视角下的多进程架构"><a href="#安全视角下的多进程架构" class="headerlink" title="安全视角下的多进程架构"></a>安全视角下的多进程架构</h5><blockquote><p>我们通过学习第一节《宏观视角下的浏览器》，了解了浏览器的发展史以及架构的演变，这节是从操作系统安全的视角来看浏览器的多进程架构的。<br>浏览器是被划分为<code>浏览器内核</code>和<code>渲染内核</code>两个核心模块，其中浏览器内核是由网络进程、浏览器主进程和GPU主进程组成的。渲染内核就是渲染进程。这两个模块通过IPC来通信。<br>浏览器多进程架构的设计不单单是为了增加其稳定性，重要的一点也是因为从安全角度去考虑、设计的。   </p></blockquote><h5 id="安全沙箱"><a href="#安全沙箱" class="headerlink" title="安全沙箱"></a>安全沙箱</h5><blockquote><p>基于安全原因(主要是为防止危险资源获取系统权限)，在渲染进程和操作系统之间建了一道墙，即便渲染进程由于存在漏洞被黑客攻击，但由于这道墙，黑客就获取不到渲染进程之外的任何操作权限。将渲染进程和操作系统隔离的这道墙就是安全沙箱。<br>浏览器中的安全沙箱是利用操作系统提供的安全技术，让渲染进程在执行过程中无法访问或者修改操作系统中的数据，在渲染进程需要访问系统资源的时候，需要通过浏览器内核来实现，然后将访问的结果通过 IPC 转发给渲染进程。<br>安全沙箱最小的保护单位是进程。因为单进程浏览器需要频繁访问或者修改操作系统的数据，所以单进程浏览器是无法被安全沙箱保护的，而现代浏览器采用的多进程架构使得安全沙箱可以发挥作用。  </p></blockquote><h4 id="36-｜-HTTPS：让数据传输更安全"><a href="#36-｜-HTTPS：让数据传输更安全" class="headerlink" title="36 ｜ HTTPS：让数据传输更安全"></a>36 ｜ HTTPS：让数据传输更安全</h4><blockquote><p>浏览器安全主要分为三大块内容：页面安全、系统安全、网络完全，本节主要学习网络安全。</p><p>我们使用 HTTP 传输的内容很容易被中间人窃取、伪造和篡改，通常我们把这种攻击方式称为中间人攻击。<br>具体来讲，在将HTTP数据提交给TCP后，数据会经过用户电脑、WIFI路由器、运营商和目标服务器，在这中间的每个环节中，数据都有可能被窃取或篡改。</p></blockquote><h5 id="在HTTP协议栈中引入安全层"><a href="#在HTTP协议栈中引入安全层" class="headerlink" title="在HTTP协议栈中引入安全层"></a>在HTTP协议栈中引入安全层</h5><blockquote><p><img src="https://static001.geekbang.org/resource/image/9e/cf/9e99f797de30a15a11b0e4b4c8f810cf.png" alt="HTTP VS HTTPS"><br>安全层有两个主要的职责：对发起 HTTP 请求的数据进行加密操作和对接收到 HTTP 的内容进行解密操作.<br>我们知道了安全层最重要的就是加解密，那么接下来我们就利用这个安全层，一步一步实现一个从简单到复杂的 HTTPS 协议。  </p><h6 id="第一版-使用对称加密"><a href="#第一版-使用对称加密" class="headerlink" title="第一版:使用对称加密"></a>第一版:使用对称加密</h6><p>提到加密，最简单的方式是使用对称加密。所谓对称加密是指加密和解密都使用的是相同的密钥。<br>将对称加密加到安全层后，实现了第一版的对称加密，但是其中传输的client-random和server-client的过程都是明文，所以黑客其实也是可以拿到并篡改的，因此此数据依然可以破解。  </p><h6 id="第二版：使用非对称加密"><a href="#第二版：使用非对称加密" class="headerlink" title="第二版：使用非对称加密"></a>第二版：使用非对称加密</h6><p>含义：和对称加密只有一个密钥不同，非对称加密算法有 A、B 两把密钥，如果你用 A 密钥来加密，那么只能使用 B 密钥来解密；反过来，如果你要 B 密钥来加密，那么只能用 A 密钥来解密。</p><h6 id="第三版：对称加密和非对称加密搭配使用"><a href="#第三版：对称加密和非对称加密搭配使用" class="headerlink" title="第三版：对称加密和非对称加密搭配使用"></a>第三版：对称加密和非对称加密搭配使用</h6><p>最终选择了一个更加完美的方案，那就是在传输数据阶段依然使用对称加密，但是对称加密的密钥我们采用非对称加密来传输.   </p><h6 id="第四版：添加数字证书"><a href="#第四版：添加数字证书" class="headerlink" title="第四版：添加数字证书"></a>第四版：添加数字证书</h6><p>为了防止黑客通过DNS劫持将用户目标官网的IP地址进行更换，而需添加数字证书，该证书是服务器向浏览器证明“我”就是“我”。 </p></blockquote><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><blockquote><p>由于 HTTP 的明文传输特性，在传输过程中的每一个环节，数据都有可能被窃取或者篡改，这倒逼着我们需要引入加密机制。<br>于是我们在 HTTP 协议栈的 TCP 和 HTTP 层之间插入了一个安全层，负责数据的加密和解密操作。<br>我们使用对称加密实现了安全层，但是由于对称加密的密钥需要明文传输，所以我们又将对称加密改造成了非对称加密。<br>但是非对称加密效率低且不能加密服务器到浏览器端的数据，于是我们又继续改在安全层，采用对称加密的方式加密传输数据和非对称加密的方式来传输密钥，这样我们就解决传输效率和两端数据安全传输的问题。<br>采用这种方式虽然能保证数据的安全传输，但是依然没办法证明服务器是可靠的，于是又引入了数字证书，数字证书是由 CA 签名过的，所以浏览器能够验证该证书的可靠性。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot;&gt;&lt;a href=&quot;#前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot; class=&quot;headerlink&quot; title=&quot;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot;&gt;&lt;/a&gt;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&lt;/h6&gt;&lt;h6 id=&quot;本篇是这个专栏的最后一章：《浏览器安全》。本章分为六节。&quot;&gt;&lt;a href=&quot;#本篇是这个专栏的最后一章：《浏览器安全》。本章分为六节。&quot; class=&quot;headerlink&quot; title=&quot;本篇是这个专栏的最后一章：《浏览器安全》。本章分为六节。&quot;&gt;&lt;/a&gt;本篇是这个专栏的最后一章：《浏览器安全》。本章分为六节。&lt;/h6&gt;
    
    </summary>
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>每周总结第二十三期</title>
    <link href="http://liugezhou.online/2019/12/15/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89%E6%9C%9F/"/>
    <id>http://liugezhou.online/2019/12/15/每周总结第二十三期/</id>
    <published>2019-12-15T15:08:00.000Z</published>
    <updated>2019-12-16T03:01:55.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这里记录过去一周，我的一些小总结。<br> <img src="http://img.liugezhou.online/weekly23.jpeg" alt="weekly-23"></p></blockquote><a id="more"></a><h4 id="Feeling"><a href="#Feeling" class="headerlink" title="Feeling"></a>Feeling</h4><blockquote><p>周末去参加了两个群体聚会，本来是有很多的感受的，但是由于本性是善于遗忘，这篇周总结拖沓了一些，什么感受不感受的也都忘光了。  </p></blockquote><h4 id="普法-如果你被裁员，赔偿金是N、N-1、2N呢？"><a href="#普法-如果你被裁员，赔偿金是N、N-1、2N呢？" class="headerlink" title="普法 | 如果你被裁员，赔偿金是N、N+1、2N呢？"></a><a href="https://mp.weixin.qq.com/s/uFUhMlittAbNDcHWjLeZLA" target="_blank" rel="noopener">普法 | 如果你被裁员，赔偿金是N、N+1、2N呢？</a></h4><blockquote><p>最近几个大厂闹了不少事情，各家对裁员的赔偿金额不尽相同，导致很多朋友有所疑惑：到底裁员应该赔偿多少？又一波科普《劳动合同法》的。</p></blockquote><h4 id="二师兄法力无边–CPI破4"><a href="#二师兄法力无边–CPI破4" class="headerlink" title="二师兄法力无边–CPI破4"></a><a href="https://mp.weixin.qq.com/s/DIxLlp9cbrcKm47WQX6oyQ" target="_blank" rel="noopener">二师兄法力无边–CPI破4</a></h4><blockquote><p>据国家统计局发布的数据，11月份全国CPI（居民消费价格指数）同比上涨4.5%，连续9个月涨幅扩大.上一次CPI处在4%以上的高位，还是7年多前.那一轮通胀周期始于2010年下半年，直到2012年初才缓解.<br>猪肉是测算CPI的一篮子商品中权重最大的单品（约占2.5%），对CPI的拉动效果极为明显。</p></blockquote><h4 id="Chrome79发布"><a href="#Chrome79发布" class="headerlink" title="Chrome79发布"></a><a href="https://mp.weixin.qq.com/s/MEV6YhBUcpT82VryKsezgg" target="_blank" rel="noopener">Chrome79发布</a></h4><blockquote><p>Google 发布了适用于 Windows、Mac、Linux、Chrome OS、Android 和 iOS 用户的 Chrome 79。</p><p>Chrome 79 是 2019 年最后一次特性更新。自今年秋天初以来，Chrome 79 一直处在开发中，并于 10 月底进入 Beta 测试。Chrome 79 的更改主要面向开发人员，但安全浏览和内置密码检查工具方面也已有一些改进。</p></blockquote><h4 id="WebAssembly"><a href="#WebAssembly" class="headerlink" title="WebAssembly"></a><a href="https://mp.weixin.qq.com/s/XxdrxkU5ZZKX4kcqIIXIQw" target="_blank" rel="noopener">WebAssembly</a></h4><blockquote><p>2019年的12月5日，WebAssembly(简称WASM) ，被W3C推荐为正式标准，这是继html、css、javascript之后的第4门web语言，同时为Web带来一种支持代码在浏览器中运行的新语言.<br>通过即时编译或解析，WebAssembly引擎可以接近原生平台的速度执行代码编译。   </p><p>关于明年的前端发展趋势，该作者给出以下几点的预测:</p><ol><li>WebAssembly变得越来越普遍，得到了实际采用，并被用于产品中。        </li><li>GraphQL在新的创业公司和新项目上超过了REST，而老牌公司则向其迁移。      </li><li>TypeScript成为创业公司和新项目的默认选择。           </li><li>CSS-in-JS可能会成为默认的样式设置方法，而不是普通的CSS。     </li><li>Flutter可能会取代React Native成为构建跨平台移动应用的最佳方式。 </li></ol></blockquote><h4 id="themostdangerouswritingapp"><a href="#themostdangerouswritingapp" class="headerlink" title="themostdangerouswritingapp"></a><a href="https://github.com/maebert/themostdangerouswritingapp" target="_blank" rel="noopener">themostdangerouswritingapp</a></h4><blockquote><p>最危险的应用写作程序。<br>一旦你开始写作，那就不要停，必须时刻不停的打字。一旦停下（5秒倒计时），便立刻把先前写的所有内容删得一干二净。</p><p>体验地址：<a href="http://www.themostdangerouswritingapp.com" target="_blank" rel="noopener">http://www.themostdangerouswritingapp.com</a></p></blockquote><h4 id="Github或正式登录中国"><a href="#Github或正式登录中国" class="headerlink" title="Github或正式登录中国"></a>Github或正式登录中国</h4><blockquote><p>2019年12月10日，据英国《金融时报》报道， 全球最大程序员交友平台 GitHub <code>渴望</code>在中国开子公司。</p></blockquote><h4 id="力扣"><a href="#力扣" class="headerlink" title="力扣"></a><a href="https://leetcode-cn.com/" target="_blank" rel="noopener">力扣</a></h4><blockquote><p>力扣（LeetCode）上的题目已经有 1000+ 了。一目了然的题目分类力扣的题覆盖面极大，目前已有 1000+ 公开题目资源，涉及了许多算法与数据结构，有贪心，搜索，动态规划，链表，二叉树，哈希表等。<br>如果你是一名程序员，力扣一定要提前准备起来。</p></blockquote><h4 id="浏览器中的网络"><a href="#浏览器中的网络" class="headerlink" title="浏览器中的网络"></a><a href="https://www.liugezhou.online/2019/12/10/No6.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C/" target="_blank" rel="noopener">浏览器中的网络</a></h4><blockquote><p>前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。<br>本篇是这个专栏的第六章：<a href="https://www.liugezhou.online/2019/12/10/No6.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C/" target="_blank" rel="noopener">浏览器中的网络</a>。本章分为三讲。    </p><p>这三讲从浏览器的视角对HTTP的历史演进，进行了整体介绍，分别是即将完成使命的HTTP/1，正在我们走向的HTTP/2，以及未来的HTTP/3.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这里记录过去一周，我的一些小总结。&lt;br&gt; &lt;img src=&quot;http://img.liugezhou.online/weekly23.jpeg&quot; alt=&quot;weekly-23&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="每周分享" scheme="http://liugezhou.online/categories/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="每周分享" scheme="http://liugezhou.online/tags/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>No6.浏览器中的网络</title>
    <link href="http://liugezhou.online/2019/12/10/No6.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C/"/>
    <id>http://liugezhou.online/2019/12/10/No6.浏览器中的网络/</id>
    <published>2019-12-10T12:40:00.000Z</published>
    <updated>2020-01-10T06:18:51.438Z</updated>
    
    <content type="html"><![CDATA[<h6 id="谈及浏览器中的网络，就避不开-HTTP。我们知道-HTTP-是浏览器中最重要且使用最多的协议，是浏览器和服务器之间的通信语言，也是互联网的基石。而随着浏览器的发展，HTTP-为了能适应新的形式也在持续进化，学习-HTTP-的最佳途径就是了解其发展史，所以在接下来的三节文章中，从浏览器发展的视角来学习-HTTP-演进。这三节分别是即将完成使命的-HTTP-1、正在向我们走来的-HTTP-2，以及未来的-HTTP-3。"><a href="#谈及浏览器中的网络，就避不开-HTTP。我们知道-HTTP-是浏览器中最重要且使用最多的协议，是浏览器和服务器之间的通信语言，也是互联网的基石。而随着浏览器的发展，HTTP-为了能适应新的形式也在持续进化，学习-HTTP-的最佳途径就是了解其发展史，所以在接下来的三节文章中，从浏览器发展的视角来学习-HTTP-演进。这三节分别是即将完成使命的-HTTP-1、正在向我们走来的-HTTP-2，以及未来的-HTTP-3。" class="headerlink" title="谈及浏览器中的网络，就避不开 HTTP。我们知道 HTTP 是浏览器中最重要且使用最多的协议，是浏览器和服务器之间的通信语言，也是互联网的基石。而随着浏览器的发展，HTTP 为了能适应新的形式也在持续进化，学习 HTTP 的最佳途径就是了解其发展史，所以在接下来的三节文章中，从浏览器发展的视角来学习 HTTP 演进。这三节分别是即将完成使命的 HTTP/1、正在向我们走来的 HTTP/2，以及未来的 HTTP/3。"></a>谈及浏览器中的网络，就避不开 HTTP。我们知道 HTTP 是浏览器中最重要且使用最多的协议，是浏览器和服务器之间的通信语言，也是互联网的基石。而随着浏览器的发展，HTTP 为了能适应新的形式也在持续进化，学习 HTTP 的最佳途径就是了解其发展史，所以在接下来的三节文章中，从浏览器发展的视角来学习 HTTP 演进。这三节分别是即将完成使命的 HTTP/1、正在向我们走来的 HTTP/2，以及未来的 HTTP/3。</h6><a id="more"></a><h4 id="29-HTTP-1：HTTP性能优化"><a href="#29-HTTP-1：HTTP性能优化" class="headerlink" title="29 | HTTP/1：HTTP性能优化"></a>29 | HTTP/1：HTTP性能优化</h4><blockquote><p>本文主要介绍的是 HTTP/1.1，我们先来学习下 HTTP/1.1 的进化史，然后再介绍在进化过程中所遇到的各种瓶颈，以及对应的解决方法。 </p></blockquote><h5 id="超文本传输协议HTTP-0-9"><a href="#超文本传输协议HTTP-0-9" class="headerlink" title="超文本传输协议HTTP/0.9"></a>超文本传输协议HTTP/0.9</h5><blockquote><p>HTTP/0.9 是于 1991 年提出的，主要用于学术交流，需求很简单——用来在网络之间传递<code>HTML 超文本</code>的内容，所以被称为<code>超文本传输协议</code>。<br>HTTP/0.9 的实现有以下三个特点:    </p><ul><li>第一个是只有一个请求行，并没有 HTTP 请求头和请求体，因为只需要一个请求行就可以完整表达客户端的需求了。  </li><li>第二个是服务器也没有返回头信息，这是因为服务器端并不需要告诉客户端太多信息，只需要返回数据就可以了。    </li><li>第三个是返回的文件内容是以 ASCII 字符流来传输的，因为都是 HTML 格式的文件，所以使用 ASCII 字节码来传输是最合适的。  </li></ul></blockquote><h5 id="被浏览器推动的HTTP-1-0"><a href="#被浏览器推动的HTTP-1-0" class="headerlink" title="被浏览器推动的HTTP/1.0"></a>被浏览器推动的HTTP/1.0</h5><blockquote><p>变化是这个世界永恒不变的主旋律，1994 年底出现了拨号上网服务，同年网景又推出一款浏览器，从此万维网就不局限于学术交流了，而是进入了高速的发展阶段。<br>万维网的高速发展带来了很多新的需求，而 HTTP/0.9 已经不能适用新兴网络的发展，所以这时就需要一个新的协议来支撑新兴网络，这就是 HTTP/1.0 诞生的原因。</p></blockquote><blockquote><p>新兴网络带来了新的需求：首先在浏览器中展示的不单是 HTML 文件了，还包括了 JavaScript、CSS、图片、音频、视频等不同类型的文件。因此支持多种类型的文件下载是 HTTP/1.0 的一个核心诉求，而且文件格式不仅仅局限于 ASCII 编码，还有很多其他类型编码的文件。   </p></blockquote><blockquote><p>为了让客户端和服务器能更深入地交流，HTTP/1.0 引入了<code>请求头</code>和<code>响应头</code>，它们都是以为 Key-Value 形式保存的，在 HTTP 发送请求时，会带上请求头信息，服务器返回数据时，会先返回响应头信息。<br>HTTP/1.0 的方案是通过请求头和响应头来进行协商，在发起请求时候会通过 HTTP 请求头告诉服务器它期待服务器返回什么类型的文件、采取什么形式的压缩、提供什么语言的文件以及文件的具体编码。</p></blockquote><h5 id="缝缝补补的HTTP-1-1"><a href="#缝缝补补的HTTP-1-1" class="headerlink" title="缝缝补补的HTTP/1.1"></a>缝缝补补的HTTP/1.1</h5><blockquote><p>技术继续发展、需求不断迭代更新，HTTP/1.0也不能满足需求了，HTTP/1.1又在HTTP/1.0上继续更新：</p></blockquote><h6 id="改进持久连接"><a href="#改进持久连接" class="headerlink" title="改进持久连接"></a>改进持久连接</h6><blockquote><p>HTTP/1.1 中增加了持久连接的方法，它的特点是在一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持。<br>HTTP 的持久连接可以有效减少 TCP 建立连接和断开连接的次数，这样的好处是减少了服务器额外的负担，并提升整体 HTTP 的请求时长。<br>持久连接在 HTTP/1.1 中是默认开启的，所以你不需要专门为了持久连接去 HTTP 请求头设置信息，如果你不想要采用持久连接，可以在 HTTP 请求头中加上Connection: close。目前浏览器中对于同一个域名，默认允许同时建立 6 个 TCP 持久连接.  </p></blockquote><h6 id="不成熟的HTTP管线化"><a href="#不成熟的HTTP管线化" class="headerlink" title="不成熟的HTTP管线化"></a>不成熟的HTTP管线化</h6><blockquote><p>如果 TCP 通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后面的所有请求，这就是著名的队头阻塞的问题。<br>HTTP/1.1 中试图通过管线化的技术来解决队头阻塞的问题。HTTP/1.1 中的管线化是指将多个 HTTP 请求整批提交给服务器的技术，虽然可以整批发送请求，不过服务器依然需要根据请求顺序来回复浏览器的请求。<br>FireFox、Chrome 都做过管线化的试验，但是由于各种原因，它们最终都放弃了管线化技术. </p></blockquote><h6 id="提供虚拟主机的支持"><a href="#提供虚拟主机的支持" class="headerlink" title="提供虚拟主机的支持"></a>提供虚拟主机的支持</h6><blockquote><p>在 HTTP/1.0 中，每个域名绑定了一个唯一的 IP 地址，因此一个服务器只能支持一个域名。<br>但是随着虚拟主机技术的发展，需要实现在一台物理主机上绑定多个虚拟主机，每个虚拟主机都有自己的单独的域名，这些单独的域名都公用同一个 IP 地址。<br>因此，HTTP/1.1 的请求头中增加了 Host 字段，用来表示当前的域名地址，这样服务器就可以根据不同的 Host 值做不同的处理。</p></blockquote><h6 id="对动态生成的内容提供了完美的支持"><a href="#对动态生成的内容提供了完美的支持" class="headerlink" title="对动态生成的内容提供了完美的支持"></a>对动态生成的内容提供了完美的支持</h6><blockquote><p>在设计 HTTP/1.0 时，需要在响应头中设置完整的数据大小，如Content-Length: 901，这样浏览器就可以根据设置的数据大小来接收数据。<br>不过随着服务器端的技术发展，很多页面的内容都是动态生成的，因此在传输数据之前并不知道最终的数据大小，这就导致了浏览器不知道何时会接收完所有的文件数据。<br>HTTP/1.1 通过引入 Chunk transfer 机制来解决这个问题，服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。这样就提供了对动态内容的支持。</p></blockquote><h6 id="客户端Cookie、安全机制"><a href="#客户端Cookie、安全机制" class="headerlink" title="客户端Cookie、安全机制"></a>客户端Cookie、安全机制</h6><blockquote><p>除此之外，HTTP/1.1 还引入了客户端 Cookie 机制和安全机制。</p></blockquote><h4 id="30-｜-HTTP-2：如何提升网络速度？"><a href="#30-｜-HTTP-2：如何提升网络速度？" class="headerlink" title="30 ｜ HTTP/2：如何提升网络速度？"></a>30 ｜ HTTP/2：如何提升网络速度？</h4><blockquote><p>HTTP/1.1为网络效率做了大量的优化，最核心的三种方式为：    </p><ul><li>增加了持久连接。    </li><li>浏览器为每个域名最多同时支持6个TCP持久连接。    </li><li>使用CDN的实现域名分片机制。 </li></ul></blockquote><h5 id="HTTP-1-1的主要问题"><a href="#HTTP-1-1的主要问题" class="headerlink" title="HTTP/1.1的主要问题"></a>HTTP/1.1的主要问题</h5><blockquote><p>HTTP/1.1对带宽的利用率却并不理想，这也是 HTTP/1.1 的一个核心问题.<br>带宽是指每秒最大能发送或者接收的字节数。我们把每秒能发送的最大字节数称为上行带宽，每秒能够接收的最大字节数称为下行带宽。  </p></blockquote><blockquote><p>出现宽带利用率不理想的原因，主要为：  </p><ul><li>第一个原因，TCP的慢启动。   </li><li>第二个原因，同时开启了多条TCP连接，那么这些连接会竞争固定的宽带。   </li><li>第三个原因，HTTP/1.1队头阻塞的问题。</li></ul></blockquote><h5 id="HTTP-2的多路复用"><a href="#HTTP-2的多路复用" class="headerlink" title="HTTP/2的多路复用"></a>HTTP/2的多路复用</h5><blockquote><p>HTTP/2 的解决方案可以总结为：一个域名只使用一个 TCP 长连接和消除队头阻塞问题.<br>具体实现就是：通过引入二进制分帧层，实现 HTTP 的多路复用技术。</p></blockquote><h5 id="HTTP-2其他特性"><a href="#HTTP-2其他特性" class="headerlink" title="HTTP/2其他特性"></a>HTTP/2其他特性</h5><blockquote><ul><li>可以设置请求的优先级。  </li><li>服务器推送。    </li><li>头部压缩。  </li></ul></blockquote><blockquote><p>HTTP/2 协议规范于 2015 年 5 月正式发布，在那之后，该协议已在互联网和万维网上得到了广泛的实现和部署。从目前的情况来看，国内外一些排名靠前的站点基本都实现了 HTTP/2 的部署。使用 HTTP/2 能带来 20%～60% 的效率提升，至于 20% 还是 60% 要看优化的程度。总之，我们也应该与时俱进，放弃 HTTP/1.1 和其性能优化方法，去“拥抱”HTTP/2</p></blockquote><h4 id="31-HTTP-3-0-甩掉TCP、TLS的包袱，构建高效网络"><a href="#31-HTTP-3-0-甩掉TCP、TLS的包袱，构建高效网络" class="headerlink" title="31 | HTTP/3.0:甩掉TCP、TLS的包袱，构建高效网络"></a>31 | HTTP/3.0:甩掉TCP、TLS的包袱，构建高效网络</h4><blockquote><p>和通常一样，介绍 HTTP/3 之前，我们先来看看 HTTP/2 到底有什么缺陷。    </p></blockquote><h5 id="1-TCP的队头阻塞"><a href="#1-TCP的队头阻塞" class="headerlink" title="1.TCP的队头阻塞"></a>1.TCP的队头阻塞</h5><blockquote><p>在 TCP 传输过程中，由于单个数据包的丢失而造成的阻塞称为 TCP 上的队头阻塞。<br>有测试数据表明，当系统达到了 2% 的丢包率时，HTTP/1.1 的传输效率反而比 HTTP/2 表现得更好。 </p></blockquote><h5 id="2-TCP建立连接的延时"><a href="#2-TCP建立连接的延时" class="headerlink" title="2.TCP建立连接的延时"></a>2.TCP建立连接的延时</h5><blockquote><p>网络延迟又称为 RTT（Round Trip Time）。我们把从浏览器发送一个数据包到服务器，再从服务器返回数据包到浏览器的整个往返时间称为 RTT。RTT 是反映网络性能的一个重要指标。 </p></blockquote><h5 id="3-TCP协议僵化"><a href="#3-TCP协议僵化" class="headerlink" title="3.TCP协议僵化"></a>3.TCP协议僵化</h5><blockquote><p>虽然我们知道了TCP的队头阻塞和建立连接延时等缺点，但是通过改进TCP协议来解决这些问题非常困难，这里说的非常困难就是指TCP协议僵化。<br>TCP协议僵化体现在两个方面：第一个是中间设备的僵化；除中间设备的僵化外，操作系统也是导致TCP协议僵化的另外一个原因。    </p></blockquote><h5 id="QUIC协议"><a href="#QUIC协议" class="headerlink" title="QUIC协议"></a>QUIC协议</h5><blockquote><p>HTTP/3 选择了一个折衷的方法——UDP 协议，基于 UDP 实现了类似于 TCP 的多路数据流、传输可靠性等功能，我们把这套功能称为 QUIC 协议。<br>HTTP/3 中的 QUIC 协议集合了以下几点功能:</p></blockquote><blockquote><ul><li>实现了类似 TCP 的流量控制、传输可靠性的功能。虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。  </li><li>集成了 TLS 加密功能。   </li><li>实现了 HTTP/2 中的多路复用功能。  </li><li>实现了快速握手功能。    </li></ul></blockquote><h5 id="HTTP-3的挑战"><a href="#HTTP-3的挑战" class="headerlink" title="HTTP/3的挑战"></a>HTTP/3的挑战</h5><blockquote><p>通过上面的分析，我们相信在技术层面，HTTP/3 是个完美的协议。不过要将 HTTP/3 应用到实际环境中依然面临着诸多严峻的挑战，这些挑战主要来自于以下三个方面:  </p><ul><li>第一，从目前的情况来看，服务器和浏览器端都没有对 HTTP/3 提供比较完整的支持。Chrome 虽然在数年前就开始支持 Google 版本的 QUIC，但是这个版本的 QUIC 和官方的 QUIC 存在着非常大的差异。    </li><li>第二，部署 HTTP/3 也存在着非常大的问题。因为系统内核对 UDP 的优化远远没有达到 TCP 的优化程度，这也是阻碍 QUIC 的一个重要原因。  </li><li>第三，中间设备僵化的问题。这些设备对 UDP 的优化程度远远低于 TCP，据统计使用 QUIC 协议时，大约有 3%～7% 的丢包率。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;谈及浏览器中的网络，就避不开-HTTP。我们知道-HTTP-是浏览器中最重要且使用最多的协议，是浏览器和服务器之间的通信语言，也是互联网的基石。而随着浏览器的发展，HTTP-为了能适应新的形式也在持续进化，学习-HTTP-的最佳途径就是了解其发展史，所以在接下来的三节文章中，从浏览器发展的视角来学习-HTTP-演进。这三节分别是即将完成使命的-HTTP-1、正在向我们走来的-HTTP-2，以及未来的-HTTP-3。&quot;&gt;&lt;a href=&quot;#谈及浏览器中的网络，就避不开-HTTP。我们知道-HTTP-是浏览器中最重要且使用最多的协议，是浏览器和服务器之间的通信语言，也是互联网的基石。而随着浏览器的发展，HTTP-为了能适应新的形式也在持续进化，学习-HTTP-的最佳途径就是了解其发展史，所以在接下来的三节文章中，从浏览器发展的视角来学习-HTTP-演进。这三节分别是即将完成使命的-HTTP-1、正在向我们走来的-HTTP-2，以及未来的-HTTP-3。&quot; class=&quot;headerlink&quot; title=&quot;谈及浏览器中的网络，就避不开 HTTP。我们知道 HTTP 是浏览器中最重要且使用最多的协议，是浏览器和服务器之间的通信语言，也是互联网的基石。而随着浏览器的发展，HTTP 为了能适应新的形式也在持续进化，学习 HTTP 的最佳途径就是了解其发展史，所以在接下来的三节文章中，从浏览器发展的视角来学习 HTTP 演进。这三节分别是即将完成使命的 HTTP/1、正在向我们走来的 HTTP/2，以及未来的 HTTP/3。&quot;&gt;&lt;/a&gt;谈及浏览器中的网络，就避不开 HTTP。我们知道 HTTP 是浏览器中最重要且使用最多的协议，是浏览器和服务器之间的通信语言，也是互联网的基石。而随着浏览器的发展，HTTP 为了能适应新的形式也在持续进化，学习 HTTP 的最佳途径就是了解其发展史，所以在接下来的三节文章中，从浏览器发展的视角来学习 HTTP 演进。这三节分别是即将完成使命的 HTTP/1、正在向我们走来的 HTTP/2，以及未来的 HTTP/3。&lt;/h6&gt;
    
    </summary>
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>每周总结第二十二期</title>
    <link href="http://liugezhou.online/2019/12/07/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E6%9C%9F/"/>
    <id>http://liugezhou.online/2019/12/07/每周总结第二十二期/</id>
    <published>2019-12-07T14:08:00.000Z</published>
    <updated>2019-12-08T14:09:36.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这里记录过去一周，我的一些小总结。<br><img src="http://img.liugezhou.online/20191206weekly.jpeg" alt="weekly-22"></p></blockquote><a id="more"></a><h4 id="Feeling"><a href="#Feeling" class="headerlink" title="Feeling"></a>Feeling</h4><blockquote><p>推出一个新产品很难，组建一个能够持续推出新产品的团队更难。<br>我最引以为傲的产品，就是苹果公司和我在苹果公司建立的团队。<br><cite>史蒂夫·乔布斯</cite></p></blockquote><h4 id="消费者办手机号全面开启人脸比对"><a href="#消费者办手机号全面开启人脸比对" class="headerlink" title="消费者办手机号全面开启人脸比对"></a>消费者办手机号全面开启人脸比对</h4><blockquote><p>据工信部的相关规定，自12月1日起，电信企业需在实体渠道全面实施人像比对技术措施，人像比对一致方可办理入网手续。<br>这意味着，今后，中国所有注册新SIM卡的手机用户都必须接受面部识别扫描。同时，规定要求电信企业部署“人工智能和其他技术方法”以检查注册SIM卡的人员的身份。<br>今年以来，人脸识别技术在国内出现了一系列的负面新闻，比如曾红极一时的换脸软件——ZAO，还有一位大学教授起诉动物园违规采集面部信息的“中国人脸识别第一案”。这些事件背后，说明中国人脸识别行业缺乏统一标准，管理仍然比较混乱，对用户的隐私保护做得不到位。就像“办手机卡”这件事，已经有一些声音开始担心：电信运营商真的能保证我们的人脸数据不外泄吗,不会用于其他的某方面用途吗？</p></blockquote><h4 id="华为作过的恶"><a href="#华为作过的恶" class="headerlink" title="华为作过的恶"></a><a href="https://github.com/evil-huawei/evil-huawei" target="_blank" rel="noopener">华为作过的恶</a></h4><blockquote><p>Gitub上，本周star数凑凑上涨的一个项目：<br>项目介绍：「由于部分内容被控评和删帖，已经无法在中文互联网搜索到，所以本项目将收集华为作过的恶，记录这些不应该被遗忘的历史。」</p></blockquote><h4 id="一键抠图神器"><a href="#一键抠图神器" class="headerlink" title="一键抠图神器"></a><a href="http://www.picup.ai/#/" target="_blank" rel="noopener">一键抠图神器</a></h4><blockquote><p>识别图像中的人体轮廓，与背景进行分离.有人体抠图和物体抠图。   </p></blockquote><h4 id="沙拉查词"><a href="#沙拉查词" class="headerlink" title="沙拉查词"></a>沙拉查词</h4><blockquote><p>一款浏览器插件，推荐。<br><img src="https://user-gold-cdn.xitu.io/2019/10/21/16dec06bb7790bd3?imageView2/2/w/800/q/85" alt="查词"></p></blockquote><h4 id="Grid-代码生成器"><a href="#Grid-代码生成器" class="headerlink" title="Grid 代码生成器"></a><a href="https://cssgrid-generator.netlify.com/" target="_blank" rel="noopener">Grid 代码生成器</a></h4><blockquote><p>可视化地配置 Grid，你可以设置行与列的个数、指定每个格子的类、长宽占比、行间距与列间距大小等，再一键生成 Grid 的 CSS 代码.<br><img src="https://user-gold-cdn.xitu.io/2019/12/6/16eda0f218272486?imageView2/2/w/800/q/85" alt="演示"></p></blockquote><h4 id="GitHub中文排行榜"><a href="#GitHub中文排行榜" class="headerlink" title="GitHub中文排行榜"></a><a href="https://github.com/kon9chunkit/GitHub-Chinese-Top-Charts" target="_blank" rel="noopener">GitHub中文排行榜</a></h4><blockquote><p>GitHub中文排行榜，帮助你发现高分优秀中文项目、更高效地吸收国人的优秀经验成果；榜单每周更新一次.   </p></blockquote><h4 id="浏览器中的页面"><a href="#浏览器中的页面" class="headerlink" title="浏览器中的页面"></a><a href="https://www.liugezhou.online/2019/12/03/No5.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E9%A1%B5%E9%9D%A2/" target="_blank" rel="noopener">浏览器中的页面</a></h4><blockquote><p>前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。<br>本篇是这个专栏的第四章：<a href="https://www.liugezhou.online/2019/12/03/No5.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E9%A1%B5%E9%9D%A2/" target="_blank" rel="noopener">浏览器中的页面</a>。本章分为八讲。</p></blockquote><h4 id="HTTP请求中的Form-Data和Request-Payload的区别"><a href="#HTTP请求中的Form-Data和Request-Payload的区别" class="headerlink" title="HTTP请求中的Form Data和Request Payload的区别"></a>HTTP请求中的Form Data和Request Payload的区别</h4><blockquote><p>前端开发中经常会用到AJAX发送异步请求，对于POST类型的请求会附带请求数据。而常用的两种传参方式为：Form Data 和 Request Payload。    </p></blockquote><blockquote><p>方式一： Form Data形式<br>当POST请求的请求头里设置Content-Type: application/x-www-form-urlencoded(默认), 参数在请求体以标准的Form Data的形式提交，以&amp;符号拼接，参数格式为key=value&amp;key=value&amp;key=value…<br>方式二：Request Payload形式<br>如果使用AJAX原生POST请求,请求头里设置Content-Type:application/json，请求的参数会显示在Request Payload中，参数格式为JSON格式：{“key”:”value”,”key”:”value”…}，这种方式可读性会更好. 后端可以使用getRequestPayload方法来获取.<br><code>Form Data 和 Request Payload 区别</code><br>如果请求头里设置Content-Type: application/x-www-form-urlencoded，那么这个请求被认为是表单请求，参数出现在Form Data里，格式为key=value&amp;key=value&amp;key=value…<br>原生的AJAX请求头里设置Content-Type:application/json，或者使用默认的请求头Content-Type:text/plain;参数会显示在Request payload块里提交。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这里记录过去一周，我的一些小总结。&lt;br&gt;&lt;img src=&quot;http://img.liugezhou.online/20191206weekly.jpeg&quot; alt=&quot;weekly-22&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="每周分享" scheme="http://liugezhou.online/categories/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="每周分享" scheme="http://liugezhou.online/tags/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>No5.浏览器中的页面</title>
    <link href="http://liugezhou.online/2019/12/03/No5.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E9%A1%B5%E9%9D%A2/"/>
    <id>http://liugezhou.online/2019/12/03/No5.浏览器中的页面/</id>
    <published>2019-12-03T12:40:00.000Z</published>
    <updated>2020-01-10T06:18:12.196Z</updated>
    
    <content type="html"><![CDATA[<h6 id="前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。"><a href="#前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。" class="headerlink" title="前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。"></a>前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。</h6><h6 id="本篇是这个专栏的第五章：《No5-浏览器中的页面》。本章分为八节。"><a href="#本篇是这个专栏的第五章：《No5-浏览器中的页面》。本章分为八节。" class="headerlink" title="本篇是这个专栏的第五章：《No5.浏览器中的页面》。本章分为八节。"></a>本篇是这个专栏的第五章：《No5.浏览器中的页面》。本章分为八节。</h6><a id="more"></a><h4 id="21-｜-Chrome开发者工具：利用网络面板做性能分析"><a href="#21-｜-Chrome开发者工具：利用网络面板做性能分析" class="headerlink" title="21 ｜ Chrome开发者工具：利用网络面板做性能分析"></a>21 ｜ Chrome开发者工具：利用网络面板做性能分析</h4><blockquote><p>本节首先对开发者工具的各个模块进行了一个简单介绍，然后重点讲解的是NetWork面板。<br>网络面板包括：控制器、过滤器、抓图信息、时间线、详细列表和下载信息概要六个区域构成。    </p></blockquote><h5 id="1-控制器"><a href="#1-控制器" class="headerlink" title="1.控制器"></a>1.控制器</h5><blockquote><ul><li>“开始/暂停”抓包。   </li><li>全局搜索。    </li><li>Disable cache:禁止从Cache中加载资源。</li><li>Online按钮：模拟2G/3G 网络，模拟弱网环境。  </li></ul></blockquote><h5 id="2-过滤器"><a href="#2-过滤器" class="headerlink" title="2.过滤器"></a>2.过滤器</h5><blockquote><p>过滤功能。 </p></blockquote><h5 id="3-抓图信息"><a href="#3-抓图信息" class="headerlink" title="3.抓图信息"></a>3.抓图信息</h5><blockquote><p>抓图信息区域，可以用来分析用户等待页面加载时间内所看到的内容，分析用户实际的体验情况。  </p></blockquote><h5 id="4-时间线"><a href="#4-时间线" class="headerlink" title="4.时间线"></a>4.时间线</h5><blockquote><p>时间线，主要用来展示 HTTP、HTTPS、WebSocket 加载的状态和时间的一个关系，用于直观感受页面的加载过程。</p></blockquote><h5 id="5-详细列表"><a href="#5-详细列表" class="headerlink" title="5.详细列表"></a>5.详细列表</h5><blockquote><p>详细记录了每个资源从发起请求到完成请求这中间所有过程的状态，以及最终请求完成的数据信息.<br>Queuing：当浏览器发起一个请求的时候，会有很多原因导致该请求不能被立即执行，而是需要排队等待。<br>Stalled： 在发起连接之前，还有一些原因可能导致连接过程被推迟，这个推迟就表现在面板中的 Stalled 上。<br>Proxy Negotiation:若使用代理服务器，会增加一个此阶段。<br>Waiting (TTFB):通常也称为“第一字节时间”。 TTFB 是反映服务端响应速度的重要指标，对服务器来说，TTFB 时间越短，就说明服务器响应越快。<br>Content Download :这意味着从第一字节时间到接收到全部响应数据所用的时间。  </p></blockquote><h5 id="6-下载信息概要"><a href="#6-下载信息概要" class="headerlink" title="6.下载信息概要"></a>6.下载信息概要</h5><blockquote><p>重点关注 DOMContentLoaded和Load两个事件。 </p><ul><li>DOMContentLoaded:这个事件发生后，说明页面已经构建好DOM了，即DOM需要的HTML、JavaScript、CSS等文件已下载完成了。  </li><li>Load：说明浏览器已经加载了所有的资源(图像、样式等)。    </li></ul></blockquote><h4 id="22-DOM树：JavaScript是如何影响DOM树构建的？"><a href="#22-DOM树：JavaScript是如何影响DOM树构建的？" class="headerlink" title="22 | DOM树：JavaScript是如何影响DOM树构建的？"></a>22 | DOM树：JavaScript是如何影响DOM树构建的？</h4><h5 id="什么是DOM"><a href="#什么是DOM" class="headerlink" title="什么是DOM"></a>什么是DOM</h5><blockquote><p>DOM 是表述 HTML 的内部数据结构，它会将 Web 页面和 JavaScript 脚本连接起来，并过滤一些不安全的内容。   </p></blockquote><h5 id="DOM树如何生成"><a href="#DOM树如何生成" class="headerlink" title="DOM树如何生成"></a>DOM树如何生成</h5><blockquote><p>在渲染引擎内部，有一个叫 HTML 解析器（HTMLParser）的模块，它的职责就是负责将 HTML 字节流转换为 DOM 结构。<br>HTML解析器过程是：网络进程加载了多少数据，HTML解析器便解析多少数据。  </p></blockquote><h5 id="JavaScript是如何影响DOM生成的"><a href="#JavaScript是如何影响DOM生成的" class="headerlink" title="JavaScript是如何影响DOM生成的"></a>JavaScript是如何影响DOM生成的</h5><blockquote><ul><li>在两段 div 中间插入了一段 JavaScript 脚本：当HTML解析器解析到script标签的时候会暂停DOM解析，去执行这段JS脚本。 </li><li>在页面中引入 JavaScript文件：整个执行流程还是一样的，执行到 JavaScript 标签时，暂停整个 DOM 的解析，执行 JavaScript 代码，不过这里执行 JavaScript 时，需要先<code>下载这段 JavaScript 代码</code>。这里需要重点关注<code>下载环境</code>，因为 JavaScript 文件的下载过程会阻塞 DOM 解析(Chrome浏览器做的一个主要优化是预解析操作)。<br>另外也有一些相关的策略：比如使用 CDN 来加速 JavaScript 文件的加载，压缩 JavaScript 文件的体积。如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为<code>异步加载</code>，通过 <code>async</code>或<code>defer</code> 来标记代码.  </li></ul><ol><li>async:使用 async 标志的脚本文件一旦加载完成，会立即执行.    </li><li>defer:使用了 defer 标记的脚本文件，需要在 DOMContentLoaded 事件之前执行.</li></ol></blockquote><blockquote><p>通过上面的分析，我们知道了 JavaScript 会阻塞 DOM 生成，而样式文件又会阻塞 JavaScript 的执行，所以在实际的工程中需要重点关注 JavaScript 文件和样式表文件，使用不当会影响到页面性能的。</p></blockquote><h4 id="23-｜-渲染流水线：CSS如何影响首次加载时的白屏问题"><a href="#23-｜-渲染流水线：CSS如何影响首次加载时的白屏问题" class="headerlink" title="23 ｜ 渲染流水线：CSS如何影响首次加载时的白屏问题"></a>23 ｜ 渲染流水线：CSS如何影响首次加载时的白屏问题</h4><blockquote><p>CSS资源是页面中非常重要的一环，本节首先站在渲染流水线的视角来介绍CSS是如何工作的、然后通过CSS工作流程来分分析性能瓶颈、最后讨论如何减少首次加载时的白屏问题。 </p></blockquote><h5 id="渲染流水线视角下的CSS"><a href="#渲染流水线视角下的CSS" class="headerlink" title="渲染流水线视角下的CSS"></a>渲染流水线视角下的CSS</h5><blockquote><p>首先是发起页面请求，网络进程接收到返回的HTML数据，将其发送给渲染进程，渲染进程解析HTML数据并构建DOM。<br>需要特别注意下，请求 HTML 数据和构建 DOM 中间有一段空闲时间，这个空闲时间有可能成为页面渲染的瓶颈。   </p></blockquote><blockquote><p>前面提到一嘴：Chrome浏览器做的一个主要优化是预解析操作。<br>因此，Chrome开启这个预解析进程后，在遇到JavaScript或CSS文件后，会提前下载这些文件。<br>这里也有一个空闲时间需要注意一下，就是在 DOM 构建结束之后、css 文件还未下载完成的这段时间内，渲染流水线无事可做，因为下一步是合成布局树，而合成布局树需要 CSSOM 和 DOM，所以这里需要等待 CSS 加载结束并解析成 CSSOM。 </p></blockquote><blockquote><p>CSSOM的两个作用： </p><ul><li>提供给 JavaScript 操作样式表的能力. </li><li>为布局树的合成提供基础的样式信息。</li></ul></blockquote><h5 id="影响页面展示的因素以及优化策略"><a href="#影响页面展示的因素以及优化策略" class="headerlink" title="影响页面展示的因素以及优化策略"></a>影响页面展示的因素以及优化策略</h5><blockquote><p>从发起 URL 请求开始，到首次显示页面的内容，在视觉上经历的三个阶段:    </p><ol><li>等请求发出去之后，到提交数据阶段，这时页面展示出来的还是之前页面的内容。   </li><li>提交数据之后渲染进程会创建一个空白页面，我们通常把这段时间称为解析白屏，并等待 CSS 文件和 JavaScript 文件的加载完成，生成 CSSOM 和 DOM，然后合成布局树，最后还要经过一系列的步骤准备首次渲染.  </li><li>等首次渲染完成之后，就开始进入完整页面的生成阶段了，然后页面会一点点被绘制出来。   </li></ol></blockquote><blockquote><p>这里重点关注第二个阶段：<br>该阶段的主要任务包括了：解析 HTML、下载 CSS、下载 JavaScript、生成 CSSOM、执行 JavaScript、生成布局树、绘制页面一系列操作。<br>对应策略：</p><ul><li>通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。    </li><li>但并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。 </li><li>还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 sync 或者 defer。    </li><li>对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。 </li></ul></blockquote><h4 id="24-分层和合成机制：为什么CSS动画比JavaScript高效"><a href="#24-分层和合成机制：为什么CSS动画比JavaScript高效" class="headerlink" title="24 | 分层和合成机制：为什么CSS动画比JavaScript高效"></a>24 | 分层和合成机制：为什么CSS动画比JavaScript高效</h4><blockquote><p>在第五节的时候，我们知道DOM构建成功后还要经历布局、分层、绘制、合成、显示等阶段后才能显示出漂亮的页面。<br>这一节主要讲解的是渲染引擎的分层和合成机制，作者说分层和合成机制代表了浏览器最为先进的合成技术，请注意是<code>最为先进的</code>. </p></blockquote><h5 id="显示器是怎么显示图像的"><a href="#显示器是怎么显示图像的" class="headerlink" title="显示器是怎么显示图像的"></a>显示器是怎么显示图像的</h5><blockquote><p>每个显示器的固定刷新频率通常是60HZ，即每秒更新60张图片，更新的图片都来自显卡中一个叫前缓冲区的地方，，显示器所做的任务很简单，就是每秒固定读取 60 次前缓冲区中的图像，并将读取的图像显示到显示器上。<br>显卡的作用：显卡的职责就是合成新的图像，并将图像保存到后缓冲区中，一旦显卡把合成的图像写到后缓冲区，系统就会让后缓冲区和前缓冲区互换，这样就能保证显示器能读取到最新显卡合成的图像。  </p></blockquote><h5 id="帧-VS-帧率"><a href="#帧-VS-帧率" class="headerlink" title="帧 VS 帧率"></a>帧 VS 帧率</h5><blockquote><p>渲染流水线生成的每一张图片称为一帧，渲染流水线每秒更新了多少帧称为帧率。  </p></blockquote><h5 id="如何生成一帧图像"><a href="#如何生成一帧图像" class="headerlink" title="如何生成一帧图像"></a>如何生成一帧图像</h5><blockquote><p>生成一帧图像有三种方式：重排、重绘、合成。 这三种方式的渲染路径不同，通常渲染路径越长，生成图像花费的时间越久。<br>这里聚焦点在合成上 ，为了提升每帧的渲染效率，Chrome 引入了分层和合成的机制，Chrome的合成技术用三个词来概括：分层、分块、合成。</p></blockquote><h5 id="分层和合成"><a href="#分层和合成" class="headerlink" title="分层和合成"></a>分层和合成</h5><blockquote><p>你可以把一张网页想象成是由很多个图片叠加在一起的，每个图片就对应一个图层，将素材分解为多个图层的操作就称为分层。最后将这些图层合并到一起的操作就称为合成。<br>在Chrome渲染流水线中，分层体现在生成布局树之后，渲染引擎根据布局树的特点将其转化为层树，层树是渲染流水线后续流程的基础结构。<br>需要重点关注的是，合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的。这就是为什么经常主线程卡住了，但是 CSS 动画依然能执行的原因。</p></blockquote><h5 id="分块"><a href="#分块" class="headerlink" title="分块"></a>分块</h5><blockquote><p>如果说分层是从宏观上提升了渲染效率，那么分块则是从微观层面提升了渲染效率。<br>在首次合成图块的时候使用一个低分辨率的图片。</p></blockquote><h5 id="如何利用分层技术优化代码"><a href="#如何利用分层技术优化代码" class="headerlink" title="如何利用分层技术优化代码"></a>如何利用分层技术优化代码</h5><blockquote><p>在写 Web 应用的时候，你可能经常需要对某个元素做几何形状变换、透明度变换或者一些缩放操作，如果使用 JavaScript 来写这些效果，会牵涉到整个渲染流水线，所以 JavaScript 的绘制效率会非常低下.<br>这时你可以使用 will-change 来告诉渲染引擎你会对该元素做一些特效变换，CSS 代码如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.box &#123;</span><br><span class="line">    will-change: transform, opacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这段代码就是提前告诉渲染引擎 box 元素将要做几何变换和透明度变换操作，这时候渲染引擎会将该元素单独实现一帧，等这些变换发生时，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就大大提升了渲染的效率。这也是 CSS 动画比 JavaScript 动画高效的原因.   </p></blockquote><h4 id="25-｜-页面性能：如何系统地优化页面？"><a href="#25-｜-页面性能：如何系统地优化页面？" class="headerlink" title="25 ｜ 页面性能：如何系统地优化页面？"></a>25 ｜ 页面性能：如何系统地优化页面？</h4><blockquote><p>本节所谈论的页面优化，其实就是让页面更快的显示和响应。<br>通常一个页面有三个阶段：加载阶段、交互阶段和关闭阶段。    </p><ul><li>加载阶段，是指从发出请求到渲染出完整页面的过程，影响到这个阶段的主要因素有网络和 JavaScript 脚本。  </li><li>交互阶段，主要是从页面加载完成到用户交互的整合过程，影响到这个阶段的主要因素是 JavaScript 脚本。    </li><li>关闭阶段，主要是用户发出关闭指令后页面所做的一些清理操作。<br>这里我们需要重点关注加载阶段和交互阶段，因为影响到我们体验的因素主要都在这两个阶段.</li></ul></blockquote><h5 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h5><blockquote><p>并非所有的资源都会阻塞页面的首次绘制，比如图片、音频、视频等文件就不会阻塞页面的首次渲染。而JavaScript、首次请求的HTML资源文件、CSS文件是会阻塞首次渲染的。把这些能阻塞页面渲染的称为关键资源。基于关键资源，细化出三个影响页面首次渲染的核心因素：   </p><ul><li>第一个是关键资源个数。  </li><li>第二个是关键资源大小。  </li><li>第三个是请求关键资源需要多少个RTT(Round Trip Time).[通常1个HTTP的数据包在14KB左右，所以0.1M的页面需要拆分成8个包来传输，也就是说需要8个RTT]。   </li></ul></blockquote><blockquote><p>然后针对核心因素，考虑优化方案：总的优化原则就是减少关键资源个数、降低关键资源大小、降低关键资源的RTT次数。</p></blockquote><h5 id="交互阶段"><a href="#交互阶段" class="headerlink" title="交互阶段"></a>交互阶段</h5><blockquote><p>交互阶段的优化，一个大的原则就是让单个帧的生成速度变快。  </p><ol><li>减少JavaScript脚本执行时间。</li><li>避免强制同步布局。【所谓强制同步布局，是指JavaScript强制将计算样式和布局操作提前到当前的任务中。】 </li><li>避免布局抖动。 </li><li>合理利用CSS合成动画。  </li><li>避免频繁的垃圾回收。   </li></ol></blockquote><h4 id="26-｜-虚拟DOM：虚拟DOM和实际的DOM有何不同？"><a href="#26-｜-虚拟DOM：虚拟DOM和实际的DOM有何不同？" class="headerlink" title="26 ｜ 虚拟DOM：虚拟DOM和实际的DOM有何不同？"></a>26 ｜ 虚拟DOM：虚拟DOM和实际的DOM有何不同？</h4><blockquote><p>本节先聊一些DOM的缺陷，然后在此基础上介绍虚拟DOM如何解决这些缺陷，最后站在双缓存和MVC的视角来聊聊虚拟DOM。</p></blockquote><h5 id="DOM的缺陷"><a href="#DOM的缺陷" class="headerlink" title="DOM的缺陷"></a>DOM的缺陷</h5><blockquote><p>通过前面对DOM的学习，我们知道对于一些复杂的页面或者目前使用非常多的单页面应用来说，其DOM结构复杂，每次操作需要去不断修改DOM树，每次操作渲染引擎都需要进行重绘、重排或者合成操作，执行一次重排或者重绘操作是非常耗时的，这样就带来了性能问题。<br>所以就需要一直方式来减少JavaScript对DOM的操作，这时候虚拟DOM就上场了。    </p></blockquote><h5 id="什么是虚拟DOM"><a href="#什么是虚拟DOM" class="headerlink" title="什么是虚拟DOM"></a>什么是虚拟DOM</h5><blockquote><p>虚拟DOM要解决的事情：  </p><ul><li>将页面改变的内容应用到虚拟DOM上，而不是直接应用在DOM上。  </li><li>变化被应用到虚拟DOM上时，虚拟DOM并不急着去渲染页面，而仅仅是调整虚拟DOM的内部状态，这样操作虚拟DOM的代价就变得非常轻了。    </li><li>在虚拟DOM收集到足够的改变时，再把这些变化一次性应用到真实的DOM上。  </li></ul></blockquote><blockquote><p>接下来从双缓存和MVC模型这两个视角来聊聊虚拟DOM：  </p><ul><li><ol><li>双缓存<br>双换粗是一种经典的思路，应用哎很多场合，能解决页面无效刷新和闪屏的问题，虚拟DOM就是双缓存思想的一种实现。<br>使用双缓存，可以先将计算的中间结果存放到另一个缓冲区中，等全部的计算结束，该缓冲区已经存储了完整的图形，这样使得整个图像的输出非常稳定。  </li></ol></li></ul><ol start="2"><li>MVC模式<br>基于MVC的设计思想广泛地渗透到各种场合，且基于MVC又衍生出了很多其他模式(如MVP、MVVM)，不过万变不离其宗，它们的基础框架都是基于MVC而来。站在MVC视角来理解虚拟DOM能让你看到更为“广阔的世界”. </li></ol></blockquote><h4 id="27-渐进式网页应用-PWA-它究竟解决了Web应用的哪些问题？"><a href="#27-渐进式网页应用-PWA-它究竟解决了Web应用的哪些问题？" class="headerlink" title="27 | 渐进式网页应用(PWA):它究竟解决了Web应用的哪些问题？"></a>27 | 渐进式网页应用(PWA):它究竟解决了Web应用的哪些问题？</h4><blockquote><p>PWA,全称是Progressive Web App，渐进式网页应用。   </p></blockquote><blockquote><p>渐进式：</p><ul><li>站在Web应用开发者来说，PWA提供了一个渐进式的过度方案，让普通站点逐步过度到Web应用。采取渐进式可以降低站点改造的代价，使得站点逐步支持各项新技术，而不是一步到位。   </li><li>站在技术角度来说，PWA技术也是一个渐进式的演化过程，在技术层面会一点点演进，比如逐渐提供更好的设备特性支持，不断优化更加流畅的动画效果，不断让页面的加载速度变得更快，不断实现本地应用的特性。<br>可以这么理解：PWA是一套理念，渐进式增强Web的优势，并通过技术手段渐进式缩短和本地应用或者小程序的距离。</li></ul></blockquote><h5 id="Web应用-VS-本地应用"><a href="#Web应用-VS-本地应用" class="headerlink" title="Web应用 VS 本地应用"></a>Web应用 VS 本地应用</h5><blockquote><p>相较于本地应用，Web应用缺陷：   </p><ul><li>首先，Web应用缺少离线使用能力，在离线或者弱网环境下基本上是无法使用的。 </li><li>其次，Web应用还缺少了消息推送的能力。   </li><li>最后，Web缺少一级入口。</li></ul></blockquote><blockquote><p>针对以上缺陷，PWA提出了两种解决方案：通过引入Service Worker来试着解决离线存储和消息推送的问题，通过引入manifest.json来解决一级入口的问题。</p></blockquote><h5 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h5><blockquote><p>在2014年的时候，标准委员会就提出来Service Worker的概念，主要思想是在页面和网络之间增加一个拦截器，主要功能就是用来缓存资源和拦截请求。</p></blockquote><blockquote><p>设计思路：<br>为避免JavaScript过多占用页面主线程时长的情况，浏览器实现了Web Worker的功能。Web Worker的目的是让JavaScript能够运行在页面主线程之外，且只能执行一些与DOM无关的JS脚本。在Chrome中，Web Worker其实就是在渲染进程中开启一个新线程，它的生命周期和页面关联。<br>“让其运行在主线程之外”就是Service Worker来自Web Worker的一个核心思想。但需要在Web Worker的基础上加上储存功能。且Service Worker还需要会为多个页面提供服务，所以还不能把Service Worker和单个页面绑定起来。<br>消息推送也是基于Service Worker来实现的。<br>最后，若要使站点支持Service Worker，首先必要的一步就是要将站点升级到HTTPS。</p></blockquote><h4 id="28-｜-WebComponent：像搭积木一样构建Web应用"><a href="#28-｜-WebComponent：像搭积木一样构建Web应用" class="headerlink" title="28 ｜ WebComponent：像搭积木一样构建Web应用"></a>28 ｜ WebComponent：像搭积木一样构建Web应用</h4><blockquote><p>首先，本节介绍了组件化开发是程序员的刚需，所谓组件化就是功能模块要实现高内聚、低耦合的特性。<br>不过由于 DOM 和 CSSOM 都是全局的，所以它们是影响了前端组件化的主要元素。<br>基于这个原因，就出现 WebComponent，它包含自定义元素、影子 DOM 和 HTML 模板三种技术，使得开发者可以隔离 CSS 和 DOM。<br>在此基础上，还重点介绍了影子 DOM 到底是怎么实现的。<br>关于 WebComponent 的未来如何，这里我们不好预测和评判，但是有一点可以肯定，WebComponent 也会采用渐进式迭代的方式向前推进，未来依然有很多坑需要去填。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot;&gt;&lt;a href=&quot;#前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot; class=&quot;headerlink&quot; title=&quot;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot;&gt;&lt;/a&gt;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&lt;/h6&gt;&lt;h6 id=&quot;本篇是这个专栏的第五章：《No5-浏览器中的页面》。本章分为八节。&quot;&gt;&lt;a href=&quot;#本篇是这个专栏的第五章：《No5-浏览器中的页面》。本章分为八节。&quot; class=&quot;headerlink&quot; title=&quot;本篇是这个专栏的第五章：《No5.浏览器中的页面》。本章分为八节。&quot;&gt;&lt;/a&gt;本篇是这个专栏的第五章：《No5.浏览器中的页面》。本章分为八节。&lt;/h6&gt;
    
    </summary>
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>每周总结第二十一期</title>
    <link href="http://liugezhou.online/2019/11/30/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E6%9C%9F/"/>
    <id>http://liugezhou.online/2019/11/30/每周总结第二十一期/</id>
    <published>2019-11-30T14:08:00.000Z</published>
    <updated>2019-11-30T14:24:35.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这里记录过去一周，我的一些小总结。<br> <img src="http://img.liugezhou.online/20191130No21week.jpeg" alt="weekly-21"></p></blockquote><a id="more"></a><h4 id="Feeling"><a href="#Feeling" class="headerlink" title="Feeling"></a>Feeling</h4><blockquote><p>No Feeling。</p></blockquote><h4 id="携号转网"><a href="#携号转网" class="headerlink" title="携号转网"></a>携号转网</h4><blockquote><p>工信部11月27日(周三)召开携号转网启动仪式，27日起，携号转网正式在全国提供服务。用户号码保持不变，符合条件可自由选择移动、联通、电信等运营商。电信业务经营者不得干涉用户自主选择。</p><p>网上数据：<br>“携号转网”服务正式在全国范围内拓展。此前，天津、海南等五个前期试验省(市)已于9月19日正式提供服务。据工信部数据，截至11月26日，上述五个试验省份完成携号转网用户316万，从前期数据来看，携号转网的人员不到整体的2%。中国电信、中国移动、中国联通转出的用户数占全部转出用户的比例分别是16.3%、57.6%和26.1%，转入的占比是49.3%、28.1%和22.6%。（21世纪经济报道）    </p><p>这次携号转网终于可以让移动这种巨无霸企业有些许收敛。终于让一直存在的最低消费、营业点办理、流量瞎收费等等问题有了一些的缓和。<br>多年来我一直有个心愿，就是将我这半死不活还在用的移动号能有一个最低消费，多次客服无果。在这次浩浩荡荡的携号转网行动中，一个人工电话完成了我的心愿，甚感欣慰。</p></blockquote><h4 id="网易裁员的5点思考"><a href="#网易裁员的5点思考" class="headerlink" title="网易裁员的5点思考"></a><a href="https://mp.weixin.qq.com/s/_qFUhwAZwxJaiPD-EBtDVw" target="_blank" rel="noopener">网易裁员的5点思考</a></h4><blockquote><p>网易裁员、华为前员工被公司起诉敲诈(知乎已删除此相关话题回答)等事件让企业与员工关系推到了一个热度，其实大家心知肚明，这些事情在短期内虽然得到关注，但是这样的事件长期依然不会停止。<br>不管如何，对于职场人来说要做的、可控的首先是关注且做好自己的本职工作，其次当然要了解一些相关法律知识以保障自己权益。这篇文章作者针对此次事件总结了一些《劳动合同法》的基本知识。<br><a href="https://mp.weixin.qq.com/s/_qFUhwAZwxJaiPD-EBtDVw" target="_blank" rel="noopener">网易裁员事件引发的 5 点重要思考</a></p></blockquote><h4 id="欧洲IPv4地址用光"><a href="#欧洲IPv4地址用光" class="headerlink" title="欧洲IPv4地址用光"></a>欧洲IPv4地址用光</h4><blockquote><p>2019年11月25日(周一），欧洲 IP 地址注册机构 RIPE 宣布，欧洲的 IPv4 地址全部分配光了，一个也没剩下，从此没有新的 IP 地址可以分配。</p></blockquote><blockquote><ul><li>IP地址是分配给每个联网设备的一系列号码，每个IP地址都是独一无二的。IPv4地址用光大体意味着2^32-1个联网设备地址分配完了。  </li><li>当全球IPv4地址耗尽的这一刻，IPv6早就已经进入了我们的生活,在很多APP开屏的界面，会标注已经支持IPv6技术。  </li><li>IPv4地址长度是32，支持的物理地址是2^32-1个地址；IPv6地址的长度是128，支持的物理地址是2^128-1个地址。能够对地球上每平方米提供6×1023个网络地址，在可预见的将来是不会耗尽的。 </li><li>IPv4的回路地址为: 127.0.0.1，IPv6的回路地址为 : 000:0000:0000:0000:0000:0000:0000:0001 可以简写为 ::1。 </li><li>全球IPv4地址耗尽对普通用户影响不大，更多是网络技术、运营商，以及互联网应用开发者的事情.     </li></ul></blockquote><h4 id="OffScreen"><a href="#OffScreen" class="headerlink" title="OffScreen"></a>OffScreen</h4><blockquote><p>App store上的一款时间管理软件，它是系统“屏幕使用时间”的最佳伴侣，可以记录更多的信息，还可以提醒你，比如，OffScreen 会在你每次点亮屏幕的时候，用通知提醒，这是今天第几次拿起手机，以及平均查看时长，熬夜提醒，边走边看提醒，等等，帮助你戒除一些错误的生活习惯，如果你觉得有必要管理你的手机使用时长，这款软件可以很轻松的帮助你。</p></blockquote><h4 id="免费版权图片一键搜索"><a href="#免费版权图片一键搜索" class="headerlink" title="免费版权图片一键搜索!"></a><a href="https://www.logosc.cn/so/" target="_blank" rel="noopener">免费版权图片一键搜索!</a></h4><blockquote><p>一键搜索多家免版权图库，可以使用现有模板或者上传模板素材设计图片。    </p></blockquote><h4 id="再次安利vconsole"><a href="#再次安利vconsole" class="headerlink" title="再次安利vconsole"></a>再次安利vconsole</h4><blockquote><p>在开发手机网页应用，在手机真机调试过程中，如果想有类似小程序自带的调试工具，那么可以在你的网页中使用次插件：vconsole。<br>Github仓库搜索：vonsole，对照引入即可快速简单部署。</p></blockquote><h4 id="VSCode插件–import"><a href="#VSCode插件–import" class="headerlink" title="VSCode插件–import"></a>VSCode插件–import</h4><blockquote><p>作用：当你写了一个导入语句时，它会提醒你这个包的大小，如果你发现某个包太大时，就需要考虑一下你是否真的需要引入整个包。效果实例：<br><img src="http://img.liugezhou.online/20191130importcost.png" alt="import"></p></blockquote><h4 id="CSS-Grid网格布局教程"><a href="#CSS-Grid网格布局教程" class="headerlink" title="CSS Grid网格布局教程"></a><a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html" target="_blank" rel="noopener">CSS Grid网格布局教程</a></h4><blockquote><p>前端非常重要的两大布局分别是：Flex弹性布局和Grid网格布局。<br>Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是一维布局。<br>Grid 布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可以看作是二维布局。<br>Grid 布局远比 Flex 布局强大。<br><img src="https://www.wangbase.com/blogimg/asset/201903/1_bg2019032501.png" alt="Grid"></p></blockquote><h4 id="前端模块化"><a href="#前端模块化" class="headerlink" title="前端模块化"></a><a href="https://www.liugezhou.online/2019/11/27/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/" target="_blank" rel="noopener">前端模块化</a></h4><blockquote><p>最近项目在调试微信支付的前端SDK引入的时候，官网文档有一句：“JSSDk的引入，支持使用 AMD/CMD 标准模块加载方法加载”。<br>对CommonJS、AMD、CMD、ES6Module等概念与代码实例的理解甚是混淆，于是查阅资料、总结<a href="https://www.liugezhou.online/2019/11/27/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/" target="_blank" rel="noopener">此文</a>。</p></blockquote><h4 id="nginx简单的几个命令"><a href="#nginx简单的几个命令" class="headerlink" title="nginx简单的几个命令"></a>nginx简单的几个命令</h4><blockquote><ul><li>服务端安装nginx：<code>yum install nginx</code>，通过yum安装的程序默认在etc目录下。  </li><li>查看nginx安装路径：<code>which nginx</code>或者<code>whereis nginx</code>.    </li><li>nginx启动：<code>service start nginx</code>,nginx停止：<code>service stop nginx</code>.   </li><li>查看nginx的运行状况：<code>ps -ef | grep nginx</code>. </li><li>nginx的配置主要查看<code>conf</code>文件，包括一些包含配置、域名解析、文件路径、监听端口、转发端口等。    </li></ul></blockquote><h4 id="浏览器中的页面循环系统"><a href="#浏览器中的页面循环系统" class="headerlink" title="浏览器中的页面循环系统"></a><a href="https://www.liugezhou.online/2019/11/25/No4.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E9%A1%B5%E9%9D%A2%E5%BE%AA%E7%8E%AF%E7%B3%BB%E7%BB%9F/" target="_blank" rel="noopener">浏览器中的页面循环系统</a></h4><blockquote><p>前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。<br>本篇是这个专栏的第四章：<a href="https://www.liugezhou.online/2019/11/25/No4.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E9%A1%B5%E9%9D%A2%E5%BE%AA%E7%8E%AF%E7%B3%BB%E7%BB%9F/" target="_blank" rel="noopener">浏览器中的页面循环系统</a>。本章分为六讲。   </p></blockquote><blockquote><p><a href="https://liugezhou.gitbook.io/liugezhou/hong-guan-shi-jiao-xia-de-liu-lan-qi/no4.-liu-lan-qi-zhong-de-ye-mian-xun-huan-xi-tong" target="_blank" rel="noopener">Gitbook在线阅读</a></p></blockquote><blockquote><ul><li>本章通过分析线程处理任务的不同方式介绍了事件循环系统、消息队列以及IPC等知识引出微任务的作用。</li><li>介绍了setTimeout和XMLHttpRequest两个WebAPI的实现方式. </li><li>由浅入深讲解微任务：包括微任务的实现原理以及微任务的应用：Promise。   </li><li>最后讲解了比Promise更容易阅读的async/await的原理及用法。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这里记录过去一周，我的一些小总结。&lt;br&gt; &lt;img src=&quot;http://img.liugezhou.online/20191130No21week.jpeg&quot; alt=&quot;weekly-21&quot;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="每周分享" scheme="http://liugezhou.online/categories/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="每周分享" scheme="http://liugezhou.online/tags/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>前端模块化</title>
    <link href="http://liugezhou.online/2019/11/27/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>http://liugezhou.online/2019/11/27/前端模块化/</id>
    <published>2019-11-27T12:00:00.000Z</published>
    <updated>2020-01-10T06:24:49.959Z</updated>
    
    <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><blockquote><p>最近在梳理前端的公众号支付流程，从前端流程微信JSSDK的引入开始查阅文档。<br>在引入JS文件一小段中，文档中备注：“支持使用 AMD/CMD 标准模块加载方法加载”。<br>于是，想到对CommonJS、AMD、CMD、ES6Module等概念与代码实例的理解甚是混淆，于是学习、总结此文。  </p></blockquote><a id="more"></a><h4 id="前端模块化"><a href="#前端模块化" class="headerlink" title="前端模块化"></a>前端模块化</h4><blockquote><p>2009年，美国程序员Ryan Dahl创造了node.js项目，将javascript语言用于服务器端编程。这标志”Javascript模块化编程”正式诞生。<br>因为老实说，在浏览器环境下，没有模块也不是特别大的问题，毕竟网页程序的复杂性有限；但是在服务器端，一定要有模块，与操作系统和其他应用程序互动，否则根本没法编程。NodeJS是CommonJS规范的实现，webpack 也是以CommonJS的形式来书写。</p></blockquote><blockquote><p>为了提高代码的复用率，方便代码进行管理，我也不知先后(应该CommonJS最早吧)的出现了一系列的模块化的规范：CommonJS、AMD、CMD以及（ES6Module）。</p></blockquote><blockquote><p>通常来讲：一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。</p></blockquote><blockquote><p>这三个规范都是为javascript模块化加载而生的，都是在用到或者预计要用到某些模块时候加载该模块，使得大量的系统巨大的庞杂的代码得以很好的组织和管理。模块化使得我们在使用和管理代码的时候不那么混乱，而且也方便了多人的合作。</p></blockquote><h4 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h4><blockquote><ul><li>CommonJS是一个更偏向于服务端的规范。Node.js就是CommonJS规范的主要实践者。 </li><li>CommonJS不适用浏览器是因为：此规范是同步加载模块，对于服务器端来说，所有的模块都是在本地磁盘，等待模块时间就是硬盘读取文件时间，很小，但对浏览器而言，设计到网速、代理更原因，同步加载会造成阻塞，浏览器处于“假死”状态，所以浏览器端出现了AMD规范。</li></ul></blockquote><blockquote><p>代码实现拓展：<a href="http://javascript.ruanyifeng.com/nodejs/module.html" target="_blank" rel="noopener">CommonJS规范</a></p></blockquote><h4 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h4><blockquote><ul><li>AMD是<code>Asynchronous Module Definition</code>的缩写，即“异步模块定义”，它采用异步方式加载模块(模块的加载不影响它后面语句的运行),且会提前加载。</li><li>AMD同CommonJS一样也是使用require加载模块，但不同的是，AMD要求两个参数：require([module],callback).  </li></ul></blockquote><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> // 定义一个模块--math.js</span><br><span class="line">    define(function() &#123;</span><br><span class="line">    var add = function(x, y) &#123;</span><br><span class="line">        return x + y;</span><br><span class="line">    &#125;</span><br><span class="line">    return  &#123;</span><br><span class="line">        add: add</span><br><span class="line">    &#125;</span><br><span class="line">//加载方法如下</span><br><span class="line">require([&apos;math&apos;], function(math) &#123;</span><br><span class="line">  alert(math.add(1, 1));</span><br><span class="line">&#125;)</span><br><span class="line">//如果math模块还依赖其他模块，写法如下：</span><br><span class="line">define([&apos;dependenceModule&apos;], function(dependenceModule) &#123;</span><br><span class="line">    // todo</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><ul><li>当require()函数加载math模块的时候，就会先加载dependenceModule模块。当有多个依赖时，就将所有的依赖都写在define()函数第一个参数数组中，所以说AMD是依赖前置的。这不同于CMD规范，它是依赖就近的。</li></ul></blockquote><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><blockquote><p>CMD与AMD最大的不同就是：CMD推崇依赖就近，延迟执行。可以在代码的任意一行写入依赖：<br><code>define(factory)</code><br>当factory为函数时，表示是模块的构造方法。<br>执行该构造方法，可以得到模块向外提供的接口。<br>factory 方法在执行时，默认会传入三个参数：require、exports 和 module.</p></blockquote><blockquote><p>AMD与CMD代码对比：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// CMD</span><br><span class="line">   define(function(require, exports, module) &#123;</span><br><span class="line">   var a = require(&apos;./a&apos;);</span><br><span class="line">   a.doSomething();</span><br><span class="line">   var b = require(&apos;./b&apos;);</span><br><span class="line">   b.doSomething();</span><br><span class="line">   &#125;)</span><br><span class="line">   // AMDdefine([&apos;a&apos;, &apos;b&apos;], function(a, b) &#123;</span><br><span class="line">   a.doSomething();</span><br><span class="line">   b.doSomething();</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure><h4 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h4><blockquote><p>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，旨在成为浏览器和服务器通用的模块解决方案。其模块功能主要由两个命令构成：export和import.<br>export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。<br>ES6还提供了export default命令，为模块指定默认输出，对应的import语句不需要使用大括号.</p></blockquote><h4 id="ES6模块与CommonJS模块差异"><a href="#ES6模块与CommonJS模块差异" class="headerlink" title="ES6模块与CommonJS模块差异"></a>ES6模块与CommonJS模块差异</h4><blockquote><ul><li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。  </li><li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;最近在梳理前端的公众号支付流程，从前端流程微信JSSDK的引入开始查阅文档。&lt;br&gt;在引入JS文件一小段中，文档中备注：“支持使用 AMD/CMD 标准模块加载方法加载”。&lt;br&gt;于是，想到对CommonJS、AMD、CMD、ES6Module等概念与代码实例的理解甚是混淆，于是学习、总结此文。  &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="web前端" scheme="http://liugezhou.online/categories/web%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端模块化" scheme="http://liugezhou.online/tags/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>No4.浏览器中的页面循环系统</title>
    <link href="http://liugezhou.online/2019/11/25/No4.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E9%A1%B5%E9%9D%A2%E5%BE%AA%E7%8E%AF%E7%B3%BB%E7%BB%9F/"/>
    <id>http://liugezhou.online/2019/11/25/No4.浏览器中的页面循环系统/</id>
    <published>2019-11-25T12:40:00.000Z</published>
    <updated>2020-01-10T06:17:45.071Z</updated>
    
    <content type="html"><![CDATA[<h6 id="前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。"><a href="#前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。" class="headerlink" title="前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。"></a>前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。</h6><h6 id="本篇是这个专栏的第四章：《浏览器中的页面循环系统》。本章分为六节。"><a href="#本篇是这个专栏的第四章：《浏览器中的页面循环系统》。本章分为六节。" class="headerlink" title="本篇是这个专栏的第四章：《浏览器中的页面循环系统》。本章分为六节。"></a>本篇是这个专栏的第四章：《浏览器中的页面循环系统》。本章分为六节。</h6><a id="more"></a><h4 id="15｜消息队列和事件循环：页面是怎么“活”起来的？"><a href="#15｜消息队列和事件循环：页面是怎么“活”起来的？" class="headerlink" title="15｜消息队列和事件循环：页面是怎么“活”起来的？"></a>15｜消息队列和事件循环：页面是怎么“活”起来的？</h4><blockquote><p>本节主要专门介绍页面的事件循环系统，希望通过几段总结能对页面的事件循环系统有一个整体上的理解。    </p></blockquote><h5 id="使用单线程处理安排好的任务"><a href="#使用单线程处理安排好的任务" class="headerlink" title="使用单线程处理安排好的任务"></a>使用单线程处理安排好的任务</h5><blockquote><p>单线程处理的流程就是把所有任务代码按照顺序写进主线程里，等线程运行时，这些任务按照顺序在线程中执行，等所有任务执行完成，线程自动退出。        </p></blockquote><h5 id="在线程运行过程中处理任务"><a href="#在线程运行过程中处理任务" class="headerlink" title="在线程运行过程中处理任务"></a>在线程运行过程中处理任务</h5><blockquote><p>当然并非所有任务都可以使用单线程处理，有时我们需要在线程运行的过程中处理任务。<br>那么要想在线程运行过程中，能接受并执行新的任务，就需要采用事件循环机制。<br>相较与单线程处理任务，此线程做了两点改进：  </p><ul><li>引入了循环机制。(比如一个实现方式是添加for循环。线程一直循环执行)。 </li><li>引入了事件。</li></ul></blockquote><h5 id="处理其他线程发送过来的任务"><a href="#处理其他线程发送过来的任务" class="headerlink" title="处理其他线程发送过来的任务"></a>处理其他线程发送过来的任务</h5><blockquote><p>如何设计好一个线程模型，能让其能够接受其他线程发送的消息呢？<br>一个通用的模式是消息队列：「消息队列是一种数据结构、可以存放要执行的任务。它符合队列“先进先出”的特点。」<br>有了队列之后继续改进步骤如下：    </p><ul><li>添加一个消息队列。  </li><li>IO线程中产生的新任务添加进消息队列尾部。    </li><li>渲染主进程会循环地从消息队列头部中读取任务，执行任务。  </li></ul></blockquote><h5 id="处理其他进程发送过来的任务"><a href="#处理其他进程发送过来的任务" class="headerlink" title="处理其他进程发送过来的任务"></a>处理其他进程发送过来的任务</h5><blockquote><p>渲染进程专门有一个 IO 线程用来接收其他进程传进来的消息，接收到消息之后，会将这些消息组装成任务发送给渲染主线程，后续的步骤就和前面的“处理其他线程发送的任务”一样。    </p></blockquote><h5 id="消息队列中的任务类型"><a href="#消息队列中的任务类型" class="headerlink" title="消息队列中的任务类型"></a>消息队列中的任务类型</h5><blockquote><p>消息队列中的任务都有哪些呢？<br>输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器等等。除此之外，消息队列中还包含了很多与页面相关的事件，如 JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画等。    </p></blockquote><h5 id="页面使用单线程的缺点"><a href="#页面使用单线程的缺点" class="headerlink" title="页面使用单线程的缺点"></a>页面使用单线程的缺点</h5><blockquote><ul><li>第一个问题是如何处理高优先级的任务。<br>由于优先级的问题使得微任务应用而生，微任务是如何权衡效率和实时性的呢?<br>通常我们把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题.等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为 DOM 变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题   </li><li>第二个是如何解决单个任务执行时长过久的问题.<br>针对这种情况，JavaScript 可以通过回调功能来规避这种问题，也就是让要执行的 JavaScript 任务滞后执行。  </li></ul></blockquote><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><blockquote><p>如果有一些确定好的任务，可以使用一个单线程来按照顺序处理这些任务，这是第一版线程模型。<br>要在线程执行过程中接收并处理新的任务，就需要引入循环语句和事件系统，这是第二版线程模型。<br>如果要接收其他线程发送过来的任务，就需要引入消息队列，这是第三版线程模型。<br>如果其他进程想要发送任务给页面主线程，那么先通过 IPC 把任务发送给渲染进程的 IO 线程，IO 线程再把任务发送给页面主线程。<br>消息队列机制并不是太灵活，为了适应效率和实时性，引入了微任务。</p></blockquote><h4 id="16-｜-WebAPI-setTimeout是如何实现的"><a href="#16-｜-WebAPI-setTimeout是如何实现的" class="headerlink" title="16 ｜ WebAPI : setTimeout是如何实现的"></a>16 ｜ WebAPI : setTimeout是如何实现的</h4><h5 id="浏览器怎么实现setTimeout"><a href="#浏览器怎么实现setTimeout" class="headerlink" title="浏览器怎么实现setTimeout"></a>浏览器怎么实现setTimeout</h5><blockquote><p>通过上一小节的学习，我们知道：对于一些事件执行的过程是：这些事件先被添加到消息队列，然后事件循环系统就会按照消息队列中的顺序来执行事件。也就是说，执行一段异步任务，需要先将任务添加到消息队列中。<br>不过通过定时器设置回调函数有点特别，它们需要在指定的时间间隔内被调用，但消息队列中的任务是按照顺序执行的，所以为了保证回调函数能在指定时间内执行，你不能将定时器的回调函数直接添加到消息队列中。<br>从Chromium队列的部分源码中我们知道，在Chrome中除了正常使用的消息队列外，还有另外一个消息队列，这个队列中维护了<code>需要延迟执行的任务列表</code>，包括了定时器和Chromium内部一些需要延迟执行的任务。<br>由于消息队列排队和一些系统级别的限制，通过setTimeout设置的回调任务并非总是可以实时的执行，这样就不能满足一些实时性要求较高的需求。    </p></blockquote><h5 id="使用setTimeout的一些注意事项"><a href="#使用setTimeout的一些注意事项" class="headerlink" title="使用setTimeout的一些注意事项"></a>使用setTimeout的一些注意事项</h5><blockquote><ul><li>如果当前任务执行时间过久，会影响延迟到期定时器任务的执行。  </li><li>如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒。 </li><li>未激活的页面，setTimeout 执行最小间隔是 1000 毫秒.  </li><li>延时执行时间有最大值:大约 24.8 天   </li><li>使用 setTimeout 设置的回调函数中的 this 不符合直觉. </li></ul></blockquote><h4 id="17-WebAPI：XMLHttpRequest是怎么实现的"><a href="#17-WebAPI：XMLHttpRequest是怎么实现的" class="headerlink" title="17 | WebAPI：XMLHttpRequest是怎么实现的?"></a>17 | WebAPI：XMLHttpRequest是怎么实现的?</h4><blockquote><p>在深入讲解 XMLHttpRequest 之前，我们得先介绍下<code>同步回调</code>和<code>异步回调</code>这两个概念.   </p></blockquote><h5 id="回调函数-VS-系统调用栈"><a href="#回调函数-VS-系统调用栈" class="headerlink" title="回调函数 VS 系统调用栈"></a>回调函数 VS 系统调用栈</h5><blockquote><p><code>回调函数</code>：将一个函数作为参数传递给另外一个函数，那作为参数的这个函数就是回调函数。</p></blockquote><blockquote><p>同步回调函数代码：  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let callback = function()&#123;</span><br><span class="line">    console.log(&apos;i am do homework&apos;)</span><br><span class="line">&#125;</span><br><span class="line">function doWork(cb) &#123;</span><br><span class="line">    console.log(&apos;start do work&apos;)</span><br><span class="line">    cb()</span><br><span class="line">    console.log(&apos;end do work&apos;)</span><br><span class="line">&#125;</span><br><span class="line">doWork(callback)</span><br><span class="line">//start do work</span><br><span class="line">//i am do homework</span><br><span class="line">//end do work</span><br></pre></td></tr></table></figure><blockquote><p>异步回调函数代码：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let callback = function()&#123;</span><br><span class="line">    console.log(&apos;i am do homework&apos;)</span><br><span class="line">&#125;</span><br><span class="line">function doWork(cb) &#123;</span><br><span class="line">    console.log(&apos;start do work&apos;)</span><br><span class="line">    setTimeout(cb,1000)   </span><br><span class="line">    console.log(&apos;end do work&apos;)</span><br><span class="line">&#125;</span><br><span class="line">doWork(callback)</span><br></pre></td></tr></table></figure><h5 id="XMLHttpRequest运作机制"><a href="#XMLHttpRequest运作机制" class="headerlink" title="XMLHttpRequest运作机制"></a>XMLHttpRequest运作机制</h5><blockquote><p>对回调函数有了一个认知后，那么接着我们来分析下从发起请求到接收数据的完整流程：    </p></blockquote><blockquote><p>首先从XMLHttpRequest的用法开始：</p><ul><li>第一步：创建XMLHttpRequest对象。  </li><li>第二步：为xhr对象注册回调函数。</li><li>第三步：配置基础的请求信息。    </li><li>第四步：发起请求。  </li></ul></blockquote><h5 id="XMLRequest使用过程中的“坑”"><a href="#XMLRequest使用过程中的“坑”" class="headerlink" title="XMLRequest使用过程中的“坑”"></a>XMLRequest使用过程中的“坑”</h5><blockquote><ul><li>跨域问题    </li><li>HTTPS混合内容的问题：这是指HTTPS页面中包含了不符合HTTPS安全要求的内容，比如包含了HTTP资源。</li></ul></blockquote><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><blockquote><p>setTimeout 是直接将延迟任务添加到延迟队列中，而 XMLHttpRequest 发起请求，是由浏览器的其他进程或者线程去执行，然后再将执行结果利用 IPC 的方式通知渲染进程，之后渲染进程再将对应的消息添加到消息队列中。    </p></blockquote><h4 id="18-宏任务和微任务：不是所有的任务都是一个待遇"><a href="#18-宏任务和微任务：不是所有的任务都是一个待遇" class="headerlink" title="18 | 宏任务和微任务：不是所有的任务都是一个待遇"></a>18 | 宏任务和微任务：不是所有的任务都是一个待遇</h4><blockquote><p>前面我们已经知道微任务可以在实时性和效率之间做一个有效的权衡。微任务已被广泛应用，比如Promise以及以Promise为基础开发出来的很多其他的技术。<br>宏任务与微任务的区别：    </p></blockquote><h5 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h5><blockquote><p>页面中的大部分任务都是在主线程上执行的。如渲染事件、用户交互事件、JavaScript脚本执行事件、网络请求等等。这些在消息队列中的任务称为宏任务。<br>虽然宏任务可以满足我们大部门的日常需求，但是有时对时间精度要求较高的需求，宏任务就难以胜任了。</p></blockquote><h5 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h5><blockquote><p>微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。<br>产生微任务的两种方式：    </p><ul><li>第一种方式是使用 MutationObserver 监控某个 DOM 节点，然后再通过 JavaScript 来修改这个节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。   </li><li>第二种方式是使用 Promise，当调用 Promise.resolve() 或者 Promise.reject() 的时候，也会产生微任务。<br>通过微任务的工作流程，我们可以得出如下结论：  </li><li>微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。    </li><li>微任务的执行时长会影响到当然宏任务的执行时长，因此写代码的时候一定要注意微任务的执行时长。  </li><li>在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务早于宏任务执行。</li></ul></blockquote><h5 id="监听DOM变化演变"><a href="#监听DOM变化演变" class="headerlink" title="监听DOM变化演变"></a>监听DOM变化演变</h5><blockquote><p>微任务应用在了<code>MutationObserver</code>中，<code>MutationObserver</code>是用来监听DOM变化的一套方法。 监听DOM变化一直是前端工程师一项非常核心的需求。<br>下面是监听DOM变化演变的简单总结:  </p><ul><li>早起观测DOM变化就是轮询检测。比如使用 setTimeout 或者 setInterval 来定时检测 DOM 是否有改变。无疑这种方式实时性不好，效率还低效。   </li><li>2000年的时候引入了Mutation Event，Mutation Event采用了观察者的设计模式，当DOM有变动时立即出发相应的事件。此方式属于同步回调。虽然这种方式解决了实时性问题，但是因为会产生较大性能开销、导致页面性能出现问题，被反对使用并逐步从web标准事件中删除。  </li><li>MutationObserver替代MutationEvent，相较于Event方式，Observer采用了一次触发异步回调。且采用微任务的处理，使得实时性与性能功能都得到有效提高。</li></ul></blockquote><h4 id="19-｜-Promise：使用Promise，告别回调函数"><a href="#19-｜-Promise：使用Promise，告别回调函数" class="headerlink" title="19 ｜ Promise：使用Promise，告别回调函数"></a>19 ｜ Promise：使用Promise，告别回调函数</h4><blockquote><p>微任务的另一个应用：Promise。<br>本节简单介绍JavaScript引入Promise的动机，以及解决问题的几个核心关键点。<br>讲到动机，也就是说Promise解决了什么问题。众所周知，他解决的是异步编码风格的问题。 </p></blockquote><blockquote><p>页面编程的一大特点就是：异步编程，下面分析异步编程的代码风格进化。    </p><ul><li>之前的代码编码风格，一段代码可能会出现五次回调，这种回调导致代码逻辑不连贯、不连线，不符合人的直觉。  </li><li>然后开发人员们通过封装异步代码，让处理流程变得线性，但是这种处理方式如果嵌套了太多的回调函数就容易陷入回调地狱。</li><li>陷入回调地狱的后代码看上去很乱主要是两点：嵌套调用和任务不确定性(成功或者失败)。于是Promise出现，解决了这两个问题。</li></ul></blockquote><h5 id="Promise：消灭嵌套调用和多次错误处理"><a href="#Promise：消灭嵌套调用和多次错误处理" class="headerlink" title="Promise：消灭嵌套调用和多次错误处理"></a>Promise：消灭嵌套调用和多次错误处理</h5><blockquote><p>Promise通过两步解决嵌套回调问题：</p><ul><li>首先，Promise实现了回调函数的延时绑定（.then）  </li><li>其次，将回调函数返回值穿透到最外层。</li></ul></blockquote><blockquote><p>Promise处理异常：<br>通过最后一个catch，将所有对象合并到一个函数来处理之前的所有异常。</p></blockquote><h5 id="Promise与微任务"><a href="#Promise与微任务" class="headerlink" title="Promise与微任务"></a>Promise与微任务</h5><blockquote><p> Promise 之所以要使用微任务是由 Promise 回调函数延迟绑定技术导致的。</p></blockquote><h4 id="20-｜-async-await：使用同步的方式去写异步代码"><a href="#20-｜-async-await：使用同步的方式去写异步代码" class="headerlink" title="20 ｜ async/await：使用同步的方式去写异步代码"></a>20 ｜ async/await：使用同步的方式去写异步代码</h4><blockquote><p>当Promise解决回调地狱代码风格的同时，我们发现写很多的then函数，还是有些不太容易阅读。<br>基于这个原因，ES7引入了async/await，这是JavaScript异步编程的一个重大改进，提供了在不阻塞主线程的情况下使用同步代码实现异步访问资源的能力。并且使得代码逻辑更加清晰。</p></blockquote><blockquote><p>本节首先介绍生成器(Generator)是如何工作的，接着介绍了Generator的底层实现机制–协程。<br>这是因为async/await使用了Generator和Promise两种技术。所以紧接着通过Generator和Promise来分析async/await到底是如何通过以同步方式来编写异步代码的。  </p></blockquote><h5 id="生成器-VS-协程"><a href="#生成器-VS-协程" class="headerlink" title="生成器 VS 协程"></a>生成器 VS 协程</h5><blockquote><p>生成器函数：生成器函数是一个带星号函数，而且是可以暂停执行和恢复执行的。<br>具体使用方式就是：在生成器函数内部执行一段代码，若遇到yiled关键字，那JS引擎将返回该关键字后面的内容且暂停该函数执行，外部函数通过next方法恢复函数的执行。<br>那么JavaScript引擎V8是如何实现一个函数的暂停和恢复的？    </p></blockquote><blockquote><p>搞懂它的暂停和恢复，需要首先了解协程的概念。协程是一种比线程更加轻量级的存在。可以把协程看作是跑在线程上的任务，一个线程可以存在多个协程。但在线程上同时只能执行一个协程。<br>在JS中，生成器就是协程的一种实现方式。</p></blockquote><h5 id="asnyc-await"><a href="#asnyc-await" class="headerlink" title="asnyc/await"></a>asnyc/await</h5><blockquote><p>为了更近一步改进生成器代码，ES7引入了async/awit，实现了更加直观简洁的代码。<br>async/aswit技术背后的实现就是Promise和生成器应用。往底层说就是微服务和协程应用。</p></blockquote><blockquote><p>async: 是一个通过异步执行并隐式返回Promise作为结果的函数。<br>await: 我们知道了 async 函数返回的是一个 Promise 对象，那下面我们再结合文中这段代码来看看 await 到底是什么。   </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">async function foo() &#123;</span><br><span class="line">    console.log(1)</span><br><span class="line">    let a = await 100</span><br><span class="line">    console.log(a)</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;</span><br><span class="line">console.log(0)</span><br><span class="line">foo()</span><br><span class="line">console.log(3)</span><br><span class="line">//输出结果：0 3 100 2</span><br></pre></td></tr></table></figure><blockquote><p>async/await 无疑是异步编程领域非常大的一个革新，也是未来的一个主流的编程风格。其实，除了 JavaScript，Python、Dart、C# 等语言也都引入了 async/await，使用它不仅能让代码更加整洁美观，而且还能确保该函数始终都能返回 Promise。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot;&gt;&lt;a href=&quot;#前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot; class=&quot;headerlink&quot; title=&quot;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot;&gt;&lt;/a&gt;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&lt;/h6&gt;&lt;h6 id=&quot;本篇是这个专栏的第四章：《浏览器中的页面循环系统》。本章分为六节。&quot;&gt;&lt;a href=&quot;#本篇是这个专栏的第四章：《浏览器中的页面循环系统》。本章分为六节。&quot; class=&quot;headerlink&quot; title=&quot;本篇是这个专栏的第四章：《浏览器中的页面循环系统》。本章分为六节。&quot;&gt;&lt;/a&gt;本篇是这个专栏的第四章：《浏览器中的页面循环系统》。本章分为六节。&lt;/h6&gt;
    
    </summary>
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>每周总结第二十期</title>
    <link href="http://liugezhou.online/2019/11/24/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93%E7%AC%AC%E4%BA%8C%E5%8D%81%E6%9C%9F/"/>
    <id>http://liugezhou.online/2019/11/24/每周总结第二十期/</id>
    <published>2019-11-24T08:50:00.000Z</published>
    <updated>2019-11-25T02:15:31.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这里记录过去一周，我的一些小总结。</p></blockquote><a id="more"></a><h4 id="Feeling"><a href="#Feeling" class="headerlink" title="Feeling"></a>Feeling</h4><blockquote><p>本周并没有总结什么。<br>只是最近几周有个感觉，更是事实，那些写技术文章的公号里充满了软文宣传、推广。<br>技术公号的文章凡是过千的便是一个有些影响力的传播媒介了。连阮一峰这种大牛级别的公众号文章的阅读量也不过万。<br>对于商业卖课者来说，公众号的每一个阅读量都代表了那些实打实的目标群体客户都接受到了广告的洗礼，<br>群体性的技术公号集体沦陷开始卖课，这应该就是那种说程序员技术变现的广泛实例。<br>我只是很好奇这种一篇推广文，会给开发者多少广告费用。 </p></blockquote><h4 id="琅琊榜图谱"><a href="#琅琊榜图谱" class="headerlink" title="琅琊榜图谱"></a>琅琊榜图谱</h4><blockquote><p>周末倍速在家刷了一遍琅琊榜，理不清谁的谁是谁的谁：</p><p>梅长苏的爸爸是林燮(xie)。<br>林燮的妹妹是宸妃.<br>宸妃的儿子是祁王–&gt; 祁王的儿子是庭生。<br>宸妃的老公是粱王。</p><p>梅长苏的妈妈是晋阳长公主。<br>晋阳长公主的哥哥是粱王。</p><p>晋阳长公主的妹妹是莅阳长公主.<br>莅阳长公主的丈夫是谢玉。</p><p>莅阳长公主的情人是南楚晟王宇文霖。<br>宇文霖的亲生儿子是萧景睿。</p><p>粱王还有个老婆是静妃，静妃的儿子是靖王。<br>粱王还有个老婆是越贵妃，越贵妃的儿子是太子。<br>粱王还有个老婆是言皇后，言皇后的养子是誉王。 </p><p>梅长苏赤焰军旧部里面有个叫聂峰。<br>聂峰的老婆是夏冬。<br>夏冬的师哥是夏秋。<br>夏冬的师傅是夏江。</p><p>……</p></blockquote><h4 id="网传网易让保安将绝症员工赶出公司"><a href="#网传网易让保安将绝症员工赶出公司" class="headerlink" title="网传网易让保安将绝症员工赶出公司"></a>网传网易让保安将绝症员工赶出公司</h4><blockquote><p>我们大家都知道不应该因为一个员工事件来骂网易云音乐或者任何的网易应用。<br>只是大家需要一个有个官方账号的回应。<br>大家维护的不仅仅是这一起人血馒头事件。<br>更加维护的是自己的生存社会环境。<br>【每个人对于他所处的社会都负有责任，这个社会的弊病需要每一个人去维护】。</p></blockquote><h4 id="曾文正公全集"><a href="#曾文正公全集" class="headerlink" title="曾文正公全集"></a>曾文正公全集</h4><blockquote><p>盖士人读书，第一要有志，第二要有识，第三要有恒。有志则不甘为下流；有识则知学问无尽，不敢以一得自足，如河伯之观海，如井蛙之窥天，皆无识者也；有恒则断无不成之事。此三者缺一不可。诸弟此时惟有识不可以骤几；至于有志，有恒，则诸弟勉之而已。<br>中心思想：要学会读书。<br><cite>引自《曾文正公全集》</cite></p></blockquote><h4 id="CSS定位详解"><a href="#CSS定位详解" class="headerlink" title="CSS定位详解"></a><a href="http://www.ruanyifeng.com/blog/2019/11/css-position.html" target="_blank" rel="noopener">CSS定位详解</a></h4><blockquote><p>CSS 有两个最重要的基本属性，前端开发必须掌握：display 和 position。<br>display属性指定网页的布局。两个重要的布局，弹性布局<code>flex</code>和网格布局<code>grid</code>。<br>本文介绍非常有用的position属性。作者希望通过10分钟的阅读，帮助大家轻松掌握网页定位，说清楚浏览器如何计算网页元素的位置，尤其是新引进的<code>sticky</code>定位.   </p></blockquote><h4 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h4><blockquote><p>iOS APP FOR BETA 版本已经预约两个星期了，还是没有下文，真是让人焦灼。 </p></blockquote><h4 id="No3-V8工作原理"><a href="#No3-V8工作原理" class="headerlink" title="No3.V8工作原理"></a><a href="https://www.liugezhou.online/2019/11/21/No3.V8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">No3.V8工作原理</a></h4><blockquote><p>前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。<br>本篇是这个专栏的第三章：<a href="https://www.liugezhou.online/2019/11/21/No3.V8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">No3.V8工作原理</a>。本章分为三讲。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这里记录过去一周，我的一些小总结。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="每周分享" scheme="http://liugezhou.online/categories/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="每周分享" scheme="http://liugezhou.online/tags/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>No3.V8工作原理</title>
    <link href="http://liugezhou.online/2019/11/21/No3.V8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://liugezhou.online/2019/11/21/No3.V8工作原理/</id>
    <published>2019-11-21T13:40:00.000Z</published>
    <updated>2020-01-10T06:17:27.455Z</updated>
    
    <content type="html"><![CDATA[<h6 id="前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。"><a href="#前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。" class="headerlink" title="前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。"></a>前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。</h6><h6 id="本篇是这个专栏的第三章：《V8工作原理》。本章分为三节。"><a href="#本篇是这个专栏的第三章：《V8工作原理》。本章分为三节。" class="headerlink" title="本篇是这个专栏的第三章：《V8工作原理》。本章分为三节。"></a>本篇是这个专栏的第三章：《V8工作原理》。本章分为三节。</h6><a id="more"></a><h4 id="12｜栈空间和堆空间：数据是如何存储的？"><a href="#12｜栈空间和堆空间：数据是如何存储的？" class="headerlink" title="12｜栈空间和堆空间：数据是如何存储的？"></a>12｜栈空间和堆空间：数据是如何存储的？</h4><h5 id="JavaScript是什么类型的语言"><a href="#JavaScript是什么类型的语言" class="headerlink" title="JavaScript是什么类型的语言"></a>JavaScript是什么类型的语言</h5><blockquote><p>在使用之前就需要确认其变量数据类型的语言称为<code>静态语言</code>，相反地，我们把运行过程中需要检查数据类型的语言称为<code>动态语言</code>。<br>我们把变量直接可以偷偷进行转换的操作称为隐式类型转换，支持隐式类型的语言称为<code>弱类型语言</code>，不支持隐式类型转换的语言称为<code>强类型语言</code>。      </p></blockquote><blockquote><p>显然，JavaScript是动态弱类型语言。    </p></blockquote><h5 id="JavaScript的数据类型"><a href="#JavaScript的数据类型" class="headerlink" title="JavaScript的数据类型"></a>JavaScript的数据类型</h5><blockquote><p>JavaScript的数据类型一共有八种：<br>基本数据类型：Boolean、Undefined、Null、String、Number、Bigint、Symbol<br>引用数据类型：Object  </p></blockquote><h5 id="内存空间"><a href="#内存空间" class="headerlink" title="内存空间"></a>内存空间</h5><blockquote><p>在JavaScript的执行过程中，主要有三种类型内存空间：代码空间、栈空间、堆空间。<br>原始类型的数据值都是直接保存在栈中的，引用类型的值都是保存在堆空间中的。<br>通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。堆空间很大，能存放很多大的数据。<br>原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。    </p></blockquote><h5 id="产生闭包的核心"><a href="#产生闭包的核心" class="headerlink" title="产生闭包的核心"></a>产生闭包的核心</h5><blockquote><p>第一步是需要预扫描内部函数。<br>第二步是把内部函数引用的外部变量保存到堆中。  </p></blockquote><h4 id="13-｜-垃圾回收：垃圾数据是如何自动回收的？"><a href="#13-｜-垃圾回收：垃圾数据是如何自动回收的？" class="headerlink" title="13 ｜ 垃圾回收：垃圾数据是如何自动回收的？"></a>13 ｜ 垃圾回收：垃圾数据是如何自动回收的？</h4><hr><blockquote><p>对一些不需要的数据，我们称之为垃圾数据，由于内存是有限的，为了释放内存，我们需要对这么垃圾数据进行回收。  </p></blockquote><h5 id="不同语言的垃圾回收策略"><a href="#不同语言的垃圾回收策略" class="headerlink" title="不同语言的垃圾回收策略"></a>不同语言的垃圾回收策略</h5><blockquote><p>通常情况，垃圾回收分为手动回收到自动回收两种策略。<br>如C/C++C++使用的是手动回收策略，何时分配内存、何时销毁内存都是由代码控制的。<br>如JavaScript、Java、Python等语言使用的是自动回收策略，产生的垃圾数据是由垃圾回收器来释放的。  </p></blockquote><h5 id="调用栈中的数据是如何回收的"><a href="#调用栈中的数据是如何回收的" class="headerlink" title="调用栈中的数据是如何回收的"></a>调用栈中的数据是如何回收的</h5><blockquote><p>栈中的垃圾回收相对比较简单：JavaScript引擎会通过向下移动ESP来销毁该函数保存在栈中的执行上下文。<br>ESP：记录当前执行状态的指针。</p></blockquote><h5 id="堆中的数据是如何回收的"><a href="#堆中的数据是如何回收的" class="headerlink" title="堆中的数据是如何回收的"></a>堆中的数据是如何回收的</h5><blockquote><p>要回收堆中的数据，需要用到JavaScript中的垃圾回收器。</p></blockquote><blockquote><p>在介绍V8如何实现回收之前，首先要了解下<code>代际假说</code>内容。这是垃圾回收领域一个重要的术语，代际假说有两个特点：    </p><ul><li>第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问.  </li><li>第二个是不死的对象，会活得更久.<br>这两个特点不仅仅适用于JavaScript，同样适应于大多数动态语言，如Java、Python等。    </li></ul></blockquote><blockquote><p>在V8中会把堆分为新生代(支持1-8M容量)和老生代(容量大很多)两个区域，新生代中存放的是生存时间短的对象，老生代中存放的是生存时间久的对象。  </p><ul><li>副垃圾回收器，主要负责新生代的垃圾回收。    </li><li>主垃圾回收器，主要负责老生代的垃圾回收。   </li></ul></blockquote><h5 id="垃圾回收器的工作流程"><a href="#垃圾回收器的工作流程" class="headerlink" title="垃圾回收器的工作流程"></a>垃圾回收器的工作流程</h5><blockquote><p>不论是主垃圾回收器还是副垃圾回收器，它们都有一套共同的执行流程。  </p><ul><li>第一步为标记活动对象与非活动对象。活动对象为还在使用的对象，非活动对象为要准备进行垃圾回收的对象。  </li><li>第二步是回收非活动对象所占用的内存。既在标记后统一清理被标记为可回收的对象的内存。    </li><li>第三步是内存整理。这是因为在频繁回收对象后，内存中会存在不连续空间，把这些不连续空间称为内存碎片。因此需要整理这些碎片，这是为了当那些较大连续内存出现时可以方便分配。【这步是可选的，副垃圾回收器不会产生内存碎片】。<br>然后按照上述流程来分析新生代垃圾回收器（副垃圾回收器）和老生代垃圾回收器（主垃圾回收器）是如何处理垃圾回收的。    </li></ul></blockquote><h5 id="副垃圾回收器"><a href="#副垃圾回收器" class="headerlink" title="副垃圾回收器"></a>副垃圾回收器</h5><blockquote><p>副垃圾回收器主要负责新生代区的垃圾回收，虽然老生代区域不大，但是垃圾回收比较频繁。<br>新生代中用Scavenge算法来处理。【Scavenge算法：把新生代空间对半划分为两个区域，一个是对象区域，一个是空闲区域。】<br>过程大概就是：新加入对象放入都对象区域，快写满时进行垃圾清理操作，副垃圾回收器把这些对象复制到空闲区域，复制后的空闲区域没有内存碎片。完成复制后，对象区域与空闲区域角色翻转。角色翻转的操作能让新生代中的两块区域无限重复使用下去。<br>因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。</p></blockquote><h5 id="主垃圾回收器"><a href="#主垃圾回收器" class="headerlink" title="主垃圾回收器"></a>主垃圾回收器</h5><blockquote><p>主垃圾回收器主要负责老生区中的垃圾回收.<br>老生区中对象的两个特点：一是存活时间长，二是对象占用空间大。<br>由特点我们知道采用副垃圾回收器的Scavenge算法显然不满足需求，因此，主垃圾回收器采用的是<code>标记-清除（Mark-Sweep）</code>算法进行垃圾回收。碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——<code>标记 - 整理（Mark-Compact）</code> .</p></blockquote><h4 id="14-编译器和解释器：V8是如何执行一段JavaScript代码的"><a href="#14-编译器和解释器：V8是如何执行一段JavaScript代码的" class="headerlink" title="14 | 编译器和解释器：V8是如何执行一段JavaScript代码的"></a>14 | 编译器和解释器：V8是如何执行一段JavaScript代码的</h4><hr><blockquote><p>深入了解V8的工作原理，我们需要弄清除一些概念和原理，比如本节要学习的：<code>编译器(Compiler)</code>、<code>解释器(Interpreter)</code>、<code>抽象语法树(AST)</code>、<code>字节码(Bytecode)</code>、<code>即时编译器(JIT)</code>等概念。 </p></blockquote><h5 id="编译器和解释器"><a href="#编译器和解释器" class="headerlink" title="编译器和解释器"></a>编译器和解释器</h5><blockquote><p>编译器和解释器“翻译”代码的流程大致可阐述如下：    </p><ol><li>在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功。    </li><li>在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。    </li></ol></blockquote><h5 id="V8是如何执行一段JavaScript代码的"><a href="#V8是如何执行一段JavaScript代码的" class="headerlink" title="V8是如何执行一段JavaScript代码的"></a>V8是如何执行一段JavaScript代码的</h5><blockquote><p>V8在执行过程中既有解释器，又有编译器。分解其执行流程如下：    </p></blockquote><h6 id="1-生成抽象语法树-AST-和执行上下文"><a href="#1-生成抽象语法树-AST-和执行上下文" class="headerlink" title="1.生成抽象语法树(AST)和执行上下文"></a>1.生成抽象语法树(AST)和执行上下文</h6><blockquote><p>那么这个抽象语法树AST是什么呢？<br>首先我们知道高级语言只是开发者可以理解的语言，但是让编译器或者解释器来理解就非常困难了。对于编译器或者解释器来说，他可以理解的是AST，所以无论是解释性语言还是编译型语言，在编译过程中，都会生成一个AST。<br>一段代码经过javascript-ast站点处理后，AST的结构和代码结构非常之相似，具体结构就不展示了，类似于DOM树。AST的生成需要经过两个阶段： </p><ul><li>第一阶段是<code>分词</code>，又称为<code>词法分析</code>。其作用是将一行行的源码拆解成一个个 token。所谓 token，指的是语法上不可能再分的、最小的单个字符或字符串。  </li><li>第二阶段是<code>解析</code>,又称为<code>语法分析</code>。其作用是将上一步生成的 token 数据，根据语法规则转为 AST。    </li></ul></blockquote><h6 id="2-生成字节码"><a href="#2-生成字节码" class="headerlink" title="2.生成字节码"></a>2.生成字节码</h6><blockquote><p>有了 AST 和执行上下文后，那接下来的第二步，解释器 Ignition 就登场了，它会根据 AST 生成字节码，并解释执行字节码。<br>字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行.之所以出现字节码，是Chrome团队为了解决内存占用问题而引入的。    </p></blockquote><h6 id="3-执行代码"><a href="#3-执行代码" class="headerlink" title="3.执行代码"></a>3.执行代码</h6><blockquote><p>生成字节码之后，接下来就进入了执行阶段。<br>在执行阶段，通常解释器逐条执行字节码，如果发现有热点代码(一段代码被重复执行多次)，那后台编译器会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了。这种字节码配合解释器和编译器的技术就称为<code>即时编译(JIT)</code>.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot;&gt;&lt;a href=&quot;#前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot; class=&quot;headerlink&quot; title=&quot;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot;&gt;&lt;/a&gt;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&lt;/h6&gt;&lt;h6 id=&quot;本篇是这个专栏的第三章：《V8工作原理》。本章分为三节。&quot;&gt;&lt;a href=&quot;#本篇是这个专栏的第三章：《V8工作原理》。本章分为三节。&quot; class=&quot;headerlink&quot; title=&quot;本篇是这个专栏的第三章：《V8工作原理》。本章分为三节。&quot;&gt;&lt;/a&gt;本篇是这个专栏的第三章：《V8工作原理》。本章分为三节。&lt;/h6&gt;
    
    </summary>
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>每周总结第十九期</title>
    <link href="http://liugezhou.online/2019/11/17/%E6%AF%8F%E5%91%A8%E6%80%BB%E7%BB%93%E7%AC%AC%E5%8D%81%E4%B9%9D%E6%9C%9F/"/>
    <id>http://liugezhou.online/2019/11/17/每周总结第十九期/</id>
    <published>2019-11-17T09:45:00.000Z</published>
    <updated>2019-11-17T09:49:24.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>这里记录过去一周，我的一些小总结。</p></blockquote><a id="more"></a>。<p><img src="http://img.liugezhou.online/weekly19" alt="weekly-19"></p><h4 id="Feeling"><a href="#Feeling" class="headerlink" title="Feeling"></a>Feeling</h4><blockquote><p>由于自己的职业关系，比较关注一些技术、软件、工具、科技等方面的讯息。<br>这些讯息的爆炸、扩散，让我一次又一次在潜意识里提醒自己：淡定下来，无论窗外之事多么热闹，都不要影响自己的心态，按着自己的节奏去学习、吸收、渗透。</p></blockquote><h4 id="Idea永久激活"><a href="#Idea永久激活" class="headerlink" title="Idea永久激活"></a><a href="https://mp.weixin.qq.com/s/1VBxhZNC4kq2KckT6Jqwfw" target="_blank" rel="noopener">Idea永久激活</a></h4><blockquote><p>Idea工具30天体验结束，找了一些网上的激活方法，大多方法都失效了，最终在这篇文章的指引下，成功激活，推荐推荐。<br>激活传送门：<a href="https://mp.weixin.qq.com/s/1VBxhZNC4kq2KckT6Jqwfw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/1VBxhZNC4kq2KckT6Jqwfw</a></p></blockquote><h4 id="GitLens"><a href="#GitLens" class="headerlink" title="GitLens"></a>GitLens</h4><blockquote><p>它是 VSCode 中非常令人推荐的一个插件，简直是Git神器，码农必备。 每一行代码旁边都有日志，代码是谁提交的一目了然。   </p></blockquote><h4 id="Gitbook"><a href="#Gitbook" class="headerlink" title="Gitbook"></a>Gitbook</h4><blockquote><p>Gitbook编写在线文档，可以非常方便快速的将自己的md、html、zip、docx等文件倒入，实现快速部署。<br>不需域名、不需其他的任何配置，即可快速实现在线浏览。<br>但是需要<code>过墙</code>。<br>我花了十分钟导入两篇文章后的效果：<a href="https://mingzhou.gitbook.io/liugezhou/" target="_blank" rel="noopener">https://mingzhou.gitbook.io/liugezhou/</a></p></blockquote><h4 id="诺基亚老照片"><a href="#诺基亚老照片" class="headerlink" title="诺基亚老照片"></a>诺基亚老照片</h4><blockquote><p>这个工具可以生成老式诺基亚手机的短信图片。<br>网页版：<a href="https://zzkia.noddl.me:8020" target="_blank" rel="noopener">https://zzkia.noddl.me:8020</a><br>微信小程序：【次元蜜蜂】。  </p></blockquote><h4 id="Github-for-mobile-iOS-beta"><a href="#Github-for-mobile-iOS-beta" class="headerlink" title="Github for mobile iOS beta"></a><a href="https://github.com/mobile" target="_blank" rel="noopener">Github for mobile iOS beta</a></h4><blockquote><p>11 月 13 日，GitHub 年度开发者大会—GitHub Universe 2019 在美国旧金山举行。<br>为改善用户体验，GitHub 在本次大会上宣布推出移动端，即 GitHub App 。<br>目前，官方已经上线 iOS 版，不过，却是 beta（公测版），因此用户暂时无法通过 App Store 下载，可以通过官方渠道下载尝鲜。<br>但是，我等</p></blockquote><h4 id="Bytespider"><a href="#Bytespider" class="headerlink" title="Bytespider"></a>Bytespider</h4><blockquote><p>[很多社区用户纷纷反馈，一种名为 Bytespider 的爬虫爬取他们的网站信息的频率太高，直接把网站搞瘫痪了。大家顺着爬虫的 IP 地址查了一下，发现 Bytespider 应该就是今日头条的搜索爬虫。]<sup><a href="https://mp.weixin.qq.com/s/KXg8xAf_TOAROMhqJVQQBQ" target="_blank" rel="noopener">来源</a></sup>  </p></blockquote><blockquote><p>robots.txt 协议:<br>也称为爬虫协议、爬虫规则、机器人协议等。robots.txt文件是存储在网站根目录下的 txt 文本文档。这是网站和蜘蛛之间的协议。该网站告诉搜索引擎哪些页面可以被抓取，哪些页面不想通过机器人协议被抓取。</p></blockquote><h4 id="浏览器中的JavaScript执行机制"><a href="#浏览器中的JavaScript执行机制" class="headerlink" title="浏览器中的JavaScript执行机制"></a><a href="https://www.liugezhou.online/2019/11/11/No2.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JavaScript%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">浏览器中的JavaScript执行机制</a></h4><blockquote><p>前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。<br>本篇是这个专栏的第二章：<a href="https://www.liugezhou.online/2019/11/11/No2.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JavaScript%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">浏览器中的JavaScript执行机制</a>。本章分为五讲。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这里记录过去一周，我的一些小总结。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="每周分享" scheme="http://liugezhou.online/categories/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
    
      <category term="每周分享" scheme="http://liugezhou.online/tags/%E6%AF%8F%E5%91%A8%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>No2.浏览器中的JavaScript执行机制</title>
    <link href="http://liugezhou.online/2019/11/11/No2.%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84JavaScript%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <id>http://liugezhou.online/2019/11/11/No2.浏览器中的JavaScript执行机制/</id>
    <published>2019-11-11T13:40:00.000Z</published>
    <updated>2020-01-10T06:17:21.184Z</updated>
    
    <content type="html"><![CDATA[<h6 id="前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。"><a href="#前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。" class="headerlink" title="前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。"></a>前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。</h6><h6 id="本篇是这个专栏的第二章：《浏览器中的JavaScript执行机制》。本章分为五节。"><a href="#本篇是这个专栏的第二章：《浏览器中的JavaScript执行机制》。本章分为五节。" class="headerlink" title="本篇是这个专栏的第二章：《浏览器中的JavaScript执行机制》。本章分为五节。"></a>本篇是这个专栏的第二章：《浏览器中的JavaScript执行机制》。本章分为五节。</h6><a id="more"></a><h4 id="07｜变量提升：JavaScript代码是按顺序执行的吗？"><a href="#07｜变量提升：JavaScript代码是按顺序执行的吗？" class="headerlink" title="07｜变量提升：JavaScript代码是按顺序执行的吗？"></a>07｜变量提升：JavaScript代码是按顺序执行的吗？</h4><blockquote><p>本节主要讲解<code>执行上下文</code>相关的内容。</p></blockquote><blockquote><p>通过一些代码的执行顺序与经验我们知道：    </p><ul><li>在执行过程中，若使用了未声明的变量，那么 JavaScript 执行会报错。    </li><li>在一个变量定义之前使用它，不会出错，但是该变量的值会为 undefined，而不是定义时的值。    </li><li>在一个函数定义之前使用它，不会出错，且函数能正确执行。</li></ul></blockquote><h5 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h5><blockquote><p>所谓的变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined.<br>之所以会发生变量提升，是因为一段JavaScript代码在执行之前，需要被JavaScript引擎编译，编译完成之后，才会进入执行阶段。也就是说在编译阶段，变量和函数的声明提升到了开头。    </p></blockquote><h4 id="08-｜调用栈：为什么JavaScript代码会出现栈溢出？"><a href="#08-｜调用栈：为什么JavaScript代码会出现栈溢出？" class="headerlink" title="08 ｜调用栈：为什么JavaScript代码会出现栈溢出？"></a>08 ｜调用栈：为什么JavaScript代码会出现栈溢出？</h4><blockquote><p>一般有三种情况，当一段代码执行的时候JS引擎对其进行编译并创建执行上下文：</p><ol><li>当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份.  </li><li>当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。   </li><li>当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。</li></ol></blockquote><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><blockquote><ul><li>每调用一个函数，JavaScript 引擎会为其创建执行上下文，并把该执行上下文压入调用栈，然后 JavaScript 引擎开始执行函数代码。 </li><li>如果在一个函数 A 中调用了另外一个函数 B，那么 JavaScript 引擎会为 B 函数创建执行上下文，并将 B 函数的执行上下文压入栈顶。   </li><li>当前函数执行完毕后，JavaScript 引擎会将该函数的执行上下文弹出栈。   </li><li>当分配的调用栈空间被占满时，会引发“堆栈溢出”问题。</li></ul></blockquote><h4 id="09-块级作用域：var缺陷以及为什么要引入let和const"><a href="#09-块级作用域：var缺陷以及为什么要引入let和const" class="headerlink" title="09 | 块级作用域：var缺陷以及为什么要引入let和const"></a>09 | 块级作用域：var缺陷以及为什么要引入let和const</h4><h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><blockquote><p>作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。<br>ES6出现之前，JS的作用域只有两种：<code>全局作用域</code>和<code>函数作用域</code>。 ES6出现，引入了<code>块级作用域</code>。</p></blockquote><h5 id="在同一段代码中，ES6-是如何做到既要支持变量提升的特性，又要支持块级作用域的呢？"><a href="#在同一段代码中，ES6-是如何做到既要支持变量提升的特性，又要支持块级作用域的呢？" class="headerlink" title="在同一段代码中，ES6 是如何做到既要支持变量提升的特性，又要支持块级作用域的呢？"></a>在同一段代码中，ES6 是如何做到既要支持变量提升的特性，又要支持块级作用域的呢？</h5><blockquote><p>当一段代码里面既有var声明的变量也有let声明的变量的时候：  </p><ul><li>函数内部通过var声明的变量，在编译阶段全都被存放到<code>变量环境</code>里面.  </li><li>通过let声明的变量，在编译阶段会被存放到<code>词法环境</code>中。 </li><li>在函数作用域内部，通过let声明的变量并没有被存放到词法环境中。<br>也就是说：通过理解词法环境的结构和工作机制，块级作用域是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现的，通过两者的结合，JavaScript引擎也就同时支持了变量 提升和块级作用域了。</li></ul></blockquote><h4 id="10-｜-作用域和闭包：代码中出现相同的变量，JavaScript引擎是如何选择的"><a href="#10-｜-作用域和闭包：代码中出现相同的变量，JavaScript引擎是如何选择的" class="headerlink" title="10 ｜ 作用域和闭包：代码中出现相同的变量，JavaScript引擎是如何选择的"></a>10 ｜ 作用域和闭包：代码中出现相同的变量，JavaScript引擎是如何选择的</h4><h5 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h5><blockquote><p>理解作用域链是理解闭包的基础，而闭包在JavaScript中无处不在，同时作用域和作用域链还是作用语言的基础，所以我们先来学习一下<code>作用域链</code>。<br>理解了调用栈、执行上下文、词法环境、变量环境等概念，那么你理解起来作用域链也会很容易,看下面一段代码：</p><pre><code>function bar() {   console.log(myName)}function foo() {   var myName = &quot;局部变量&quot;   bar()}var myName = &quot;全局变量&quot;foo()</code></pre><p>通过上面的代码，我们知道最终打印出来的结果是：”全局变量“。<br>这是因为，当一段代码使用了一个变量后，JavaScript引擎会首先在“当前的执行上下文”中去查找该变量。若没有找到，由于每个执行上下文都包含一个外部引用指向外部执行上下文，所以bar函数中的变量会去全局上下文中区域查找。我们把这个查找的链条就称为作用域链。</p></blockquote><h5 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h5><blockquote><p>foo 函数调用的 bar 函数，那为什么 bar 函数的外部引用是全局执行上下文，而不是 foo 函数的执行上下文？了解这个问题我们继续来学习词法作用域：<br>词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。<br>然后，根据词法作用域，foo 和 bar 的上级作用域都是全局作用域，所以如果 foo 或者 bar 函数使用了一个它们没有定义的变量，那么它们会到全局作用域去查找。也就是说，词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系。</p></blockquote><h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><blockquote><p>在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。<br>在使用闭包的时候，要尽量注意一个原则：如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。</p></blockquote><h4 id="11-｜-this：从JavaScript执行上下文的视角讲清楚this"><a href="#11-｜-this：从JavaScript执行上下文的视角讲清楚this" class="headerlink" title="11 ｜ this：从JavaScript执行上下文的视角讲清楚this"></a>11 ｜ this：从JavaScript执行上下文的视角讲清楚this</h4><blockquote><p>首先我们要知道，在对象内部的方法中使用对象内部的属性是一个非常普遍的需求，但是JavaScript作用域机制并不支持这一点，基于这个需求，JavaScript搞出了一套this机制。    </p></blockquote><blockquote><p>在前几节中，我们提到执行上下文中包含了：<code>变量环境</code>、<code>词法环境</code>、<code>外部环境</code>、还有一个没有提及的<code>this</code>,this是和执行上下文绑定的，每个执行上下文都有一个this。<br>在08节我们总结了执行上下文主要分三种：全局执行上下文、函数执行上下文和eval执行上下文。<br>对应的this也只有这三种：全局执行上下文中的this、函数执行上下中的this和eval中的this(不做讨论)。    </p><ul><li>全局执行上下文中的this：全局执行上下文中的this指向window对象。  </li><li>函数执行上下文中的this：<ol><li>默认情况下调用一个函数，其执行上下文中的 this 也是指向 window 对象的.  </li><li>通过函数的call方法设置其this指向其他对象（还可以使用bind和apply方法来设置函数执行上下文中的this）。   </li><li>通过对象调用方法设置。（使用对象来调用其内部的一个方法，该方法的 this 是指向对象本身的。在全局环境中调用一个函数，函数内部的this指向的是全局变量window）。   </li><li>通过构造函数中设置。   </li></ol></li></ul></blockquote><h5 id="this的设计缺陷以及应对方案"><a href="#this的设计缺陷以及应对方案" class="headerlink" title="this的设计缺陷以及应对方案"></a>this的设计缺陷以及应对方案</h5><blockquote><ol><li>嵌套函数的this不会从外层函数中继承。==&gt;  1⃣️、将this保存一个self变量，利用变量作用域机制传递给嵌套函数。2⃣️、将乔套函数改为箭头函数。   </li><li>普通函数中的this默认指向全局对象window。==&gt;可以通过设置JavaScript的“严格模式”来解决。</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot;&gt;&lt;a href=&quot;#前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot; class=&quot;headerlink&quot; title=&quot;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&quot;&gt;&lt;/a&gt;前段时间在《极客时间》上学了一个专栏，通篇略过，干货不少，但理解相当不够透彻，于是计划用几周的时间，对本专栏内容用作者的总结以及自己的相对逐字理解，来个通篇的文字记录学习，书读百遍，其义自现。&lt;/h6&gt;&lt;h6 id=&quot;本篇是这个专栏的第二章：《浏览器中的JavaScript执行机制》。本章分为五节。&quot;&gt;&lt;a href=&quot;#本篇是这个专栏的第二章：《浏览器中的JavaScript执行机制》。本章分为五节。&quot; class=&quot;headerlink&quot; title=&quot;本篇是这个专栏的第二章：《浏览器中的JavaScript执行机制》。本章分为五节。&quot;&gt;&lt;/a&gt;本篇是这个专栏的第二章：《浏览器中的JavaScript执行机制》。本章分为五节。&lt;/h6&gt;
    
    </summary>
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/categories/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
    
      <category term="浏览器工作原理与实践" scheme="http://liugezhou.online/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
</feed>
