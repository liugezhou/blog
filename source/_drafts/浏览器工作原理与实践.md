---
title: 浏览器工作原理与实践
date: 2019-09-05 10:15:00
categories:
- web前端
- 优化
tags: 
  -  浏览器工作原理与实践
---
### 导读
##### 本文主要是从极客时间专栏《浏览器工作原理与实践》，对其每一章的学习进行系统性总结，字字干货不啰嗦。
***
<!--more-->

### 浏览器中的JavaScript执行机制 (5讲)
#### 07 | 变量提升：JavaScript代码是按顺序执行的吗？
---
> 本节的主要内容为：
> + JavaScript代码执行过程中，需要先做`变量提升`，而之所以需要实现变量提升，是因为 JavaScript 代码在执行之前需要`先编译`。
> + 在`编译阶段`，变量和函数会被存放到`变量环境`中，变量的默认值会被设置为undefined；在代码执行阶段,JavaScript引擎会从变量环境去查找自定义的变量和函数。
> + 如果在编译阶段，存在两个相同的函数，那么最终存放在变量环境中的是最后定义的那个，这是因为后定义的会覆盖掉之前定义的。

> 这一节的内容主要就是清楚的了解JavaScript的执行机制：`先编译，再执行`.

#### 08 | 调用栈：为什么JavaScript代码会出现栈溢出？
---
> 本节的主要内容为：
> 每调用一个函数，JavaScript 引擎会为其创建执行上下文，并把该执行上下文压入调用栈，然后 JavaScript引擎开始执行函数代码。
> 如果一个函数 A中调用了另一个函数B，那么JavaScript引擎会为B函数创建执行上下文，并将B函数的执行上下文压入栈顶。
> 当函数执行完毕时，JavaScript引擎会将该函数的执行上下文弹出栈。
> 当分配的调用栈空间被占满时，会引发“堆栈溢出”问题。

> 栈是一种非常重要的数据结构，不只在JS中，在其它编程语言，如C++、Java、Python等语言，，在执行过程中也都使用了栈来管理函数之间的调用关系。
#### 09 | 块级作用域：var缺陷以及为什么要引入let和const？
---
> 本节的主要内容为：
> ES6之前，ES的作用域只有两种：全局作用域和函数作用域。
> 作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。
> ES6同时支持变量提升和块级作用域，分别是通过变量环境和词法环境的栈结构来实现的:
>   块级作用域通过词法环境的栈结构来实现，变量提升是通过变量环境来实现的。

#### 10 | 作用域链和闭包 ：代码中出现相同的变量，JavaScript引擎是如何选择的？
---
> 学习本节内容之前首先需要对`调用栈`、`执行上下文`、`变量环境`、`词法环境`的概念弄清楚。
> 本节的主要内容为：
> + 变量是通过作用域链来查找的。
> + 词法作用域：词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系。

> 本节内容概念有点多且理解起来有一些晦涩，必须对JS代码的执行逻辑流程还有一些概念多多熟悉，理解起来才更容易一些。

#### 11 | this：从JavaScript执行上下文的视角讲清楚this
---
> 首先学习this之前，要区分清楚`作用域链`和``this`是两套不同的系统，他们之间基本没太多联系。
> 执行上下文： 变量环境、词法环境、outer、this
> 全局执行上下文中的this：全局执行上下文中的 this 是指向 window 对象的。
> 函数执行上下文中的this：
> > ①、通过函数的call方法设置（bind、apply）
> > ②、通过对象调用方法设置：得出两个结论
> > + 在全局环境中调用一个函数，函数内部的 this 指向的是全局的window.
> > + 通过一个对象来调用其内部的一个方法，该方法的执行上下文中的this指向本身。
> > ③、 通过构造函数中设置:
> > 当执行 var myObj = new CreateObj() 的时候，JavaScript引擎做了四件事：
> > + 首先创建了一个空对象tempObj。
> > + 调用CreateObj对象的call方法，并将tempObj作为call方法的参数，这样当CreateObj的执行上下文创建时，它的this就指向了tempObj对象。
> > + 然后执行CreateObj函数，此时的CreateObj函数执行上下文中的this指向了tempObj对象。
> > + 最后返回tempObj对象。
