---
title: 浏览器工作原理与实践
date: 2019-09-16 10:15:00
categories:
- web前端
- 优化
tags: 
  -  浏览器工作原理与实践
---
### 导读
##### 本文主要是从极客时间专栏《浏览器工作原理与实践》，对其每一章的学习进行系统性总结，字字干货不啰嗦。
***
<!--more-->

### 浏览器中的JavaScript执行机制 (5讲)
#### 07 | 变量提升：JavaScript代码是按顺序执行的吗？
---
> 本节的主要内容为：
> + JavaScript代码执行过程中，需要先做`变量提升`，而之所以需要实现变量提升，是因为 JavaScript 代码在执行之前需要`先编译`。
> + 在`编译阶段`，变量和函数会被存放到`变量环境`中，变量的默认值会被设置为undefined；在代码执行阶段,JavaScript引擎会从变量环境去查找自定义的变量和函数。
> + 如果在编译阶段，存在两个相同的函数，那么最终存放在变量环境中的是最后定义的那个，这是因为后定义的会覆盖掉之前定义的。

> 这一节的内容主要就是清楚的了解JavaScript的执行机制：`先编译，再执行`.

#### 08 | 调用栈：为什么JavaScript代码会出现栈溢出？
---
> 本节的主要内容为：
> 每调用一个函数，JavaScript 引擎会为其创建执行上下文，并把该执行上下文压入调用栈，然后 JavaScript引擎开始执行函数代码。
> 如果一个函数 A中调用了另一个函数B，那么JavaScript引擎会为B函数创建执行上下文，并将B函数的执行上下文压入栈顶。
> 当函数执行完毕时，JavaScript引擎会将该函数的执行上下文弹出栈。
> 当分配的调用栈空间被占满时，会引发“堆栈溢出”问题。

> 栈是一种非常重要的数据结构，不只在JS中，在其它编程语言，如C++、Java、Python等语言，，在执行过程中也都使用了栈来管理函数之间的调用关系。
#### 09 | 块级作用域：var缺陷以及为什么要引入let和const？
---
> 本节的主要内容为：
> ES6之前，ES的作用域只有两种：全局作用域和函数作用域。
> 作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。
> ES6同时支持变量提升和块级作用域，分别是通过变量环境和词法环境的栈结构来实现的:
>   块级作用域通过词法环境的栈结构来实现，变量提升是通过变量环境来实现的。

#### 10 | 作用域链和闭包 ：代码中出现相同的变量，JavaScript引擎是如何选择的？
---
> 学习本节内容之前首先需要对`调用栈`、`执行上下文`、`变量环境`、`词法环境`的概念弄清楚。
> 本节的主要内容为：
> + 变量是通过作用域链来查找的。
> + 词法作用域：词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系。

> 本节内容概念有点多且理解起来有一些晦涩，必须对JS代码的执行逻辑流程还有一些概念多多熟悉，理解起来才更容易一些。

#### 11 | this：从JavaScript执行上下文的视角讲清楚this
---
> 首先学习this之前，要区分清楚`作用域链`和``this`是两套不同的系统，他们之间基本没太多联系。
> 执行上下文： 变量环境、词法环境、outer、this
> 全局执行上下文中的this：全局执行上下文中的 this 是指向 window 对象的。
> 函数执行上下文中的this：
> > ①、通过函数的call方法设置（bind、apply）
> 
> > ②、通过对象调用方法设置：得出两个结论
> > + 在全局环境中调用一个函数，函数内部的 this 指向的是全局的window.
> > + 通过一个对象来调用其内部的一个方法，该方法的执行上下文中的this指向本身。
> 
> > ③、通过构造函数中设置:
> > 当执行 var myObj = new CreateObj() 的时候，JavaScript引擎做了四件事：
> > + 首先创建了一个空对象tempObj。
> > + 调用CreateObj对象的call方法，并将tempObj作为call方法的参数，这样当CreateObj的执行上下文创建时，它的this就指向了tempObj对象。
> > + 然后执行CreateObj函数，此时的CreateObj函数执行上下文中的this指向了tempObj对象。
> > + 最后返回tempObj对象。

### V8工作原理(3讲)
---
#### 12 | 栈空间和堆空间：数据是如何存储的？
> 我们把这种在使用之前就需要确认其变量数据类型的称为`静态语言`。
> 相反地，我们把在运行过程中需要检查数据类型的语言称为`动态语言`。

> 通常把偷偷转换的操作成为隐式类型转换：支持因此类型转换的语言称为`弱类型语言`，不支持隐式类型转换的语言称为`强类语言`。

> 原始数据类型的值都是直接保存在“栈”中，引用数据类型的值是存放在“堆”中的。

#### 13 | 垃圾回收：垃圾数据是如何自动回收的？
---
> 通常情况下：垃圾数据回收分为`手动回收`和`自动回收`两种策略。
> 
> JavaScript、Java、Python 等语言，产生的垃圾数据是由垃圾回收期来释放的，并不需要手动通过代码来释放。
##### 调用栈中的数据是如何回收的
> 在调用栈中，有一个记录当前执行状态的指针(称为ESP),当一个函数执行结束之后，JavaScript引擎会通过向下移动ESP来销毁该函数保存在栈中的执行上下文。
##### 堆中的数据是如何回收的
> 堆中的数据是如何回收的----回收堆中的垃圾数据，需要用到JavaScript中的`垃圾回收期`。
> 
> <b>前置知识点：代际假说的两个特点：</b>(代际假说时垃圾回收领域一个重要的术语)  
> + 第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问。  
> + 第二个是不死的对象，会活的更久。
> 
> 有了代际假说基础，我们便可以探讨V8是如何实现垃圾回收的了：
> 在V8中会把堆分为`新生代`和`老生代`两个区域，新生代存放的是`生存时间极短的对象`，老生代中存放的是`生存时间久的对象`。
> + 副垃圾回收器，主要负责新生代的垃圾回收。
> + 主垃圾回收期，主要负责老生代的垃圾回收。
>
> 接下来我们开始分析<b>垃圾回收期的工作流程</b>   
> V8把堆分成了两个区域，并分别使用不同的垃圾回收期，但不论什么类型回收期，他们使用的是一套共同的执行流程。 
##### 副垃圾回收器
> 新生代中用Scavenge算法来处理：即把新生代空间对半划分为两个区域：一半是`对象区域`，一半是`空闲区域`。 
> 对象区域与回收区域会经过反复的角色翻转操作。 
> JavaScipt引擎采用了对象晋升策略，也就是经过两次垃圾回收仍然存活的对象，会被移动到老生区中。
##### 主垃圾回收器
> 主要负责老生区中的垃圾回收，老生区中的对象有两个特点：一个是对象占用空间大，一个是对象存活时间长。  
> 采用标记-清除(Mark-Sweep)的算法进行垃圾回收。
> 由于碎片过多而导致大对象无法分配到足够的连续内存，于是又产生来另外一种算法--标记-整理(Mark-Compact)。 
> 
> 全停顿：为了降低老生代的垃圾回收而造成的卡顿，V8将标记过程分为一个个的子标记过程，同时让垃圾回收标记和JavaScript应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记(Incremental Marking)算法。

#### 14 | 编译器和解释器：V8是如何执行一段JavaScript代码的？
---
> 了解V8的编译流程能让你对语言以及相关工具有更充分的认识。  
> 深入理解V8的工作原理，这里我们需要搞清楚一些概念和原理：`编译器(Compiler)`、`解释器(Interpreter)`、`抽象语法树(AST)`、`字节码(Bytecode)`、`即时编译器(JIT)`等概念。
##### 编译器和解释器
> 按语言的执行流程，可以把语言划分为编译型语言和解释型语言。  
> `编译型语言`在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。  
> 而由`解释型语言`编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行。
>
##### V8时如何执行一段JavaScript代码的
> V8在执行过程中既有解释器Ignition，也有编译器TurboFan.下面分解其执行流程：  
> 
> 1. 生成抽象`语法树(AST)`和执行上下文。
>  AST的结构和代码的结构非常相似。因此可以把AST看成代码的结构化表示，编译器和解释器后续的工作都需要依赖于AST,而不是源代码。  
>  抽象语法树(AST)的应用：Babel、ESLint。  
> 
> 生成AST需要经过两个阶段：第一阶段是分词(tokenize)，又称为词法分析。第二个阶段是解析(parse)，又称为语法分析。   
> 这就是 AST 的生成过程，先分词，再解析。 
> 有了AST后，接下来V8就会生成该代码的执行上下文。
> 
> 2. 生成`字节码`  
> 第一步的AST和执行上下文搞定后，下一步就是解释器登场，根据AST生成字节码，并解释执行字节码。 
> 说到字节码，其实一开始的时候V8是没有字节码的，而是直接将AST转换为机器码。但是随着Chrome在手机上普及，内存占用问题暴露出来了（这是因为V8需要消耗大量的内存在存放转换后的机器码）。因此为了解决内存占用问题，引入来字节码。
> 
>  <b>字节码就是介于AST和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。</b>
> 
> 3. 执行代码
> 通常，如果有一段第一次执行的字节码，解释器 Ignition会逐条解释执行，若发现有热点代码，那么编译器TurboFan就会把该段热点的字节码编译为高效的机器码，再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了。
> 我们把这种技术称为`即时编译(JIT)`。
##### JavaScript的性能优化
> 在过去几年中，JavaScript的性能得到了大幅提升，这得益于V8团队对解释器和编译器的不断改进和优化。 
> 应该将优化的中心聚焦在单次脚本的执行时间和脚本的网络下载上，主要关注以下三点内容：  
> + 提升单次脚本执行速度 。 
> + 避免大的内联脚本 。 
> + 减少JavScript文件容量。  

### 浏览器中的页面循环系统(4讲)
---
#### 15 | 消息队列和事件循环：页面上怎么“活”起来的？ 
> 如果把一个渲染进程比作一个国家，在线程世界里，我们将主线程比作一个总统。总统公务如此繁忙，当然需要一些得力大臣来帮助统筹调度等，我们这里要说的得力大臣就是要学习的`消息队列`和`事件循环系统`.  
##### 在线程运行中处理新任务
> 要想在线程运行过程中，能接受并执行新的任务，就需要采用事件循环机制。

##### 处理其它线程发送过来的任务
> 处理其它线程发送过来的任务通用模式是消息队列。  
> `消息队列`说一种数据结构，可以存放要执行的任务。它符合队列“先进先出”的特点。

##### 处理其它进程发送过来的任务
> 渲染进程专门有一个IO线程用来接受其他进程传进来的消息。接受到消息后将这些消息组装成任务发送给主线程，后续步骤同上述。

##### 消息队列中的任务类型
> 输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript定时器等等。  
> 消息队列还包含了很多与页面相关的事件：JavaScript执行、解析DOM、样式计算、布局计算、CSS动画等。

